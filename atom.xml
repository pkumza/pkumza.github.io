<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zablog</title>
  <subtitle>疾风知劲草 岁寒见后凋</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zablog.me/"/>
  <updated>2017-12-17T02:53:56.000Z</updated>
  <id>http://zablog.me/</id>
  
  <author>
    <name>Zachary Marv</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几款MarkDown对比</title>
    <link href="http://zablog.me/2017/12/16/markdown/"/>
    <id>http://zablog.me/2017/12/16/markdown/</id>
    <published>2017-12-16T13:00:00.000Z</published>
    <updated>2017-12-17T02:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来比较三款MarkDown工具。入选的三个工具分别叫做<code>马克飞象</code>、<code>小书匠</code>、<code>作业部落Cmd Markdown</code>。入选的必要条件是支持所有的终端，且可以导到其他的笔记平台。单个端的Markdown解析器、或者文本编辑器的插件之类的，不在今天的讨论之列。</p>
<a id="more"></a>
<p>这几款Markdown工具都是国产，各有优劣。下面将给大家具体分析</p>
<h2 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h2><p>印象笔记等笔记平台不在今天的比较队列里，这里首先来讲述一下使用Markdown的痛点所在。</p>
<p>印象笔记其实在格式方面是存在很多问题的。其实印象笔记这个公司在2016年就在融资上出现了很大的问题，确实它的格式在2006年左右还是杀手级的，但是恐怕这个公司已经对兼容性焦头烂额了。</p>
<p>当然，对于一个程序员来说，对于印象笔记最为头疼的地方是它无法写代码。它比IDE等等差的太多，甚至连vim都不如。当你在里面写了两个英文的双引号，则左边的会自动变成中文的左括号。<em><strong>黑人问号？？？</strong></em>这还怎么写代码？！</p>
<p>Wiz笔记作为国内的笔记旗帜，对于Markdown的支持还是令人很欣慰的。早在五年前，我还是Wiz的忠实用户。但是切换Macbook以后，发现这个软件对于Mac段的支持一直不尽如人意，所以后来还是转了印象笔记，并成为印象笔记的忠实付费高级用户。</p>
<p>而且Wiz笔记现在不付费好像是几乎没法用了，这个也是有点不太好呀。</p>
<p>有道云笔记也使用过，但是没有留下太强烈的印象，后来也放弃了。</p>
<p>对于问题，三款Markdown都能够完好的解决，毕竟Markdown嘛，可以用```来写代码的。</p>
<hr>
<h2 id="马克飞象"><a href="#马克飞象" class="headerlink" title="马克飞象"></a>马克飞象</h2><p>马克飞象对于各个客户端做得相对来说比较<code>native</code>，所以算是支持的比较好的。对于同步笔记来说，它并没有把印象笔记的原有内容同步过来。这一方面说是一个问题，另一方面说也是一个优点。毕竟原来的笔记并不是支持这样一个markdown的格式的，而且那么多笔记，总共也得有1000篇了吧，总体弄过来真的比较乱。</p>
<p>现在的问题是这个内容能不能自动同步。但是从“正在从印象笔记载入”字样来看应该没这个顾虑。</p>
<p>缺陷：</p>
<ul>
<li>价格是肯定要放在缺陷里面的。当然，收费没有任何值得指责的，毕竟作者辛辛苦苦为大家提供了很好的产品。但是如果两个产品一样的话，那么我们还是更喜欢拥抱开源的免费的大家庭。</li>
<li>文章在印象笔记端无法编辑。当然这个也确实解决了冲突的问题，但是笔记端只能看不能写也是有点讨厌。</li>
</ul>
<p>对于Markdown的存储方式，在微博上看到作者本人的回复。印象笔记本身的格式是enml，是html兼容的。作者在整个enml的最后增加了一个<code>&lt;center&gt;</code>标签，并且把这个center标签设置为隐藏的，所以我们在印象笔记中看不到相关的内容，但是它真真切切地同步了。至于图片的话，就直接印象笔记兼容的图片嵌入进去了。马克飞象可以通过相应的操作，把整个Markdown还原回来。</p>
<hr>
<h2 id="小书匠"><a href="#小书匠" class="headerlink" title="小书匠"></a>小书匠</h2><p>不可否认的是，小书匠做得确实不错。</p>
<p>这里就不上图了，因为截了个图发现暴露了一些隐私账户。</p>
<p>居然可以把印象笔记的所有内容都同步过来，并且都尝试以Markdown的方式进行打开。</p>
<p>小书匠免费版的功能是最强大的，收费版的费用也并不贵。20元一年，也就一碗帝都牛肉面而已。</p>
<p>小书匠的缺陷，个人认为也是三个编辑器中最大的。首先是它使用了一个比较奇怪的引擎，导致用起来的流畅度不足。</p>
<p>为了省事儿，很多软件的跨平台，实际上都是js的功劳。启示还是有很多js框架做的不错的，譬如 <a href="https://github.com/electron/electron" target="_blank" rel="external">Electron</a>，然而小书匠用的这个是<a href="https://github.com/nwjs/nw.js" target="_blank" rel="external">nwjs</a>。感觉上会稍微不那么原生。最基本的，对于一个Mac用户来说，它不支持最大化就罢了，关闭、满窗口（非最大化）、最小化三个按钮居然还在界面右端，非常不习惯。</p>
<p>不过这些并不足以让我放弃一个编辑器，让我最终放弃它的原因是它对<code>Undo</code>的支持非常差。</p>
<p>假若你输入一段中文<code>今日头条</code>，输入完之后，点击<code>⌘</code>+<code>Z</code>进行Undo操作，你会得到一个字符串<code>jin&#39;ri&#39;tou&#39;tiao</code>，然后不停地点击<code>⌘</code>+<code>Z</code>，这堆英文字母才能挨个消失。这是让人无法忍受的。</p>
<p>而如果你先输入了中文<code>今日头条</code>，然后又使用delete键删除了<code>条</code>，这个时候你的界面上剩下<code>今日头</code>，你会发现你的<code>⌘</code>+<code>Z</code>键完全失效了。这种失灵也完全无法忍受。</p>
<p>这种问题很可能是js本身平台的问题，因为我尝试了网页版，也存在同样的问题。</p>
<p>当然，小书匠也有很多优点。一个是界面确实功能丰富，另外一个是它同步导入印象笔记是可编辑的，而且其markdown部分也作为附件存在了笔记下面。这让人看着安心，自己的信息一定不会丢失。</p>
<hr>
<h2 id="Cmd-Markdown"><a href="#Cmd-Markdown" class="headerlink" title="Cmd Markdown"></a>Cmd Markdown</h2><p>最后是Cmd Markdown，这一款笔记做的也非常好。</p>
<p>它支持Tex的公式，还支持流程图、时序图，甚至还支持甘特图。</p>
<p>不过它还是以自身为主，对于笔记平台的依赖性相对比较低。如果想要同步到印象笔记的话，得专门点击设置，然后用导出的方式来导出到笔记，这个是我不太希望的。我期待的结果是直接点击<code>⌘</code>+<code>S</code>就给我乖乖同步到印象笔记，这个功能，前面两款做的都非常好。</p>
<p>更何况，从cmd markdown导出到印象笔记还需要充会员，连试用的机会都没有，￥90/year。</p>
<p>马克飞象和小书匠都支持非常非常丰富的主题列表，而cmd markdown对主题的支持相对来说简陋了一些，只支持亮暗两种。</p>
<p>cmd markdown的展示还是非常方便的，当文档写得好的话，就直接不需要专门做Keynote了。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些编辑器有一些共同的优点，譬如他们都支持导出，都支持非常程序员喜爱的操作方式，导出方式，保存方式。甚至是把数据仓库都指示了出来。</p>
<p>它们都是全平台的工具，而且都支持加载很快，非常方便的web端，效率比Google Docs高得多。因此，它们都一定程度上解决了印象笔记的痛点，当然，有的时候也会不小心引入新的痛点。</p>
<p>从我的选择上来说，还是选择马克飞象了。</p>
<p>对于效率工具这方面，大家都不要吝惜自己的小钱钱，毕竟这是能够给你带来更大价值的工具。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来比较三款MarkDown工具。入选的三个工具分别叫做&lt;code&gt;马克飞象&lt;/code&gt;、&lt;code&gt;小书匠&lt;/code&gt;、&lt;code&gt;作业部落Cmd Markdown&lt;/code&gt;。入选的必要条件是支持所有的终端，且可以导到其他的笔记平台。单个端的Markdown解析器、或者文本编辑器的插件之类的，不在今天的讨论之列。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Markdown" scheme="http://zablog.me/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Go语言小技巧——合理使用Pool</title>
    <link href="http://zablog.me/2017/12/13/go_pool/"/>
    <id>http://zablog.me/2017/12/13/go_pool/</id>
    <published>2017-12-13T13:00:00.000Z</published>
    <updated>2017-12-13T09:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收一直是Go语言的一块心病，在它执行垃圾回收的时间中，你很难做什么。<br>在垃圾回收压力大的服务中，GC占据的CPU有可能超过2%，造成的Pause经常超过2ms。垃圾严重的时候，秒级的GC也出现过。<br>如果经常临时使用一些大型结构体，可以用Pool来减少GC。</p>
<a id="more"></a>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> structR6 <span class="keyword">struct</span> &#123;</div><div class="line">	B1 [<span class="number">100000</span>]<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> r6Pool = sync.Pool&#123;</div><div class="line">	New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(structR6)</div><div class="line">	&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">usePool</span><span class="params">()</span></span> &#123;</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		sr6 := r6Pool.Get().(*structR6)</div><div class="line">		sr6.B1[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">		r6Pool.Put(sr6)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"pool Used:"</span>, time.Since(startTime))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">standard</span><span class="params">()</span></span> &#123;</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		<span class="keyword">var</span> sr6 structR6</div><div class="line">		sr6.B1[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"standard Used:"</span>, time.Since(startTime))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	standard()</div><div class="line">	usePool()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个含有100000个int值的结构体，在标准方法中，每次均新建，重复10000次，一共需要耗费193ms；<br>如果用完的struct可以废物利用，放回pool中。需要新的结构体的时候，尝试去pool中取，而不是重新生成，重复10000次仅需要693us。<br>这样简单的操作，却节约了99.65%的时间，也节约了各方面的资源。最重要的是它可以有效减少GC CPU和GC Pause。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收一直是Go语言的一块心病，在它执行垃圾回收的时间中，你很难做什么。&lt;br&gt;在垃圾回收压力大的服务中，GC占据的CPU有可能超过2%，造成的Pause经常超过2ms。垃圾严重的时候，秒级的GC也出现过。&lt;br&gt;如果经常临时使用一些大型结构体，可以用Pool来减少GC。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>匿名代理、透传代理和精英代理之间的区别</title>
    <link href="http://zablog.me/2017/12/04/proxy/"/>
    <id>http://zablog.me/2017/12/04/proxy/</id>
    <published>2017-12-04T13:00:00.000Z</published>
    <updated>2017-12-05T02:35:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>匿名代理、透传代理和精英代理之间的区别 / differences between transparent, anonymous and elite proxy<br><a id="more"></a></p>
<p>作为一个代理的普通用户，你也许不知道你在用的代理到底是透明的，匿名的还是精英的。<br>你也许会倾向于使用精英代理，正如它名字指示的那样。那么这几种代理到底有什么区别呢？</p>
<p>首先，代理一般会在HTTP的Header中传输以下3个字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR</div><div class="line">HTTP_X_FORWARDED_FOR</div><div class="line">HTTP_VIA</div></pre></td></tr></table></figure>
<p>REMOTE_ADDR总是发送代理服务器的IP地址。</p>
<h2 id="透传代理"><a href="#透传代理" class="headerlink" title="透传代理"></a>透传代理</h2><p>对于透传代理（Transparent Proxy）来说，你真实IP地址会被放在HTTP_X_FORWARDED_FOR里面。这意味着网站可以知道代理的IP，还知道你真正的IP地址。<br>HTTP_VIA头也会发送，显示你正在使用代理服务器</p>
<h2 id="匿名代理"><a href="#匿名代理" class="headerlink" title="匿名代理"></a>匿名代理</h2><p>匿名代理不会把你的真实IP写在<code>HTTP_X_FORWARDED_FOR</code>头里面。但是HTTP_VIA头还是透露了您正在使用一个代理服务器。</p>
<h2 id="精英代理"><a href="#精英代理" class="headerlink" title="精英代理"></a>精英代理</h2><p>精英代理只发送REMOTE_ADDR头,因此让你看起来像一个普通互联网用户不使用代理。</p>
<h2 id="检测精英代理"><a href="#检测精英代理" class="headerlink" title="检测精英代理"></a>检测精英代理</h2><p>精英代理并非不可以检测。<br>网站可以检查这个IP，是否使用了常用的代理接口（如8080、3128、8080、3128）。</p>
<p>可以使用以下网站来检测你是否匿名:<a href="http://whoer.net/ext" target="_blank" rel="external">http://whoer.net/ext</a> 或 <a href="https://whoer.net/zh#extended" target="_blank" rel="external">https://whoer.net/zh#extended</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;匿名代理、透传代理和精英代理之间的区别 / differences between transparent, anonymous and elite proxy&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="计数随笔" scheme="http://zablog.me/tags/%E8%AE%A1%E6%95%B0%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>爬虫小纪</title>
    <link href="http://zablog.me/2017/11/12/crawler/"/>
    <id>http://zablog.me/2017/11/12/crawler/</id>
    <published>2017-11-12T13:00:00.000Z</published>
    <updated>2017-11-12T13:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近比较繁忙，所以博客也没有什么新文章。<br>说一下爬虫吧。<br>自从互联网时代开始，爬虫就没停止活跃…恐怕今后很长一段时间爬虫都会长期存在。当人们谈到XSS、DDos、SQL injection、SSL attacks的时候，多数你在谈论计算机安全，当你谈到爬虫的时候，你更多的在关心内容安全。爬虫有时候会涉及内容安全，有些内容是别人的立站根本，譬如PGC、UGC的文章；有的内容是别人的商业机密，譬如酒店、商品的价格。</p>
<p>对于爬虫来说，有没有规范定义它不允许爬取的内容呢。有一个文件叫做robots.txt，它是是一种存放于网站根目录下的ASCII编码的文本文件，通常用来告诉搜索引擎的爬取器哪些内容是不应该被获取的。</p>
<p>曾经阿里巴巴有一个很火的网站<a href="http://etao.com/" target="_blank" rel="external">一淘</a>，这个网站的最大优势是可以在线比价。它可以将一件商品在各个平台上的价格放在一起，消费者可以在这里瞬间看到很多平台的价格，从而找到最便宜的。</p>
<p>而更杀手级的功能是，它提供历史价格的功能。譬如对于京东来说，它可以看到京东里面某件商品的价格历史。当前虽然在搞促销，但是也许并非历史最低价格，消费者可能就继续观望了。</p>
<p>这对京东这种商家的损害很大，一淘这样就侵犯京东的商业机密了。京东不希望别人知道一件商品的价格历史。所以，京东的robots.txt设置为了这样：<a href="https://www.jd.com/robots.txt" target="_blank" rel="external">robots.txt</a><br>其中有一条写作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">User-agent: EtaoSpider </div><div class="line">Disallow: /</div></pre></td></tr></table></figure></p>
<p>也就是说，对于Etao的爬虫来说，我不允许你爬取京东的任何内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近比较繁忙，所以博客也没有什么新文章。&lt;br&gt;说一下爬虫吧。&lt;br&gt;自从互联网时代开始，爬虫就没停止活跃…恐怕今后很长一段时间爬虫都会长期存在。当人们谈到XSS、DDos、SQL injection、SSL attacks的时候，多数你在谈论计算机安全，当你谈到爬虫的时候
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="crawler" scheme="http://zablog.me/tags/crawler/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第八期】go-cache</title>
    <link href="http://zablog.me/2017/10/08/github_go-cache/"/>
    <id>http://zablog.me/2017/10/08/github_go-cache/</id>
    <published>2017-10-08T10:00:00.000Z</published>
    <updated>2017-10-09T13:03:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>用Go实现的驻留内存的键值对存储/高速缓存（类似Memcached），适合单机应用 // An in-memory key:value store/cache (similar to Memcached) library for Go, suitable for single-machine applications.<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>go-cache</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/patrickmn/go-cache" target="_blank" rel="external">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td><a href="https://github.com/patrickmn" target="_blank" rel="external">patrickmn</a>等</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>An in-memory key:value store/cache (similar to Memcached) library for Go, suitable for single-machine applications.</td>
</tr>
<tr>
<td>LICENSE</td>
<td>MIT</td>
</tr>
<tr>
<td>starts</td>
<td>1,119</td>
</tr>
</tbody>
</table>
<p>go-cache是一个驻留内存的键值对存储/高速缓存（类似Memcached），适合单机应用。<br>它大致上可以认为是一个线程安全的<code>map[string]interface{}</code>，同时支持时间过期。</p>
<p>任何对象都可以被存储，可以指定过期时间，也可以指定为永久存在。go-cache是线程安全的。</p>
<p>虽然go-cache并非作为持久存储而设计的，但是整个高速缓存的内容可以通过<code>c.Items()</code>序列化以后存储，然后使用<code>NewFrom()</code>重新加载。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/patrickmn/go-cache</div></pre></td></tr></table></figure>
<p>用法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"github.com/patrickmn/go-cache"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// 创建一个默认过期时间为5分钟，清理间隔时间为10分钟的高速缓存</span></div><div class="line">	c := cache.New(<span class="number">5</span>*time.Minute, <span class="number">10</span>*time.Minute)</div><div class="line"></div><div class="line">	<span class="comment">// 设置“foo”键的值为“bar”，默认过期时间</span></div><div class="line">	c.Set(<span class="string">"foo"</span>, <span class="string">"bar"</span>, cache.DefaultExpiration)</div><div class="line"></div><div class="line">	<span class="comment">// 设置“baz”为42，不过期</span></div><div class="line">	<span class="comment">// 如果没有重置或者删除的话，它不会被删除</span></div><div class="line">	c.Set(<span class="string">"baz"</span>, <span class="number">42</span>, cache.NoExpiration)</div><div class="line"></div><div class="line">	<span class="comment">// 获取"foo"对应的字符串</span></div><div class="line">	foo, found := c.Get(<span class="string">"foo"</span>)</div><div class="line">	<span class="keyword">if</span> found &#123;</div><div class="line">		fmt.Println(foo)</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 因为Go是一种静态类型语言，而cache可以存储任何类型，因此可以使用断言来判断任意类型</span></div><div class="line">	foo, found := c.Get(<span class="string">"foo"</span>)</div><div class="line">	<span class="keyword">if</span> found &#123;</div><div class="line">		MyFunction(foo.(<span class="keyword">string</span>))</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">// 需要高性能？那就存指针吧</span></div><div class="line">	c.Set(<span class="string">"foo"</span>, &amp;MyStruct, cache.DefaultExpiration)</div><div class="line">	<span class="keyword">if</span> x, found := c.Get(<span class="string">"foo"</span>); found &#123;</div><div class="line">		foo := x.(*MyStruct)</div><div class="line">			<span class="comment">// ...</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用法相对很简单，实现也不难，具体文档参考<a href="https://godoc.org/github.com/patrickmn/go-cache" target="_blank" rel="external">文档</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用Go实现的驻留内存的键值对存储/高速缓存（类似Memcached），适合单机应用 // An in-memory key:value store/cache (similar to Memcached) library for Go, suitable for single-machine applications.&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>剖析Go的读写锁</title>
    <link href="http://zablog.me/2017/09/27/go_sync/"/>
    <id>http://zablog.me/2017/09/27/go_sync/</id>
    <published>2017-09-27T12:00:00.000Z</published>
    <updated>2017-09-28T02:40:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>源码级剖析Go标准库中的sync.RWMutex。</p>
<a id="more"></a>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>RWMutex，读写锁，又称“读写互斥锁”。<br>读写锁简单来说就是可以由任意数量的读者同时使用，或者只由一个写者使用的锁。</p>
<p>读写锁和互斥量(<code>Mutex</code>)类似，但是比起互斥量有着更高的并行性，它允许多个读者同时读取，因此有一些特殊的应用场景。<br>在并发编程的很多场景下，数据的读取可能比写入更加频繁，这时就要允许多个线程同时读取一块内容。</p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>Go中，RWMutex的零值是一个未加锁的互斥量。</p>
<p>RWMutex使用起来相对比较简单，这里举一个简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	rw := <span class="built_in">new</span>(sync.RWMutex)</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;   <span class="comment">// 建立两个写者</span></div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</div><div class="line">				rw.Lock()</div><div class="line">				<span class="comment">// 写</span></div><div class="line">				rw.Unlock()</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;    <span class="comment">// 建立两个读者</span></div><div class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">3</span>; j++ &#123;</div><div class="line">				rw.RLock()</div><div class="line">				<span class="comment">// 读</span></div><div class="line">				rw.RUnlock()</div><div class="line">			&#125;</div><div class="line">		&#125;()</div><div class="line">	&#125;</div><div class="line">	time.Sleep(time.Second)</div><div class="line">	fmt.Println(<span class="string">"Done"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/joOSIM__Yg" target="_blank" rel="external"><strong>PlayGround</strong></a></p>
<h2 id="一个（神奇）优秀的（大坑）特性"><a href="#一个（神奇）优秀的（大坑）特性" class="headerlink" title="一个（神奇）优秀的（大坑）特性"></a>一个<del>（神奇）</del>优秀的<del>（大坑）</del>特性</h2><blockquote>
<p>读者在读的时候，不能够假定别的读者也能够获得锁。因此，禁止读锁嵌套。</p>
</blockquote>
<p>是不是有点儿绕？下面举个“七秒例”：🌰</p>
<ul>
<li>第一秒：读者1在第1秒成功申请了读锁</li>
<li>第二秒：写者1在第2秒申请写锁，申请失败，阻塞，但它会防止新的读者获锁</li>
<li>第三秒：读者2在第3秒申请读锁，申请失败</li>
<li>第四秒：读者1释放读锁，写者1获得写锁</li>
<li>第五秒：写者1释放写锁，读者2获得读锁</li>
<li>第六秒：读者1再次申请读锁，申请成功，与读者2共享</li>
<li>第七秒：读者1、读者2释放读锁，结束</li>
</ul>
<p>当写锁阻塞时，新的读锁是无法申请的，这可以有效防止写者饥饿。<em>如果一个线程因为某种原因，导致得不到CPU运行时间，这种状态被称之为</em> <strong><em>饥饿</em></strong>。</p>
<p>然而，这种机制也禁止了读锁嵌套。读锁嵌套可能造成死锁：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	rw := <span class="built_in">new</span>(sync.RWMutex)</div><div class="line"></div><div class="line">	<span class="keyword">var</span> deadLockCase time.Duration = <span class="number">1</span></div><div class="line"></div><div class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</div><div class="line">		time.Sleep(time.Second * deadLockCase)</div><div class="line">		fmt.Println(<span class="string">"Writer Try"</span>)</div><div class="line">		rw.Lock()</div><div class="line">		fmt.Println(<span class="string">"Writer Fetch"</span>)</div><div class="line">		time.Sleep(time.Second * <span class="number">1</span>)</div><div class="line">		fmt.Println(<span class="string">"Writer Release"</span>)</div><div class="line">		rw.Unlock()</div><div class="line">	&#125;()</div><div class="line">	fmt.Println(<span class="string">"Reader 1 Try"</span>)</div><div class="line">	rw.RLock()</div><div class="line">	fmt.Println(<span class="string">"Reader 1 Fetch"</span>)</div><div class="line">	time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">	fmt.Println(<span class="string">"Reader 2 Try"</span>)</div><div class="line">	rw.RLock()</div><div class="line">	fmt.Println(<span class="string">"Reader 2 Fetch"</span>)</div><div class="line">	time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">	fmt.Println(<span class="string">"Reader 1 Release"</span>)</div><div class="line">	rw.RUnlock()</div><div class="line">	time.Sleep(time.Second * <span class="number">1</span>)</div><div class="line">	fmt.Println(<span class="string">"Reader 2 Release"</span>)</div><div class="line">	rw.RUnlock()</div><div class="line">	time.Sleep(time.Second * <span class="number">2</span>)</div><div class="line">	fmt.Println(<span class="string">"Done"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读者1和读者2是嵌套关系，按照这种时间安排，上述程序会导致死锁。</p>
<p>而有些死锁的可怕之处就在于，它不一定会发生。假设上面程序中的time.Sleep都是随机的时间，那么这一段代码每次的结果有可能不一致，这会给Debug带来极大的困难。</p>
<p><strong>吾闻读锁莫嵌套，写锁嵌套长已矣</strong>。（读锁嵌套了还有概率成功，写锁嵌套了100%完蛋🏥）</p>
<h2 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h2><p><sub>（源码具体内容、行数，以版本<code>go version 1.8.1</code>为例。）</sub></p>
<p>为了方便理解，可以把所有的<code>if race.Enabled {...}</code>扔掉不看。接下来，我们重述“七秒例”。🌰</p>
<p>第一秒，读者1请求读锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Line41: </div><div class="line">	<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerCount, <span class="number">1</span>) &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="comment">// A writer is pending, wait for it.</span></div><div class="line">		runtime_Semacquire(&amp;rw.readerSem)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>读者数量<code>readerCount</code>开始是0，这个时候加1，变成了1，不符合判负条件所以跳出，成功获得读锁一枚。</p>
<p>第二秒，写者尝试获取写锁。第85行获取w的锁。不管这个读写锁有没有获取成功，先排斥别的写者。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Line85:</div><div class="line">	<span class="comment">// First, resolve competition with other writers.</span></div><div class="line">	rw.w.Lock()</div><div class="line">	<span class="comment">// Announce to readers there is a pending writer.</span></div><div class="line">	r := atomic.AddInt32(&amp;rw.readerCount, -rwmutexMaxReaders) + rwmutexMaxReaders</div><div class="line">	<span class="comment">// Wait for active readers.</span></div><div class="line">	<span class="keyword">if</span> r != <span class="number">0</span> &amp;&amp; atomic.AddInt32(&amp;rw.readerWait, r) != <span class="number">0</span> &#123;</div><div class="line">		runtime_Semacquire(&amp;rw.writerSem)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>刚才说了，一个写者阻塞在这里的时候，也不会让新的读者去读了，所以它干了一件非常坏的事情：<br>把readerCount变成了1-rwmutexMaxReaders。<br>这样就能卡住新来的读者了。<br>接下来，算出r等于1。这意味着有当前有写者存在。<br>因为有读者，所以写者卡在了信号量<code>writerSem</code>上。但是它不甘心啊，心想“等完现在的这几个读者，我就要去写！”，它默默地把现在占有读锁的人记在了<del>小本本</del>rw.readerWait上。在本例子中，readerWait被设置为了1。</p>
<p>第三秒，读者2尝试获得读锁，它又来到了第41行，结果发现读者的数量是1-rwmutexMaxReaders，好吧，它只好卡在信号量<code>readerSem</code>上。</p>
<p>第四秒，读者1调用RUnlock()，它首先把读者数量减一，毕竟自己已经不读了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Line61:</div><div class="line">	<span class="keyword">if</span> r := atomic.AddInt32(&amp;rw.readerCount, <span class="number">-1</span>); r &lt; <span class="number">0</span> &#123;</div><div class="line">		<span class="comment">// A writer is pending.</span></div><div class="line">		<span class="keyword">if</span> atomic.AddInt32(&amp;rw.readerWait, <span class="number">-1</span>) == <span class="number">0</span> &#123;</div><div class="line">			<span class="comment">// The last reader unblocks the writer.</span></div><div class="line">			runtime_Semrelease(&amp;rw.writerSem)</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>在读者数量减一的时候，它发现读者数量是负数，这回读者1明白了，有一个写者在等待写。估计读者1自己已经在这个写者的<del>小本本</del>readerWait上了，因此它把readerWait减一，表示自己不读了。这时候读者1发现自己就是最后一个读者了，所以赶紧祭出writerSem，让写者可以去写。<br>读者1释放了writerSem信号量以后，写者很快就收到了这个提醒，兴高采烈地获得了写锁，开始自己的写作生涯。</p>
<p>读者2还卡着呢…</p>
<p>第五秒，写者1写完了一稿便不想写了，调用Unlock()准备释放读锁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Line114:</div><div class="line">	<span class="comment">// Announce to readers there is no active writer.</span></div><div class="line">	r := atomic.AddInt32(&amp;rw.readerCount, rwmutexMaxReaders)</div><div class="line"></div><div class="line">	<span class="comment">// Unblock blocked readers, if any.</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="keyword">int</span>(r); i++ &#123;</div><div class="line">		runtime_Semrelease(&amp;rw.readerSem)</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>只见他重新为readerCount加上rwmutexMaxReaders，使他重新变为了正数。这个正数恰好也是阻塞的读者的数量。<br>接下来，写者按照这个读者的数量，释放了这么多的readerSem信号量，相当于将所有阻塞的读者一一唤醒。读者2在收到readerSem的那一刻喜极而泣，它终于可以读了。</p>
<p>第六秒，读者1又来了，它把读者数量加1，发现它是正数哎，写者现在又没来，它再次幸运地瞬间获得读锁，与读者2一起读了起来。</p>
<p>第七秒，读者1和读者2都释放了自己的读锁。至此，结束。</p>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><table>
<thead>
<tr>
<th>中文</th>
<th>英文</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>信号量 （也称信号灯）</td>
<td>Semaphore</td>
<td></td>
</tr>
<tr>
<td>条件变量</td>
<td>Condition</td>
<td></td>
</tr>
<tr>
<td>互斥量</td>
<td>Mutex</td>
</tr>
</tbody>
</table>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Semaphore_(programming" target="_blank" rel="external">Wikipedia: Semaphore (programming)</a>)</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;源码级剖析Go标准库中的sync.RWMutex。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第七期】FiraCode</title>
    <link href="http://zablog.me/2017/09/24/github_firacode/"/>
    <id>http://zablog.me/2017/09/24/github_firacode/</id>
    <published>2017-09-24T03:30:00.000Z</published>
    <updated>2017-09-25T03:55:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>具备编程连字功能的等宽字体 // monospaced font with programming ligatures<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>FiraCode</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/gohugoio/hugo" target="_blank" rel="external">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td>tonsky等</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>monospaced font with programming ligatures</td>
</tr>
<tr>
<td>LICENSE</td>
<td>SIL Open Font License 1.1</td>
</tr>
<tr>
<td>starts</td>
<td>17,400</td>
</tr>
</tbody>
</table>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序员在编程的时候会使用很多符号。在某些编程语言中，一个逻辑令牌可能由2至3个字符构成，譬如<code>-&gt;</code>，<code>&lt;=</code>或<code>==</code>。<br>理想情况下，所有的编程语言都应该为操作员设计出完整的Unicode符号，但现在还没有。</p>
<p>Fira代码是Fira Mono字体的扩展，包含一组通用编程多字符组合的连字。这只是一个字体渲染功能：底层代码保持ASCII兼容，这有助于更快地阅读和理解代码。<br>另外，对于某些频繁的序列，如..或//，连字可以让我们纠正间距。</p>
<p>所有特殊字体：<br><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/all_ligatures.png" alt="all_ligatures"></p>
<h2 id="编程样例"><a href="#编程样例" class="headerlink" title="编程样例"></a>编程样例</h2><p>Ruby：<br><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/ruby.png" alt="Ruby"></p>
<p>Elixir:<br><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/elixir.png" alt="elixir"></p>
<p>Go:<br><img src="https://github.com/tonsky/FiraCode/raw/master/showcases/go.png" alt="Go"></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>对于Mac系统来说，安装FiraCode还是比较容易的，只需要运行两条命令即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew tap caskroom/fonts</div><div class="line">brew cask install font-fira-code</div></pre></td></tr></table></figure>
<p>在系统中安装之后，还需要在对应的代码编辑器中进行适配，以VS Code为例，点击<code>⌘</code>+<code>,</code>，然后把以下代码粘贴进去即可：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">"editor.fontFamily": "Fira Code",</div><div class="line">"editor.fontLigatures": true</div></pre></td></tr></table></figure>
<p>届时安装完毕。这时<code>-&gt;</code>的显示就变成了<code>→</code>咯。当然作为等款字体，它和<code>→</code>还不太一样，还是会占据两个字符宽度的。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;具备编程连字功能的等宽字体 // monospaced font with programming ligatures&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>Emoji与Unicode</title>
    <link href="http://zablog.me/2017/09/18/emoji/"/>
    <id>http://zablog.me/2017/09/18/emoji/</id>
    <published>2017-09-18T03:00:00.000Z</published>
    <updated>2017-09-18T06:21:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Unicode的资源是非常宝贵的，而emoji的表情真的是越来越多，那么emoji是如何编码的呢？<br><a id="more"></a><br>在普通的聊天软件中，譬如QQ，一些基本表情是采用普通字符的转义表示。譬如在字符串中检测到<code>[微笑]</code>，就自动替换为表情。<br>但是Emoji是一种特殊的字符，它是真正被编码入Unicode的字符。它在字符集里占据了U+1F300到U+1F9EF中的部分范围。</p>
<p>但是为了实现丰富的Emoji，这种表情不一定只占据一个字符，尤其是为了实现<a href="https://emojipedia.org/neutral/" target="_blank" rel="external">emoji中立</a>的时候，就需要1-2个字符来完成一个表情，最多需要7个字符。</p>
<p>现在用一段代码来举例 ：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></div><div class="line"><span class="keyword">import</span> <span class="string">"unicode/utf8"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	strs := []<span class="keyword">string</span>&#123;<span class="string">`Golang够浪`</span>, <span class="string">`a`</span>, <span class="string">`©`</span>, <span class="string">``</span>, <span class="string">`🐵`</span>, <span class="string">`👲🏻`</span>, <span class="string">`👲🏿`</span>, <span class="string">`💇🏽‍♂️`</span>, <span class="string">`👨‍👨‍👦‍👦`</span>&#125;</div><div class="line">	<span class="keyword">for</span> _, str := <span class="keyword">range</span> strs &#123;</div><div class="line">		fmt.Printf(<span class="string">"%s, rune count:%d, len:%d\n"</span>, str, utf8.RuneCountInString(str), <span class="built_in">len</span>(str))</div><div class="line">		<span class="keyword">for</span> _, theRune := <span class="keyword">range</span> str &#123;</div><div class="line">			fmt.Printf(<span class="string">"%s : 0x%x | "</span>, <span class="keyword">string</span>(theRune), theRune)</div><div class="line">		&#125;</div><div class="line">		fmt.Print(<span class="string">"\n------\n"</span>)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://play.golang.org/p/tnSsUw0nvf" target="_blank" rel="external"><em>到 Playground中运行一下，查看结果</em></a></p>
<p>我们来逐段分析每一个内容。</p>
<p>字串<code>Golang够浪</code>一共有8个字符，其中<code>Golang</code>这六个字符，每个字符在utf8里占据1个字节的空间，而词语<code>够浪</code>中的每个汉字占据3个字节的空间。</p>
<p><code>a</code>这种最基本的内容，在utf8里只占据1个字节，因为它们太常见了，依霍夫曼编码的思路，也必然应当使用短小的编码方式。</p>
<p><code>©</code>是一个相对比较常见的符号，但是又不在0~127这128个最基本的字符中，在utf8中占据2个字节。</p>
<p><code></code>这个字符是苹果公司的logo，别的操作系统不一定能够正确显示，相对来说非常不常见，在utf8中占据3个字节。在Mac系统中，只需要同时按下<code>⇧</code>（shift）+ <code>⌥</code>（option）+ <code>K</code> 即可。</p>
<p><code>🐵</code>是一个猴子emoji表情，在utf8中占据4个字节。多数emoji表情都占据4个字节。</p>
<p><code>👲🏻</code>是一个戴着中国帽的中国男人，它需要由<code>👲</code>戴着中国帽的男人，与<code>🏻</code>黄种肤色放在一起，两个字符拼凑而成，共需要8个字节。</p>
<p>同样地，<code>👲🏿</code>是一个戴着中国帽的黑人男人，它需要由<code>👲</code>戴着中国帽的男人，与<code>🏿</code>黑人肤色放在一起，两个字符拼凑而成，共需要8个字节。</p>
<p><code>💇🏽‍♂️</code>剪头发的棕色人种男人由<code>💇‍</code>剪头发的普通女人加上<code>🏽‍</code>棕色肤色，加上200d连接符，再加上‍♂男性符号，最后加上U+fe0f符号构成，一共耗费17个字节。这一版本的Mac和iOS系统可能还显示不出来，新版本iOS推出以后估计就能显示出来了。</p>
<p>最长的，也是最能够体现中立性质的一个emoji表情是<code>👨‍👨‍👦‍👦</code>，它代表着<code>两个爸爸和两个儿子一家</code>。它由7个字符组成，分别是👨 : U+1f468 普通男人 | ‍ : U+200d 连接符 | 👨 : U+1f468 普通男人 | ‍ : U+200d 连接符 | 👦 : U+1f466  普通男孩 | ‍ : U+200d  连接符 | 👦 : U+1f466 普通男孩 | 组成。</p>
<p>相信这对你理解utf8和unicode概念上的区别也有帮助😆 ~ Enjoy the Emoji!🙂</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>Emoji在不同的平台上的显示是不同的，参考<a href="https://apps.timwhitlock.info/emoji/tables/unicode#block-1-emoticons" target="_blank" rel="external">Emoji Unicode Tables</a>，总体来说Apple的Emoji实现最尊重原版。</p>
<p>Emoji随着时间的推移在不断地丰富，按照年份，版本也在不断整张，参考<a href="http://unicode.org/emoji/charts/emoji-versions.html" target="_blank" rel="external">emoji-versions</a></p>
<p>Unicode 10.0在22个块中使用1,182个字符的表情符号标识，其中1,085个是单个表情符号，26个是区分指示符符号、成对组合形成标志表情符号，12个（＃，*和0-9）是键帽的基本字符emoji序列。</p>
<p>杂项符号和象形图块中768个代码点中的637个被认为是表情符号。补充符号和象形图块中148个代码点中的134个被认为是表情符号。表情符号块中的所有80个代码点都被认为是表情符号。运输和地图符号块中的107个代码点中的94个被认为是表情符号。杂项符号块中的256个代码点中的80个被认为是表情符号。Dingbats块中192个代码点中的33个被认为是表情符号。</p>
<p>所谓<a href="https://emojipedia.org/neutral/" target="_blank" rel="external">emoji中立</a>就是防止歧视。表情应该是无种族的，应该是无性别特异性的，同样一个表情应该拥有各种肤色，有男有女。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://en.wikipedia.org/wiki/Emoji" target="_blank" rel="external">Emoji - Wikipedia</a></li>
<li><a href="https://gist.github.com/x7hub/ecacd20401042d61f68f" target="_blank" rel="external">Emoji表情传输和保存：对非BMP范围的Unicode字符的处理</a></li>
<li><a href="https://apps.timwhitlock.info/emoji/tables/unicode#block-1-emoticons" target="_blank" rel="external">Emoji Unicode Tables</a></li>
<li><a href="http://www.unicode.org/Public/emoji/5.0/emoji-data.txt" target="_blank" rel="external">Emoji 5.0 data</a></li>
<li><a href="https://emojipedia.org/neutral/" target="_blank" rel="external">Emoji中立</a></li>
<li><a href="http://newping.cn/447" target="_blank" rel="external">Mac——如何输入⌘、⌥、⇧、⌃、⎋等特殊字符（链接1）</a>、 <a href="http://blog.sina.com.cn/s/blog_5656bf3e0102w3ic.html" target="_blank" rel="external">（链接2）</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Unicode的资源是非常宝贵的，而emoji的表情真的是越来越多，那么emoji是如何编码的呢？&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第六期】nes</title>
    <link href="http://zablog.me/2017/09/12/github_nes/"/>
    <id>http://zablog.me/2017/09/12/github_nes/</id>
    <published>2017-09-12T09:30:00.000Z</published>
    <updated>2017-09-12T13:12:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个用Go实现的NES模拟器 // NES emulator written in Go.<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>nes</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/fogleman/nes" target="_blank" rel="external">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td>fogleman</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>NES emulator written in Go.</td>
</tr>
<tr>
<td>LICENSE</td>
<td>MIT</td>
</tr>
<tr>
<td>starts</td>
<td>2,816</td>
</tr>
</tbody>
</table>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>这是一个使用Go实现的NES模拟器。</p>
<p><img src="https://camo.githubusercontent.com/528b888320bf91dc045537bd738303937f780e72/687474703a2f2f692e696d6775722e636f6d2f764433465856682e706e67" alt="NES"></p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.com/go-gl/gl/v2.1/gl</div><div class="line">github.com/go-gl/glfw/v3.1/glfw</div><div class="line">github.com/gordonklaus/portaudio</div></pre></td></tr></table></figure>
<p>portaudio-go依赖需要在系统中安装PortAudio</p>
<p>在ubuntu上，需要执行<code>apt-get install portaudio19-0dev</code>即可，在Mac系统，需要执行<code>brew install portaudio</code></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用go get指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go get github.com/fogleman/nes</div></pre></td></tr></table></figure>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nes [rom_file|rom_directory]</div></pre></td></tr></table></figure>
<h2 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h2><p>NES是童年时很多人的挚爱，它的全称是Nintendo Entertainment System，也就是俗称的红白机。当年国内的小霸王就是对NES的盗版。<br>NES上有众多让人印象深刻的游戏，譬如马里奥系列、魂斗罗、松鼠大战、双截龙、泡泡龙等等。那是一个经典游戏的辉煌与井喷的年代。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>本nes工程，是对NES白皮书的一种go的实现。<br>代码中涉及了很多相对底层和硬件的内容，乍一看可能灰色难懂。这里可以循一条线来带你看懂nes的代码。</p>
<p>首先关注主目录下的文件结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">├── LICENSE.md</div><div class="line">├── README.md</div><div class="line">├── main.go</div><div class="line">├── nes</div><div class="line">│   ├── apu.go</div><div class="line">│   ├── cartridge.go</div><div class="line">│   ├── console.go</div><div class="line">│   ├── controller.go</div><div class="line">│   ├── cpu.go</div><div class="line">│   ├── filter.go</div><div class="line">│   ├── ines.go</div><div class="line">│   ├── mapper.go</div><div class="line">│   ├── mapper1.go</div><div class="line">│   ├── mapper2.go</div><div class="line">│   ├── mapper3.go</div><div class="line">│   ├── mapper4.go</div><div class="line">│   ├── mapper7.go</div><div class="line">│   ├── memory.go</div><div class="line">│   ├── palette.go</div><div class="line">│   └── ppu.go</div><div class="line">├── ui</div><div class="line">│   ├── audio.go</div><div class="line">│   ├── director.go</div><div class="line">│   ├── font.go</div><div class="line">│   ├── gameview.go</div><div class="line">│   ├── menuview.go</div><div class="line">│   ├── run.go</div><div class="line">│   ├── texture.go</div><div class="line">│   └── util.go</div><div class="line">└── util</div><div class="line">    └── roms.go</div></pre></td></tr></table></figure>
<p>直接放在root下的代码文件只有main.go，直接决定了nes这个可执行文件运行之后运行的代码。main.go在整个工程里是最易懂的代码了，简单来说就是判断一下参数，然后调用<code>ui.Run(nes文件路径)</code>。这条线索待会继续跟踪…</p>
<p>再来看主目录下面的文件夹们。nes文件夹主要负责nes文件的格式解析支持，ui负责界面与交互，util主要用来测试rom。（个人认为把util放在这里，并且起这个名字，从项目结构上不妥）</p>
<p>下面从nes/ui/run.go入手， 毕竟main函数调用了ui的Run函数，而Run函数可以看做是ui这个包的入口。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// run.go</span></div><div class="line"><span class="keyword">package</span> ui</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"runtime"</span></div><div class="line"></div><div class="line">	<span class="string">"github.com/go-gl/gl/v2.1/gl"</span></div><div class="line">	<span class="string">"github.com/go-gl/glfw/v3.1/glfw"</span></div><div class="line">	<span class="string">"github.com/gordonklaus/portaudio"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">const</span> (</div><div class="line">	width  = <span class="number">256</span></div><div class="line">	height = <span class="number">240</span></div><div class="line">	scale  = <span class="number">3</span></div><div class="line">	title  = <span class="string">"NES"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// we need a parallel OS thread to avoid audio stuttering</span></div><div class="line">	runtime.GOMAXPROCS(<span class="number">2</span>)</div><div class="line"></div><div class="line">	<span class="comment">// we need to keep OpenGL calls on a single thread</span></div><div class="line">	runtime.LockOSThread()</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Run</span><span class="params">(paths []<span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	<span class="comment">// initialize audio</span></div><div class="line">	portaudio.Initialize()</div><div class="line">	<span class="keyword">defer</span> portaudio.Terminate()</div><div class="line"></div><div class="line">	audio := NewAudio()</div><div class="line">	<span class="keyword">if</span> err := audio.Start(); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatalln(err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> audio.Stop()</div><div class="line"></div><div class="line">	<span class="comment">// initialize glfw</span></div><div class="line">	<span class="keyword">if</span> err := glfw.Init(); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatalln(err)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">defer</span> glfw.Terminate()</div><div class="line"></div><div class="line">	<span class="comment">// create window</span></div><div class="line">	glfw.WindowHint(glfw.ContextVersionMajor, <span class="number">2</span>)</div><div class="line">	glfw.WindowHint(glfw.ContextVersionMinor, <span class="number">1</span>)</div><div class="line">	window, err := glfw.CreateWindow(width*scale, height*scale, title, <span class="literal">nil</span>, <span class="literal">nil</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatalln(err)</div><div class="line">	&#125;</div><div class="line">	window.MakeContextCurrent()</div><div class="line"></div><div class="line">	<span class="comment">// initialize gl</span></div><div class="line">	<span class="keyword">if</span> err := gl.Init(); err != <span class="literal">nil</span> &#123;</div><div class="line">		log.Fatalln(err)</div><div class="line">	&#125;</div><div class="line">	gl.Enable(gl.TEXTURE_2D)</div><div class="line"></div><div class="line">	<span class="comment">// run director</span></div><div class="line">	director := NewDirector(window, audio)</div><div class="line">	director.Start(paths)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它所依赖的包就不多说了，与上文所述的依赖一致。</p>
<p>第一个函数是init()函数。看起来这个函数在整个工程中并没有被调用，其实不然。Go里面有两个保留函数，分别是init函数和main函数，其中init函数能够应用于所有的package，而main函数只能应用于main package。当某一个包被引入的时候，首先会引入自身的其他依赖，然后初始化常量，初始化全局变量，接下来就会自动调用这个package的init()函数。</p>
<p>可以在一个package下的多个文件中都定义init()函数，然而这样不是很便于管理，建议每个package最多写一个init()函数。<br>nes的作者就写了很多个init()函数。</p>
<p>init的内容是把runtime.GOMAXPROCS设置为2。runtime.GOMAXPROCS可以认为是Go语言最多使用的核心数目，在不设置的时候默认是1。<br>较大的GOMAXPROCS适合于CPU密集型，且并发度较高的情形。如果是IO密集型，CPU之间的切换反而会带来较大的性能损失。<br>nes中的GOMAXPROCS设置，是为了在执行任务的时候，音效不要卡顿。<br>接下来作者调用了runtime.LockOSThread(),这保证了调用OpenGL的时候，go只有一个线程去访问OpenGL的接口。</p>
<p>在执行Run的时候，NES首先初始化音频部件，然后初始化glfw，接下来使用glfw创建一个窗口，</p>
<p>glfw是一个C的OpenGL库，而<a href="https://github.com/go-gl/glfw/" target="_blank" rel="external">go glfw</a>则是一个典型的C与GO混合开发的一个库。</p>
<p>下面，NES初始化了gl，使用TEXTURE_2D模式。</p>
<p>最终，新建了一个Director，并执行这个Director，至此Run函数结束。</p>
<h2 id="Director"><a href="#Director" class="headerlink" title="Director"></a>Director</h2><p>Director导演的作用主要是对操作进行一个分发。如果当前有游戏的话，那么就加载游戏的GameView；如果是一个大列表，就把列表展示出来，让用户可以选择一个nes游戏执行。</p>
<h2 id="按键"><a href="#按键" class="headerlink" title="按键"></a>按键</h2><p>令人伤感的是，作者把按键适配写死在代码里，而且如果只有键盘的话，只能单人玩，简直是不能忍呀。具体的按键写死的代码在util.go中，有兴趣的小朋友可以给他改了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">readKeys</span><span class="params">(window *glfw.Window, turbo <span class="keyword">bool</span>)</span> [8]<span class="title">bool</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> result [<span class="number">8</span>]<span class="keyword">bool</span></div><div class="line">	result[nes.ButtonA] = readKey(window, glfw.KeyZ) || (turbo &amp;&amp; readKey(window, glfw.KeyA))</div><div class="line">	result[nes.ButtonB] = readKey(window, glfw.KeyX) || (turbo &amp;&amp; readKey(window, glfw.KeyS))</div><div class="line">	result[nes.ButtonSelect] = readKey(window, glfw.KeyRightShift)</div><div class="line">	result[nes.ButtonStart] = readKey(window, glfw.KeyEnter)</div><div class="line">	result[nes.ButtonUp] = readKey(window, glfw.KeyUp)</div><div class="line">	result[nes.ButtonDown] = readKey(window, glfw.KeyDown)</div><div class="line">	result[nes.ButtonLeft] = readKey(window, glfw.KeyLeft)</div><div class="line">	result[nes.ButtonRight] = readKey(window, glfw.KeyRight)</div><div class="line">	<span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码规定Z和X对应红白机的A和B键。</p>
<p>虽然按键不尽如人意，但是fogleman的令人拍案称奇的作品确实还是太多了，估计没时间做nes的按键适配了吧。况且毕竟glfw并不特别方便进行窗口编程。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://stackoverflow.com/questions/25361831/benefits-of-runtime-lockosthread-in-golang" target="_blank" rel="external">Benefits of runtime.LockOSThread in Golang - Stackoverflow</a></li>
<li><a href="https://github.com/golang/go/wiki/LockOSThread" target="_blank" rel="external">LockOSThread</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个用Go实现的NES模拟器 // NES emulator written in Go.&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>Go语言小技巧--二 命名规范</title>
    <link href="http://zablog.me/2017/09/08/go_tricks_and_tips_2/"/>
    <id>http://zablog.me/2017/09/08/go_tricks_and_tips_2/</id>
    <published>2017-09-08T03:00:00.000Z</published>
    <updated>2017-10-09T12:37:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇主要讲述Go语言的命名规范。<br>优秀的代码必须具备良好的可读性，而可读性的关键即在于命名风格。</p>
<a id="more"></a>
<p><a href="http://zablog.me/2017/09/08/go_tricks_and_tips_2/">原文链接: http://zablog.me/2017/09/08/go_tricks_and_tips_2/</a></p>
<h2 id="优秀的命名"><a href="#优秀的命名" class="headerlink" title="优秀的命名"></a>优秀的命名</h2><p>优秀的命名应当是一贯的、短小的、精确的。<br>所谓一贯，就是说同一个意义在不同的环境下的命名应当一致，譬如依赖关系，不要在一个方法中命名为depend，另一个方法中命名为rely。<br>所谓短小，不必多言，当命名过长的时候，读者可能更关注命名本身，而忽视真正的逻辑内容。<br>所谓精确，就是命名达意、易于理解</p>
<h2 id="首条经验"><a href="#首条经验" class="headerlink" title="首条经验"></a>首条经验</h2><p>声明位置与使用位置越远，则命名应当越长。</p>
<h2 id="骆驼命名法"><a href="#骆驼命名法" class="headerlink" title="骆驼命名法"></a>骆驼命名法</h2><p>Go语言应该使用 MixedCase<br>(不要使用 names_with_underscores)<br>首字母缩写词都应该用大写,譬如<code>ServeHTTP</code>、<code>sceneID</code>、<code>CIDRProcessor</code>。</p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><p>局部变量应当尽可能短小，譬如使用<code>buf</code>指代<code>buffer</code>，使用<code>i</code>指代<code>index</code><br>在很长的函数中可能会有很多的变量，这个时候可以适当使用一些长名字。<br>但是写出这么长的函数，通常意味着代码需要重构了！🙅🏻‍</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p>函数的参数和局部变量类似，但是它们默认还具有文档的功能<br>当参数类型具有描述性的时候，参数名就应该尽可能短小：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">AfterFunc</span><span class="params">(d Duration, f <span class="keyword">func</span>()</span>) *<span class="title">Timer</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">Escape</span><span class="params">(w io.Writer, s []<span class="keyword">byte</span>)</span></span></div></pre></td></tr></table></figure>
<p>当参数类型比较模糊的时候，参数名就应当具有文档的功能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unix</span><span class="params">(sec, nsec <span class="keyword">int64</span>)</span> <span class="title">Time</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">HasPrefix</span><span class="params">(s, prefix []<span class="keyword">byte</span>)</span> <span class="title">bool</span></span></div></pre></td></tr></table></figure>
<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>在Go语言中，返回值可以定义名称的，它可以当做一种特殊的参数。<br>尤其重要的是，在外部可见的函数中，返回值的名称应当可以作为文档参考。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">Copy</span><span class="params">(dst Writer, src Reader)</span> <span class="params">(written <span class="keyword">int64</span>, err error)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="title">ScanBytes</span><span class="params">(data []<span class="keyword">byte</span>, atEOF <span class="keyword">bool</span>)</span> <span class="params">(advance <span class="keyword">int</span>, token []<span class="keyword">byte</span>,</span></span></div><div class="line"><span class="function"><span class="params"> err error)</span></span></div></pre></td></tr></table></figure>
<h2 id="方法接收者（Receiver）"><a href="#方法接收者（Receiver）" class="headerlink" title="方法接收者（Receiver）"></a>方法接收者（Receiver）</h2><p>方法接收者也是一种特殊的参数。Go语言中没有明显的面向对象的概念，可以对方法定义方法接收者来实现类似于对象的方法的概念。</p>
<p>按照惯例，由于方法接收者在函数内部经常出现，因此它经常采用一两个字母来标识方法接收者的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="params">(sh serverHandler)</span> <span class="title">ServeHTTP</span><span class="params">(rw ResponseWriter, req *Request)</span></span></div><div class="line"><span class="function"></span></div><div class="line"><span class="function"><span class="title">func</span> <span class="params">(r Rectangle)</span> <span class="title">Size</span><span class="params">()</span> <span class="title">Point</span></span></div></pre></td></tr></table></figure>
<p>需要注意的是，方法接收者的名字在同一类型的不同方法中应该保持统一，这也是前文所述的一贯性的需求。</p>
<h2 id="导出包级别命名"><a href="#导出包级别命名" class="headerlink" title="导出包级别命名"></a>导出包级别命名</h2><p>导出名被使用的时候通常是放在包名后<br>所以，在导出变量、常数、函数和类型的时候，<br>不要把包名的意义再写一遍</p>
<p>比较好的名字<br><code>bytes.Buffer</code> <code>strings.Reader</code></p>
<p>比较蠢的名字<br><code>bytes.ByteBuffer</code> <code>strings.StringReader</code></p>
<h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><p>只含有一个方法的接口类型通常以函数名加上<code>er</code>后缀作为名字</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</div><div class="line">    Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候可能导致蹩脚的英文，但别管他，能看懂就好</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Execer <span class="keyword">interface</span> &#123;</div><div class="line">    Exec(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候可以适当调整一下英文单词的顺序，增加可读性：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ByteReader <span class="keyword">interface</span> &#123;</div><div class="line">    ReadByte(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当接口含有多个方法的时候，还是要选取一个能够精准描述接口目的的名字，譬如<code>net.Conn</code>、<code>http/ResponseWriter</code></p>
<h2 id="Error的命名"><a href="#Error的命名" class="headerlink" title="Error的命名"></a>Error的命名</h2><p>Error类型应该写成FooError的形式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> ExitError <span class="keyword">struct</span> &#123;</div><div class="line">	....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Error变量协程ErrFoo的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var ErrFormat = errors.New(&quot;unknown format&quot;)</div></pre></td></tr></table></figure>
<h2 id="包的命名"><a href="#包的命名" class="headerlink" title="包的命名"></a>包的命名</h2><p>应当与它导出代码的内容相关，避免<code>util</code>、<code>common</code>这种宽泛的命名</p>
<h2 id="引入路径"><a href="#引入路径" class="headerlink" title="引入路径"></a>引入路径</h2><p>包路径的最后一个单词应该和包名一致</p>
<p>包路径应该尽可能简洁</p>
<p>记得把库的主要代码直接放在代码库的根目录</p>
<p>避免在包路径中使用任何大写字母（并非所有文件系统都区分大小写）</p>
<h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><p>上述很多例子都是从标准库中来的</p>
<p>标准库的很多内容都可以作为参考<br>多看看标准库来寻求灵感吧</p>
<p>但是要记住：</p>
<p>当作者写标准库的时候，他们自己也在学习过程中。<br>多数情况下作者是对的，但是偶尔还是会犯一些错误</p>
<p><hr></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://talks.golang.org/2014/names.slide" target="_blank" rel="external">What’s in a name? - Andrew Gerrand</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇主要讲述Go语言的命名规范。&lt;br&gt;优秀的代码必须具备良好的可读性，而可读性的关键即在于命名风格。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>Go语言小技巧--一 技巧杂烩</title>
    <link href="http://zablog.me/2017/09/04/go_tricks_and_tips/"/>
    <id>http://zablog.me/2017/09/04/go_tricks_and_tips/</id>
    <published>2017-09-04T13:00:00.000Z</published>
    <updated>2017-10-09T12:37:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>七个Go语言小技巧，后续持续更新。<br>无论是Go语言小白，还是有经验的开发者，都可能从中获取灵感。</p>
<a id="more"></a>
<h2 id="一句话技巧"><a href="#一句话技巧" class="headerlink" title="一句话技巧"></a>一句话技巧</h2><ul>
<li>把你面向对象的大脑扔到家里吧，去拥抱接口。<a href="https://twitter.com/mikegehard" target="_blank" rel="external">@mikegehard</a></li>
<li>学习如何使用Go的方式做事，不要把别的的编程风格强行用在Go里面。<a href="https://twitter.com/drnic" target="_blank" rel="external">@DrNic</a></li>
<li>多用接口总比少用好。<a href="https://twitter.com/evanphx" target="_blank" rel="external">@evanphx</a></li>
<li>拥抱这种简洁、并行、工整的语言。<a href="">@francesc</a></li>
<li>阅读官网<a href="http://golang.org/" target="_blank" rel="external">golang.org</a>上所有的文档，真是棒呆了。<a href="https://twitter.com/vbatts" target="_blank" rel="external">@vbatts</a></li>
<li>别忘了用<code>gofmt</code>。<a href="https://twitter.com/darkhelmetlive" target="_blank" rel="external">@darkhelmetlive</a></li>
<li>多读源代码。<a href="https://twitter.com/drnic" target="_blank" rel="external">@DrNic</a></li>
<li>学习工具和组件，然后创造你自己的！码代码和学代码一样对成功必不可少。<a href="https://twitter.com/coreyprak" target="_blank" rel="external">@coreyprak</a></li>
<li>学而不思则罔，思而不学则殆。<a href="https://www.zhihu.com/question/21111579" target="_blank" rel="external">《论语》</a></li>
</ul>
<h2 id="引入package的多种方式"><a href="#引入package的多种方式" class="headerlink" title="引入package的多种方式"></a>引入package的多种方式</h2><p>有几种非常规方式来引入包（package）。接下来我会使用<code>fmt</code>来作为例子：</p>
<ul>
<li><code>import format &quot;fmt&quot;</code> - 为<code>fmt</code>创造一个别名。把代码中所有使用到<code>fmt</code>的内容用<code>format.</code>代替<code>fmt.</code></li>
<li><code>import . &quot;fmt&quot;</code> - 允许包内的内容不加<code>fmt</code>前缀而被被直接引用</li>
<li><code>import _ &quot;fmt&quot;</code> - 阻止编译器为引入<code>fmt</code>却不使用里面的内容做引发的警告，执行package中的初始化函数。提醒一句，在这种情况下<code>fmt</code>是不可调用的</li>
</ul>
<p>看这篇<a href="http://learngowith.me/alternate-ways-of-importing-packages/" target="_blank" rel="external">博客</a>来了解更多细节。</p>
<h2 id="Goimports"><a href="#Goimports" class="headerlink" title="Goimports"></a>Goimports</h2><p>命令<code>goimports</code>可以更新您的Go导入行，添加缺少的行，并删除未引用的引导行。</p>
<p>它拥有和<code>gofmt</code>(插入式替换)相同的能力，但是<code>goimports</code>额外增加了修复imports的功能。</p>
<h2 id="组织"><a href="#组织" class="headerlink" title="组织"></a>组织</h2><p>Go是一种相对来说易学习的编程语言，但对于开发者来说，起初接触这门语言最困难的事情就是如何组织代码。<code>scaffolding</code>是人们喜欢<code>Rails</code>的原因之一，它可以给新晋的开发者清晰的方向，让他们明白在哪里插入代码，应该遵循怎样的编程风格。</p>
<p>作为扩展，Go使用<code>go fmt</code>这样的工具来提供开发者相同的功能。同样地，Go的编译器非常严格，它不会去编译没有使用的变量，或者没有使用的import声明。</p>
<h2 id="自定义构造函数"><a href="#自定义构造函数" class="headerlink" title="自定义构造函数"></a>自定义构造函数</h2><p>我经常听到别人问，“我什么时候应该使用像<code>NewJob</code>这样的自定义构造函数？”，我的回答是“大多数情形下你没必要这么做”。然而，当你需要在初始化的时候就设置值，且你有一些默认值的时候，这就最好使用一个构造函数。在这个例子中，构造函数就比较有意义了，因此我们用如下的代码可以构建一个默认的logger：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"log"</span></div><div class="line">	<span class="string">"os"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> Job <span class="keyword">struct</span> &#123;</div><div class="line">	Command <span class="keyword">string</span></div><div class="line">	*log.Logger</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewJob</span><span class="params">(command <span class="keyword">string</span>)</span> *<span class="title">Job</span></span> &#123;</div><div class="line">	<span class="keyword">return</span> &amp;Job&#123;command, log.New(os.Stderr, <span class="string">"Job: "</span>, log.Ldate)&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	NewJob(<span class="string">"demo"</span>).Print(<span class="string">"starting now..."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="把代码分解到不同的package中"><a href="#把代码分解到不同的package中" class="headerlink" title="把代码分解到不同的package中"></a>把代码分解到不同的package中</h2><p>参考这篇博客<a href="http://matt.aimonetti.net/posts/2014/04/28/refactoring-go-code/" target="_blank" rel="external">重构Go代码</a>，第一部分就讲了package的组织。</p>
<p>以工程<code>Gobot</code>为例，它可以被分割为一个核心package和一些其他package。gobot的开发者们准备每个部分放在自己的package里。经过讨论，他们选择把所有的官方库放在同一个repository下，让import路径变得干净而富有逻辑。</p>
<p>所以，他们不打算把路径设置为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.com/hybridgroup/gobot</div><div class="line">github.com/hybridgroup/gobot-sphero</div><div class="line">github.com/hybridgroup/gobot-...</div></pre></td></tr></table></figure>
<p>而是设置为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">github.com/hybridgroup/gobot</div><div class="line">github.com/hybridgroup/gobot/sphero</div><div class="line">github.com/hybridgroup/gobot/...</div></pre></td></tr></table></figure>
<p>现在package的名字不再是冗长的gobot-sphero，而变成了简要的sphero。</p>
<h2 id="集合（Sets）"><a href="#集合（Sets）" class="headerlink" title="集合（Sets）"></a>集合（Sets）</h2><p>在其他的程序语言中，经常会有一种数据结构叫做sets，它允许把元素存入，但是不允许重复。Go并不直接支持这种结构，但是这个结构在Go里面的实现并不困难。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// UniqStr returns a copy if the passed slice with only unique string results.</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">UniqStr</span><span class="params">(col []<span class="keyword">string</span>)</span> []<span class="title">string</span></span> &#123;</div><div class="line">	m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> col &#123;</div><div class="line">		<span class="keyword">if</span> _, ok := m[v]; !ok &#123;</div><div class="line">			m[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	list := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="built_in">len</span>(m))</div><div class="line"></div><div class="line">	i := <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> m &#123;</div><div class="line">		list[i] = v</div><div class="line">		i++</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> list</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://play.golang.org/p/AtG9pTe8yt" target="_blank" rel="external">Playground链接</a></p>
<p>在这里，我会使用一些非常有意思的花招。首先，对空结构的映射：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div></pre></td></tr></table></figure>
<p>我们创建了一个<code>map</code>，这可以确保<code>key</code>是独一无二的，而相关联的<code>value</code>其实是我们不关心的。<br>我们当然可以使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>但是，使用空结构体可以达到同样的效率，同时不会占用额外的内存。</p>
<p>第二个花招的意味更为深远：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> _, ok := m[v]; !ok &#123;</div><div class="line">  m[v] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里做的事情就是确认map <code>m</code>中的某个值是否存在，而不关心<code>value</code>本身。如果发现没有对应的值，就去加一个。当然，不去验证直接加好像也没有什么区别。</p>
<p>一旦我们拥有了一个充满独一无二key的map以后，就可以把他们放到一个切片里，返回结果了。</p>
<p>这里有一段测试代码，正如你所见，这里使用了一个符合Go语言单元测试风格的表格测试：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestUniqStr</span><span class="params">(t *testing.T)</span></span> &#123;</div><div class="line"></div><div class="line">	data := []<span class="keyword">struct</span>&#123; in, out []<span class="keyword">string</span> &#125;&#123;</div><div class="line">		&#123;[]<span class="keyword">string</span>&#123;&#125;, []<span class="keyword">string</span>&#123;&#125;&#125;,</div><div class="line">		&#123;[]<span class="keyword">string</span>&#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">""</span>&#125;&#125;,</div><div class="line">		&#123;[]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"a"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"a"</span>&#125;&#125;,</div><div class="line">		&#123;[]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;&#125;,</div><div class="line">		&#123;[]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;&#125;,</div><div class="line">		&#123;[]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;&#125;,</div><div class="line">		&#123;[]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"b"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>&#125;&#125;,</div><div class="line">		&#123;[]<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, []<span class="keyword">string</span>&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;&#125;,</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span> _, exp := <span class="keyword">range</span> data &#123;</div><div class="line">		res := UniqStr(exp.in)</div><div class="line">		<span class="keyword">if</span> !reflect.DeepEqual(res, exp.out) &#123;</div><div class="line">			t.Fatalf(<span class="string">"%q didn't match %q\n"</span>, res, exp.out)</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过测试发现，并非每次都能够成功，而是有概率的。因为map是使用hashmap实现的，使用range进行遍历的时候，其遍历顺序和字符串的内容没有必然联系，因此此test有可能失败。在进行DeapEqual比对的时候，可能会爆出类似于<code>[&quot;b&quot; &quot;c&quot; &quot;a&quot;] didn&#39;t match [&quot;a&quot; &quot;b&quot; &quot;c&quot;]</code>的错误。当然，在<a href="https://play.golang.org/p/elRIpSKGjD" target="_blank" rel="external">Playground</a>中，每次执行的上下文环境一模一样，因此这里的test是总能通过的。</p>
<h2 id="依赖包管理"><a href="#依赖包管理" class="headerlink" title="依赖包管理"></a>依赖包管理</h2><p>很遗憾，Go语言官方并不提供依赖包管理系统。这很可能是因为go语言植根于C语言的文化，因此它没有办法引入特定版本的包。</p>
<p>这会带来一些严重的问题：</p>
<ol>
<li>当多个开发者共同维护一个项目时，不同开发者的依赖版本可能不同。</li>
<li>依赖也会有他们自身的依赖，所以很难确保所有的依赖都使用同一个版本。</li>
<li>你的多个项目基于了同一个依赖的不同版本。</li>
</ol>
<p>对于最后一种情形，可以通过搭建一个_持续集成环境(Continuous<em>integration)</em>来解决，但是前两者就相对困难。</p>
<p><hr></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://www.golangbootcamp.com/book/tricks_and_tips" target="_blank" rel="external"><em>GO BOOTCAMP - Everything you need to know to get started with Go : Tips and Tricks</em></a></li>
<li><a href="https://www.zhihu.com/question/21111579" target="_blank" rel="external">论语</a></li>
<li><a href="http://matt.aimonetti.net/posts/2014/04/28/refactoring-go-code/" target="_blank" rel="external">refactoring Go code</a></li>
<li><a href="http://learngowith.me/alternate-ways-of-importing-packages/" target="_blank" rel="external">Alternate Ways of Importing Packages</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;七个Go语言小技巧，后续持续更新。&lt;br&gt;无论是Go语言小白，还是有经验的开发者，都可能从中获取灵感。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第五期】免费编程书</title>
    <link href="http://zablog.me/2017/09/01/github_free-programming-books/"/>
    <id>http://zablog.me/2017/09/01/github_free-programming-books/</id>
    <published>2017-09-01T10:00:00.000Z</published>
    <updated>2017-10-09T12:49:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>📚 免费的编程书 // 📚 Freely available programming books<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>Freely available programming books</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/EbookFoundation/free-programming-books" target="_blank" rel="external">Github</a></td>
</tr>
<tr>
<td>组织</td>
<td>EbookFoundation</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>📚 Freely available programming books</td>
</tr>
<tr>
<td>LICENSE</td>
<td>Creative Commons Attribution 4.0 International License</td>
</tr>
<tr>
<td>starts</td>
<td>92,214</td>
</tr>
</tbody>
</table>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>这周比较忙，所以就不介绍一些需要深入了解的Repo了，写一个比较水的，但是点赞数特别多的。</p>
<p>这一个Repo在Github上的Star数目为92.2k，为世界第三，但是对应的编程语言却是空。如果非要说一种语言的话，那么这个repo是用markdown来组成的。</p>
<p>里面免费的书籍实在是太多了，汇集各种语言、各类领域的计算机类免费书籍，支持的语言也有26种之多，大家可以重点关注一下<a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="external">中文书籍</a>和<a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books.md" target="_blank" rel="external">英文书籍</a></p>
<p>顺便一提下，想搜搜看Github上最最最最最火的Repo，点<a href="https://github.com/search?o=desc&amp;q=stars%3A%3E1000&amp;s=stars&amp;type=Repositories&amp;utf8=%E2%9C%93" target="_blank" rel="external">这个链接</a>就可以了。越火的repo，相关介绍也就越多，中文版的也有，所以接下来一般不会选择太火的介绍。如果又介绍了个，只能说明近期较忙啦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;📚 免费的编程书 // 📚 Freely available programming books&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第四期】hugo</title>
    <link href="http://zablog.me/2017/08/27/github_hugo/"/>
    <id>http://zablog.me/2017/08/27/github_hugo/</id>
    <published>2017-08-27T09:30:00.000Z</published>
    <updated>2017-08-27T09:32:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个用Go实现的快速灵活的静态页面生成工具 // A Fast and Flexible Static Site Generator built with love in GoLang.<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>hugo</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/gohugoio/hugo" target="_blank" rel="external">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td>spf13等</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>A Fast and Flexible Static Site Generator built with love in GoLang.</td>
</tr>
<tr>
<td>LICENSE</td>
<td>Apache 2.0</td>
</tr>
<tr>
<td>starts</td>
<td>19,204</td>
</tr>
</tbody>
</table>
<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><img src="https://raw.githubusercontent.com/gohugoio/hugoDocs/master/static/img/hugo-logo.png" alt="HUGO"></p>
<p>Hugo 是一个快速灵活的静态页面生成工具。它在速度、易用性和可配置性上进行了优化。Hugo可以把一个包含内容、模板的文件夹渲染为一个完整的HTML网站。</p>
<p>Hugo基于Markdown文件。</p>
<p>Hugo可以在瞬间渲染出一个中等大小的网站。从经验来看，每一片内容的渲染只需要大概1微秒。</p>
<p>Hugo设计之初就是为了服务于博客、tumbles和文档。</p>
<p><a href="http://gohugo.io/" target="_blank" rel="external">官网gohugo.io</a></p>
<h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>hugo和hexo可以说是功能类似。</p>
<p>hexo是离线生成博客网页的工具，由js实现，基于node和npm这一套提醒。可以方便地生成整个博客，渲染markdown，使用theme。</p>
<p>然而，hexo也存在很多问题，第一是生成速度慢。生成速度和theme有很大关系，但是确实比较慢。最艰难的时候，我曾经每次写一篇新的博客，都需要大概10秒钟以上的时间来生成所有的静态页面。后来换了一个theme，更新了hexo，100个页面，加载时间长达1000ms，生成时间大概是231ms。</p>
<p>但是hugo在时间上有很大的优势，每次只需要90ms就解决所有的问题，快了十几倍。</p>
<p>另外，hexo的theme与主hexo的兼容性还有待商榷。有一些主题的兼容性很差，尤其是hexo更新以后，也许就不怎么支持了。</p>
<p>最后也是最重要的，npm的网络实在不敢恭维，很多时候爆出WARN、Error或者直接下载失败，也就真的卡在npm这里了。对于go来说，本身go的包管理，我认为会比npm好用。</p>
<p>当然，hexo我已经用了较长时间了，总体也比较熟练。如果没有使用过hexo，但是想要做一个静态博客的话，我建议使用hugo。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个用Go实现的快速灵活的静态页面生成工具 // A Fast and Flexible Static Site Generator built with love in GoLang.&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第三期】go.uuid</title>
    <link href="http://zablog.me/2017/08/18/github_go.uuid/"/>
    <id>http://zablog.me/2017/08/18/github_go.uuid/</id>
    <published>2017-08-18T12:30:00.000Z</published>
    <updated>2017-08-18T14:02:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>go语言UUID包 // UUID package for Go</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>名称</th>
<th>go.uuid</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/satori/go.uuid" target="_blank" rel="external">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td>satori等</td>
</tr>
<tr>
<td>brief intro</td>
<td>UUID package for Go</td>
</tr>
<tr>
<td>简要介绍</td>
<td>go语言UUID包</td>
</tr>
<tr>
<td>LICENSE</td>
<td>MIT</td>
</tr>
<tr>
<td>Stars</td>
<td>1304</td>
</tr>
</tbody>
</table>
<h2 id="什么是UUID"><a href="#什么是UUID" class="headerlink" title="什么是UUID"></a>什么是UUID</h2><p>UUID的全称是universally unique identifier，全局唯一认证，它是一个128比特的数字，用来辨认计算机系统中的信息。术语GUID也是这个意思。</p>
<p>UUID的终极目的是“独特性”,它不希望依赖中央注册机构或协调双方之间产生这种独特性,与大多数其他编号计划。虽然UUID将重复的概率不为零，但是它接近于零，因此可以忽略不计。</p>
<p>在命令行，有简单的产生UUID的方法，在Unix/Linux系统中，只要简单的执行uuidgen就可以获得一个新的UUID字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ uuidgen</div><div class="line">7d976a86-8414-11e7-8ac3-6c92bf136d47</div></pre></td></tr></table></figure>
<p>UUID是128比特的数字，如果用16进制表示的话，可以表示为一个32位的十六进制数。一般在格式化的时候，格式化为<code>8-4-4-4-12</code>的形式，如</p>
<p><code>123e4567-e89b-12d3-a456-426655440000</code><br><code>xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx</code></p>
<h2 id="为什么要有UUID"><a href="#为什么要有UUID" class="headerlink" title="为什么要有UUID"></a>为什么要有UUID</h2><p>在分布式系统中，因为通信、同步、保持一致性具有很高的成本，所以一些场景下希望不依靠通信就可以生成唯一的身份验证符号。</p>
<h2 id="如何产生UUID"><a href="#如何产生UUID" class="headerlink" title="如何产生UUID"></a>如何产生UUID</h2><p>那么这样一个UUID是如何产生的呢？</p>
<p>中国是一个超大规模的国家，如果每个人生成自己的身份证，都需要到相互协调，那么全国肯定一团糟，如果每个人都到中央注册机构来确定独特性的话，那么中央注册机构肯定被挤爆。那么身份证的生成办法是分配前几位数为地区，分配中间几位为时间，后面三位用于一个区域内确定唯一性，最后一位校验即可。这样就可以相对方便地产生唯一的身份号码了。</p>
<p>同样地，MAC地址和蓝牙地址的确定也是类似的策略，前面的位数是厂商号，后面的位数由厂商内部决定，这样就避免了冲突。</p>
<p>实际上，UUID的国际标准<a href="https://tools.ietf.org/html/rfc4122" target="_blank" rel="external"><strong>RFC 4122</strong></a>定义了5个版本的生成方式。</p>
<h4 id="版本1"><a href="#版本1" class="headerlink" title="版本1"></a>版本1</h4><p>根据时间和MAC地址生成。版本1会把48比特的MAC地址和60比特的时间戳串联起来。<br>这个时间戳是从1582年10月15日午夜UTC时间起算起的纳秒数目。<br>按照<code>RFC4122</code>的规定，这个时间可以延续到大概公元3400年。<br>然而，一些软件，譬如libuuid库，把时间戳作为非负数类型使用，在这种方法下可以使用到公元5236年。</p>
<h4 id="版本2"><a href="#版本2" class="headerlink" title="版本2"></a>版本2</h4><p>根据时间和MAC地址生成，并使用POSIX UID/GID，DCE安全版本。<br>版本2和版本1很类似，除了最重要的八个时钟序列字节被替换为了本地域的数字，最护重要的32个时间戳被替换为与本地域对应的整形数字。在POSIX系统上，它与UID和GID有关。在非POSIX系统上，就靠系统自己定义了。</p>
<h4 id="版本3"><a href="#版本3" class="headerlink" title="版本3"></a>版本3</h4><p>哈希命名空间和名字，使用MD5作为哈希算法。<br>版本3的生成方法是哈希命名空间的标识符和名字。命名空间标识符本身就是一个UUID，该规格提供UUID来标识URL的命名空间等作用。</p>
<h4 id="版本4"><a href="#版本4" class="headerlink" title="版本4"></a>版本4</h4><p>随机生成。<br>忘了说，上述所有版本生成的UUID都有字段来规定自己的版本。所以并非128比特都是可以任意使用的。<br>对于随机生成的版本4UUID，理论上有2<sup>122</sup>, 或者说5.3x10<sup>36</sup>种可能性。</p>
<h4 id="版本5"><a href="#版本5" class="headerlink" title="版本5"></a>版本5</h4><p>哈希命名空间和名字，使用SHA1作为哈希算法。和版本3特别类似。因为SHA1算法产生的字串是160bit，比MD5长，所以强行缩短为128位再插入。</p>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>在版本1或者2中，因为是和独一无二的MAC地址相关的，所以只要MAC地址不冲突，则UUID不可能冲突。当然MAC地址是可以伪造的，那个时候冲突就不在我们的讨论范围了。</p>
<p>但是其他版本的是有可能产生冲突的。譬如版本4，完全依靠随机性来产生，两个UUID一模一样是存在理论可能的。<br>然而，因为位数较多，所以这个可能性极低。<br>经过计算，产生的2.71x10<sup>18</sup>个UUID，有50%的概率会拥有至少一个冲突。</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d5e4534ec6aac67d0d084e7aa8e431d2baed988e" alt="UUID冲突公式"></p>
<p>这概率可以说实在是太低了，一般应用场景不会有这种问题。</p>
<h2 id="go-uuid"><a href="#go-uuid" class="headerlink" title="go.uuid"></a>go.uuid</h2><p>最后来讲解一下这个库的用法。这个库相对比较优势的地方就是它实现了<code>RFC4122</code>规定的所有版本，虽然并没有很难哈哈。<br>使用样例很简单，这里是版本4，也是最简单的用法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"github.com/satori/go.uuid"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	<span class="comment">// Creating UUID Version 4</span></div><div class="line">	u1 := uuid.NewV4()</div><div class="line">	fmt.Printf(<span class="string">"UUIDv4: %s\n"</span>, u1)</div><div class="line"></div><div class="line">	<span class="comment">// Parsing UUID from string input</span></div><div class="line">	u2, err := uuid.FromString(<span class="string">"6ba7b810-9dad-11d1-80b4-00c04fd430c8"</span>)</div><div class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</div><div class="line">		fmt.Printf(<span class="string">"Something gone wrong: %s"</span>, err)</div><div class="line">	&#125;</div><div class="line">	fmt.Printf(<span class="string">"Successfully parsed: %s"</span>, u2)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参考文献：</p>
<ul>
<li><a href="https://github.com/Knetic/govaluate" target="_blank" rel="external">https://github.com/Knetic/govaluate</a></li>
<li><a href="https://en.wikipedia.org/wiki/Universally_unique_identifier" target="_blank" rel="external">UUID-Wikipedia</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go语言UUID包 // UUID package for Go&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第二期】govaluate</title>
    <link href="http://zablog.me/2017/08/13/github_govaluate/"/>
    <id>http://zablog.me/2017/08/13/github_govaluate/</id>
    <published>2017-08-13T12:30:00.000Z</published>
    <updated>2017-08-15T03:05:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>golang环境下任意表达式的求值 // Arbitrary expression evaluation for golang</p>
<a id="more"></a>
<table>
<thead>
<tr>
<th>名称</th>
<th>govaluate</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/Knetic/govaluate" target="_blank" rel="external">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td>Knetic等</td>
</tr>
<tr>
<td>brief intro</td>
<td>Arbitrary expression evaluation for golang</td>
</tr>
<tr>
<td>简要介绍</td>
<td>golang环境下任意表达式的求值</td>
</tr>
<tr>
<td>LICENSE</td>
<td>MIT</td>
</tr>
<tr>
<td>Stars</td>
<td>245</td>
</tr>
</tbody>
</table>
<p>govaluate提供了任意类似C语言的算术/字符串表达式的求值。</p>
<h2 id="为什么你不应该直接在代码中书写表达式"><a href="#为什么你不应该直接在代码中书写表达式" class="headerlink" title="为什么你不应该直接在代码中书写表达式"></a>为什么你不应该直接在代码中书写表达式</h2><p>有些时候，你并没有办法提前得知表达式的样子，或者你希望表达式可设置。如果你有一堆运行在你的应用上的数据，或者你想要允许你的用户自定义一些内容，或者你写的是一个监控框架，可以获得很多metrics信息，然后进行一些公式计算，那么这个库就会非常有用。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>可以创建一个新的EvaluableExpression，然后调用它的”Evaluate”方法。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   expression, err := govaluate.NewEvaluableExpression(<span class="string">"10 &gt; 0"</span>);</div><div class="line">result, err := expression.Evaluate(<span class="literal">nil</span>);</div><div class="line"><span class="comment">// result is now set to "true", the bool value.</span></div></pre></td></tr></table></figure>
<p>那么，如何使用参数？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">expression, err := govaluate.NewEvaluableExpression(<span class="string">"foo &gt; 0"</span>);</div><div class="line"></div><div class="line">parameters := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">8</span>)</div><div class="line">parameters[<span class="string">"foo"</span>] = <span class="number">-1</span>;</div><div class="line"></div><div class="line">result, err := expression.Evaluate(parameters);</div><div class="line"><span class="comment">// result is now set to "false", the bool value.</span></div></pre></td></tr></table></figure>
<p>这很棒，但是这些基本上可以使用代码直接实现。那么如果计算中牵扯到一些数学计算呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">expression, err := govaluate.NewEvaluableExpression(&quot;(requests_made * requests_succeeded / 100) &gt;= 90&quot;);</div><div class="line"></div><div class="line">parameters := make(map[string]interface&#123;&#125;, 8)</div><div class="line">parameters[&quot;requests_made&quot;] = 100;</div><div class="line">parameters[&quot;requests_succeeded&quot;] = 80;</div><div class="line"></div><div class="line">result, err := expression.Evaluate(parameters);</div><div class="line">// result is now set to &quot;false&quot;, the bool value.</div></pre></td></tr></table></figure>
<p>上述例子返回的都是布尔值，事实上，它是可以返回数字的。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">expression, err := govaluate.NewEvaluableExpression(<span class="string">"(mem_used / total_mem) * 100"</span>);</div><div class="line"></div><div class="line">parameters := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">8</span>)</div><div class="line">parameters[<span class="string">"total_mem"</span>] = <span class="number">1024</span>;</div><div class="line">parameters[<span class="string">"mem_used"</span>] = <span class="number">512</span>;</div><div class="line"></div><div class="line">result, err := expression.Evaluate(parameters);</div><div class="line"><span class="comment">// result is now set to "50.0", the float64 value.</span></div></pre></td></tr></table></figure>
<p>你也可以做一些日期的转化，只要符合RF3339,ISO8061,Unix Date，或者ruby日期格式标准即可。如果你还是不太确定，那么可以看一下支持的<a href="https://github.com/Knetic/govaluate/blob/0580e9b47a69125afa0e4ebd1cf93c49eb5a43ec/parsing.go#L258" target="_blank" rel="external">日期标准</a>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   expression, err := govaluate.NewEvaluableExpression(<span class="string">"'2014-01-02' &gt; '2014-01-01 23:59:59'"</span>);</div><div class="line">result, err := expression.Evaluate(<span class="literal">nil</span>);</div><div class="line"></div><div class="line"><span class="comment">// result is now set to true</span></div></pre></td></tr></table></figure>
<p>表达式只需要进行一次句法分析，就可以多次复用。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   expression, err := govaluate.NewEvaluableExpression(<span class="string">"response_time &lt;= 100"</span>);</div><div class="line">parameters := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="number">8</span>)</div><div class="line"></div><div class="line"><span class="keyword">for</span> &#123;</div><div class="line">	parameters[<span class="string">"response_time"</span>] = pingSomething();</div><div class="line">	result, err := expression.Evaluate(parameters)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于执行顺序，本库支持正常C标准的执行顺序。编写表达式时，请确保您正确地书写操作符，或使用括号来明确表达式的哪些部分应先运行。</p>
<p>govaluate采用\或者[]来完成转义。</p>
<p>支持自定义函数</p>
<p>支持简单的结构体（访问器）</p>
<h2 id="运算符支持"><a href="#运算符支持" class="headerlink" title="运算符支持"></a>运算符支持</h2><p>ruleplatform的表达式引擎支持以下运算：<br>二元计算符 : + - / <em> &amp; | ^ *</em> % &gt;&gt; &lt;&lt;<br>二元比较符 : &gt; &gt;= &lt; &lt;= == != =~ !~<br>逻辑操作符 : || &amp;&amp;<br>括号 : ( )<br>数组相关 : , IN (例子1 IN (1, 2, ‘foo’)，返回值true)<br>一元计算符 : ! - ~<br>三元运算符 : ? :<br>空值聚合符: ??</p>
<p>更多内容请查看<a href="https://github.com/Knetic/govaluate" target="_blank" rel="external">https://github.com/Knetic/govaluate</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;golang环境下任意表达式的求值 // Arbitrary expression evaluation for golang&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>每周一个Github项目【第一期】onionscan</title>
    <link href="http://zablog.me/2017/08/04/github_onion_scan/"/>
    <id>http://zablog.me/2017/08/04/github_onion_scan/</id>
    <published>2017-08-04T12:30:00.000Z</published>
    <updated>2017-08-15T03:05:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>一个用于探查深网的免费开源工具 // A free and open source tool for investigating the Dark Web<br><a id="more"></a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>OnionScan</th>
</tr>
</thead>
<tbody>
<tr>
<td>地址</td>
<td><a href="https://github.com/s-rah/onionscan" target="_blank" rel="external">Github</a></td>
</tr>
<tr>
<td>作者</td>
<td>s-rah等</td>
</tr>
<tr>
<td>Brief Intro</td>
<td>OnionScan is a free and open source tool for investigating the Dark Web.</td>
</tr>
<tr>
<td>LICENSE</td>
<td>MIT</td>
</tr>
<tr>
<td>starts</td>
<td>912</td>
</tr>
</tbody>
</table>
<p>所以这个东西叫做扫描洋葱呗。</p>
<blockquote>
<p>OnionScan是一个用于探查深网（Dark Web）的免费开源工具。对于匿名和隐私空间的所有惊人的技术创新，总是有一个不断的威胁，没有有效的技术补丁，那就是人为错误。</p>
<p>无论是操作安全漏洞还是软件配置错误 - 最常见的是匿名攻击不是来自于破坏底层系统，而是来自于我们自己。</p>
<p>OnionScan有两个主要目标：</p>
<p>希望帮助隐藏服务的运营者找到并修复其服务的操作安全问题。希望帮助他们检测配置错误，希望启发新一代匿名工程项目，保护人们的隐私。</p>
<p>其次，OnionScan希望帮助研究人员和调查人员监控和跟踪黑网站。当然OnionScan并不一定同意调查者的动机，但通过使调查变得容易，希望为新的匿名技术创造一个强大的激励（见目标1）</p>
</blockquote>
<p>OnionScan这个工具的探测能力很强，但是作为一个爬虫类的应用，首先需要一个proxy。该工程使用的是tor proxy，这个我在测试的时候还没有搞定，所以具体实际测试也就没进行。具体作用、效果待研究。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个用于探查深网的免费开源工具 // A free and open source tool for investigating the Dark Web&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Github Every Week" scheme="http://zablog.me/tags/Github-Every-Week/"/>
    
  </entry>
  
  <entry>
    <title>网络实用工具</title>
    <link href="http://zablog.me/2017/05/26/network_utility/"/>
    <id>http://zablog.me/2017/05/26/network_utility/</id>
    <published>2017-05-26T06:48:06.000Z</published>
    <updated>2017-08-15T03:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac OS X 中超方便的网络小工具<br><a id="more"></a></p>
<p>早在互联网的早期，事情并不如现在那么稳定，所以系统管理员创建了一套工具来帮助解决问题。许多老板都记得在命令行中键入ping命令后面跟着一个IP地址的“乐趣”，然后等待看是否有响应。</p>
<p>同样地，traceroute总是有助于找出机器之间通信的计算机，路由器和服务器之间的长链反弹的哪里。 苹果把所有这些有用的工具放在一个名为“网络实用工具”的应用程序中。</p>
<p>旧版本的Mac可以在Applications文件夹的Utilities文件夹中找到网络实用工具，在 OS X Mavericks 和更高版本中，“网络实用工具”位于“/系统/资源库/CoreServices/Applications”中。当然，也可以用spotlight直接搜索“网络实用工具”，更可以丧心病狂地对Siri说“启动网络实用程序”，应用程序立即在您的屏幕上。每个Mac都可以免费使用，并可以很好地解决互联网连接的问题。<br>您可以在网络实用工具中做的一切事情，当然也可以使用unix工具在终端窗口中实际执行此操作。但是，苹果创建了一个很好的应用程序，让我们可以更轻松地使用这些内容。</p>
<p>当您首次打开网络实用程序时，可以看到顶部有9个选项卡。</p>
<p>先做对这些功能的简要介绍（官方）<a href="https://support.apple.com/en-us/HT202790" target="_blank" rel="external">ref</a></p>
<h2 id="功能列表："><a href="#功能列表：" class="headerlink" title="功能列表："></a>功能列表：</h2><ul>
<li>Netstat：通过查看使用常用网络协议发送和接收的数据包类型的详细摘要，来检查您电脑的网络路由表。</li>
<li>Ping：测试您的电脑是否可与位于特定网络地址处的电脑或其他设备进行通信。</li>
<li>Lookup：查看由您的域名系统 (DNS) 服务器提供的信息。</li>
<li>Traceroute：跟踪信息在网络中的电脑之间传输时所采用的路径。</li>
<li>Whois：输入一个域地址，以从 whois 服务器中查找其“whois”信息。</li>
<li>Finger：输入一个用户名和域地址，以使用 Finger 协议来获取有关用户的信息。</li>
<li>端口扫描：输入一个互联网或 IP 地址来扫描打开的端口。</li>
</ul>
<p><img src="https://blog.macsales.com/wp-content/uploads/2016/10/NetworkUtility-1.png" alt="Info"></p>
<h2 id="Info-信息"><a href="#Info-信息" class="headerlink" title="Info 信息"></a>Info 信息</h2><p>信息（见上图）提供了一个下拉菜单，其中列出了Mac内置的每个网络接口。 例如，它显示了显示 Wi-Fi（en0），Thunderbolt 1（en1）和Thunderbolt 13（en2）。 选择任何一个网络接口提供了丰富的信息，包括硬件地址（MAC - 媒体访问控制地址，分配给每个网络接口的唯一编号），IP地址（IPv4），链路速度，链路状态，供应商和模型。</p>
<p>信息屏幕的右侧还显示自Mac上次重新启动以来接口发送或接收的数据包数量。如果可以看到一些错误或冲突，那么丢弃数据包的可能性很小。这通常表现为与网站缓慢的连接，缓慢的下载等。</p>
<h2 id="Netstat"><a href="#Netstat" class="headerlink" title="Netstat"></a>Netstat</h2><p>对于不是网络管理员的大多数Mac用户，Netstat有点深奥。 它提供了一种通过显示使用常用网络协议（TCP，UDP，IP，ICMP，IGMP，IPSEC，IP6，ICMP6，IPSEC6和PFKEY）发送和接收的数据包类型的摘要，来检查您的Mac网络路由表的方法。<br><img src="https://blog.macsales.com/wp-content/uploads/2016/10/NetworkUtility-2-e1475853654240.png" alt="Netstat"></p>
<h2 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h2><p>网络实用程序中可能使用最广泛和最有用的工具可能是ping。 它用于查看您的Mac是否可以与具有已知网络地址的另一个设备通信 - 否则称为“ping”其他设备。例如，如果我在我的iMac（本地网络IP地址10.0.1.6），我想知道我是否可以到达我的AirPort Extreme路由器（本地网络IP地址10.0.1.1），我键入我希望ping的地址 进入网络实用程序的Ping窗格中的字段，然后单击Ping按钮。<br><img src="https://blog.macsales.com/wp-content/uploads/2016/10/NetworkUtility-3.png" alt="ping"></p>
<p>默认情况下，ping向另一台设备发送10个数据包，测量iMac上每次ping接收的时间。 如果响应显示任何或所有ping返回超时，则表示Mac与路由器之间的连接不正确，并且我可以开始解决具有该知识的问题。</p>
<h2 id="Lookup"><a href="#Lookup" class="headerlink" title="Lookup"></a>Lookup</h2><p>如果不是域名系统（DNS）服务器，我们都可以在我们的网络浏览器中输入数字地址以访问网站。 DNS将Web地址（如blog.macsales.com）转换为IP地址，以便我们的计算机可以与Web服务器进行会话。 有时您可能会输入网址，并从网页浏览器中找到“服务器未找到”错误。 这通常表示您错误地输入了地址（如“blurg.macsales.com”），DNS服务器可能存在问题，或DNS服务器地址（在“网络参考”中输入）可能不正确。</p>
<p>Lookup实际上包含两个基本命令 - nslookup和dig。 键入网站的字母数字名称 - 例如“apple.com”，然后单击查找按钮显示与该域名相关联的IP地址，而输入IP地址则显示与该地址相关联的域。 奇怪的是，输入“apple.com”显示的IP地址将“applecentre.info”，“AirTunes.info”和“carbondating.com”作为三个可能的域返回。 前两个地址带你到“apple.com”网站，而第三个地址被遗忘。 我猜？ 苹果公司使用这些奇怪的域名作为抵御对该公司的分布式拒绝服务攻击的一种方式。</p>
<p><img src="https://blog.macsales.com/wp-content/uploads/2016/10/NetworkUtility-4.png" alt="lookup"></p>
<h2 id="traceroute"><a href="#traceroute" class="headerlink" title="traceroute"></a>traceroute</h2><p>网络实用程序中最有用的工具之一是traceroute，它正是这个名称所暗示的 - 它跟踪Mac和另一台机器之间的路由。 看看从本电脑traceroute到美国专利商标局（uspto.gov）会发生什么。</p>
<p><img src="https://blog.macsales.com/wp-content/uploads/2016/10/NetworkUtility-5.png" alt="traceroute"></p>
<p>事情从我的本地网络（10.0.1.1是我的AirPort Extreme Wi-Fi路由器）开始，然后通过各种Comcast系统到达得克萨斯州的达拉斯地区，然后离开ATT网络上的华盛顿特区（wswdc）。 Traceroute在播放Mac和网络服务器之间可以播放一个野蛮的数据包时很有趣。</p>
<h2 id="Whois"><a href="#Whois" class="headerlink" title="Whois"></a>Whois</h2><p>想知道域名背后的实体？ 这就是Whois的一切。 虽然许多组织现在购买域名注册信息的隐私，但仍然可以找到网站使用的域名注册商。 如果您从特定的电子邮件地址收到垃圾邮件并希望向域名注册商投诉，这可能非常有用。</p>
<h2 id="Finger"><a href="#Finger" class="headerlink" title="Finger"></a>Finger</h2><p>Finger创建于1971年，是现在使用微博、QQ完成状态更新的最早形式之一。你可以使用Finger来检查你的朋友是否在线，你可以发布.plan文件到您的个人资料类似博客帖子。</p>
<p>使用Finger的最佳方式之一是在Mac上输入您的用户名或其他用户的用户名。它会告诉你他们/你当前是否登录，以及他们/你上次登录的时间长短。可以把Finger视为独立个体的whois。</p>
<p>幸运的是，现在它已经几乎无法正常工作，它曾经在互联网的原始日子里辉煌过。如今，用户名和域名地址的手指很可能会超时。这对于隐私保护来说是一件好事，而且在这个社交网络已经极其发达的时候，Finger说实在的已经没有什么意义了。</p>
<h2 id="Port-Scan"><a href="#Port-Scan" class="headerlink" title="Port Scan"></a>Port Scan</h2><p>网络实用程序窗口中的最后一个选项卡是端口扫描，可用于确定特定计算机上各种Internet协议端口的状态。 当您的Mac被分配一个特定的IP地址时，它使用的各种服务，包括电子邮件，网页浏览等，都被分配一个TCP或UDP端口号。</p>
<p>在一个非常安全的世界中，在一个非常安全的Mac上，所有的端口将被关闭 - 这就是防火墙的目的，它作为特定端口的网守，只允许特定流量通过该端口进入。 但是你会发现一些端口是开放的 - 在这次扫描中，我关闭了Mac的内置防火墙（在“系统偏好设置”&gt;防火墙中找到），并发现许多端口都是打开的：<br><img src="https://blog.macsales.com/wp-content/uploads/2016/10/NetworkUtility-6.png" alt="Port Scan"><br>要查看特定端口的使用情况，以下是完整列表。 我发现一些端口（445和4502）用于Windows共享和Silverlight; 将Mac的防火墙重新启动没有关闭这些端口，这显然是我在这台机器上使用的一些应用程序所需要的。</p>
<hr>

<p>所以，你现在已经学会这个工具啦。它在网络问题解决方面真的是太方便了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac OS X 中超方便的网络小工具&lt;br&gt;
    
    </summary>
    
      <category term="技术指南" scheme="http://zablog.me/categories/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="OS X" scheme="http://zablog.me/tags/OS-X/"/>
    
  </entry>
  
  <entry>
    <title>多线程的内存排布</title>
    <link href="http://zablog.me/2016/12/26/multithreading_memory/"/>
    <id>http://zablog.me/2016/12/26/multithreading_memory/</id>
    <published>2016-12-26T04:46:23.000Z</published>
    <updated>2016-12-26T03:09:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>写了一小段python代码来测试Linux对于多线程的内存排布。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, t_name)</span>:</span></div><div class="line">        threading.Thread.__init__(self, name=t_name)</div><div class="line">        self.name = t_name</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">print</span> <span class="string">"%s Runs"</span> % self.name</div><div class="line">        <span class="comment"># sleep for 1 minutes.</span></div><div class="line">        time.sleep(<span class="number">60</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    t1 = T(<span class="string">"t1"</span>)</div><div class="line">    t2 = T(<span class="string">"t2"</span>)</div><div class="line">    t3 = T(<span class="string">"t3"</span>)</div><div class="line">    t1.start()</div><div class="line">    t2.start()</div><div class="line">    t3.start()</div><div class="line">    t1.join()</div><div class="line">    t2.join()</div><div class="line">    t3.join()</div><div class="line">    <span class="keyword">print</span> <span class="string">"T1 &amp; T2 reaped."</span></div></pre></td></tr></table></figure>
<p>查看一下maps文件，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$cat</span> /proc/.../maps</div></pre></td></tr></table></figure>
<p>内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">zachary@LABCAT:/mnt/c/Projects/test$ cat /proc/309/maps</div><div class="line">00400000-006bc000 r-x- 00000000 00:00 249355                     /usr/bin/python2.7</div><div class="line">008bb000-008bc000 r--- 002bb000 00:00 249355                     /usr/bin/python2.7</div><div class="line">008bc000-00931000 rw-- 002bc000 00:00 249355                     /usr/bin/python2.7</div><div class="line">00931000-00943000 rw-- 00000000 00:00 0</div><div class="line">020cb000-0219c000 rw-- 00000000 00:00 0                          [heap]</div><div class="line">7f0a4c000000-7f0a4c021000 rw-- 00000000 00:00 0</div><div class="line">7f0a4c021000-7f0a50000000 ---- 00000000 00:00 0</div><div class="line">7f0a50000000-7f0a50021000 rw-- 00000000 00:00 0</div><div class="line">7f0a50021000-7f0a54000000 ---- 00000000 00:00 0</div><div class="line">7f0a54000000-7f0a54021000 rw-- 00000000 00:00 0</div><div class="line">7f0a54021000-7f0a58000000 ---- 00000000 00:00 0</div><div class="line">7f0a58910000-7f0a58911000 ---- 00000000 00:00 0</div><div class="line">7f0a58911000-7f0a59111000 rw-- 00000000 00:00 0</div><div class="line">7f0a59120000-7f0a59121000 ---- 00000000 00:00 0</div><div class="line">7f0a59121000-7f0a59921000 rw-- 00000000 00:00 0</div><div class="line">7f0a59930000-7f0a59931000 ---- 00000000 00:00 0</div><div class="line">7f0a59931000-7f0a5a131000 rw-- 00000000 00:00 0</div><div class="line">7f0a5a137000-7f0a5a2c0000 r--- 00000000 00:00 119790             /usr/lib/locale/locale-archive</div><div class="line">7f0a5a2c0000-7f0a5a3c5000 r-x- 00000000 00:00 34505              /lib/x86_64-linux-gnu/libm-2.19.so</div><div class="line">7f0a5a3c5000-7f0a5a3c6000 ---- 00105000 00:00 34505              /lib/x86_64-linux-gnu/libm-2.19.so</div><div class="line">7f0a5a3c6000-7f0a5a5c4000 ---- 00000000 00:00 0</div><div class="line">7f0a5a5c4000-7f0a5a5c5000 r--- 00104000 00:00 34505              /lib/x86_64-linux-gnu/libm-2.19.so</div><div class="line">7f0a5a5c5000-7f0a5a5c6000 rw-- 00105000 00:00 34505              /lib/x86_64-linux-gnu/libm-2.19.so</div><div class="line">7f0a5a5d0000-7f0a5a5e8000 r-x- 00000000 00:00 34714              /lib/x86_64-linux-gnu/libz.so.1.2.8</div><div class="line">7f0a5a5e8000-7f0a5a5e9000 ---- 00018000 00:00 34714              /lib/x86_64-linux-gnu/libz.so.1.2.8</div><div class="line">7f0a5a5e9000-7f0a5a7e7000 ---- 00000000 00:00 0</div><div class="line">7f0a5a7e7000-7f0a5a7e8000 r--- 00017000 00:00 34714              /lib/x86_64-linux-gnu/libz.so.1.2.8</div><div class="line">7f0a5a7e8000-7f0a5a7e9000 rw-- 00018000 00:00 34714              /lib/x86_64-linux-gnu/libz.so.1.2.8</div><div class="line">7f0a5a7f0000-7f0a5a7f2000 r-x- 00000000 00:00 34384              /lib/x86_64-linux-gnu/libutil-2.19.so</div><div class="line">7f0a5a7f2000-7f0a5a7f3000 ---- 00002000 00:00 34384              /lib/x86_64-linux-gnu/libutil-2.19.so</div><div class="line">7f0a5a7f3000-7f0a5a9f1000 ---- 00000000 00:00 0</div><div class="line">7f0a5a9f1000-7f0a5a9f2000 r--- 00001000 00:00 34384              /lib/x86_64-linux-gnu/libutil-2.19.so</div><div class="line">7f0a5a9f2000-7f0a5a9f3000 rw-- 00002000 00:00 34384              /lib/x86_64-linux-gnu/libutil-2.19.so</div><div class="line">7f0a5aa00000-7f0a5aa03000 r-x- 00000000 00:00 34478              /lib/x86_64-linux-gnu/libdl-2.19.so</div><div class="line">7f0a5aa03000-7f0a5aa04000 ---- 00003000 00:00 34478              /lib/x86_64-linux-gnu/libdl-2.19.so</div><div class="line">7f0a5aa04000-7f0a5ac02000 ---- 00000000 00:00 0</div><div class="line">7f0a5ac02000-7f0a5ac03000 r--- 00002000 00:00 34478              /lib/x86_64-linux-gnu/libdl-2.19.so</div><div class="line">7f0a5ac03000-7f0a5ac04000 rw-- 00003000 00:00 34478              /lib/x86_64-linux-gnu/libdl-2.19.so</div><div class="line">7f0a5ac10000-7f0a5adca000 r-x- 00000000 00:00 34759              /lib/x86_64-linux-gnu/libc-2.19.so</div><div class="line">7f0a5adca000-7f0a5add2000 ---- 001ba000 00:00 34759              /lib/x86_64-linux-gnu/libc-2.19.so</div><div class="line">7f0a5add2000-7f0a5afca000 ---- 00000000 00:00 0</div><div class="line">7f0a5afca000-7f0a5afce000 r--- 001ba000 00:00 34759              /lib/x86_64-linux-gnu/libc-2.19.so</div><div class="line">7f0a5afce000-7f0a5afd0000 rw-- 001be000 00:00 34759              /lib/x86_64-linux-gnu/libc-2.19.so</div><div class="line">7f0a5afd0000-7f0a5afd5000 rw-- 00000000 00:00 0</div><div class="line">7f0a5afe0000-7f0a5aff9000 r-x- 00000000 00:00 34736              /lib/x86_64-linux-gnu/libpthread-2.19.so</div><div class="line">7f0a5aff9000-7f0a5b003000 ---- 00019000 00:00 34736              /lib/x86_64-linux-gnu/libpthread-2.19.so</div><div class="line">7f0a5b003000-7f0a5b1f8000 ---- 00000000 00:00 0</div><div class="line">7f0a5b1f8000-7f0a5b1f9000 r--- 00018000 00:00 34736              /lib/x86_64-linux-gnu/libpthread-2.19.so</div><div class="line">7f0a5b1f9000-7f0a5b1fa000 rw-- 00019000 00:00 34736              /lib/x86_64-linux-gnu/libpthread-2.19.so</div><div class="line">7f0a5b1fa000-7f0a5b1fe000 rw-- 00000000 00:00 0</div><div class="line">7f0a5b200000-7f0a5b223000 r-x- 00000000 00:00 34451              /lib/x86_64-linux-gnu/ld-2.19.so</div><div class="line">7f0a5b2e0000-7f0a5b3d1000 rw-- 00000000 00:00 0</div><div class="line">7f0a5b3e0000-7f0a5b421000 rw-- 00000000 00:00 0</div><div class="line">7f0a5b422000-7f0a5b423000 r--- 00022000 00:00 34451              /lib/x86_64-linux-gnu/ld-2.19.so</div><div class="line">7f0a5b423000-7f0a5b424000 rw-- 00023000 00:00 34451              /lib/x86_64-linux-gnu/ld-2.19.so</div><div class="line">7f0a5b424000-7f0a5b425000 rw-- 00000000 00:00 0</div><div class="line">7f0a5b430000-7f0a5b4b2000 rw-- 00000000 00:00 0</div><div class="line">7f0a5b4c0000-7f0a5b4c1000 rw-- 00000000 00:00 0</div><div class="line">7f0a5b4d0000-7f0a5b4d1000 rw-- 00000000 00:00 0</div><div class="line">7f0a5b4e0000-7f0a5b4e1000 rw-- 00000000 00:00 0</div><div class="line">7f0a5b4f0000-7f0a5b4f2000 rw-- 00000000 00:00 0</div><div class="line">7ffff2573000-7ffff2d73000 rw-- 00000000 00:00 0                  [stack]</div><div class="line">7ffff2f6b000-7ffff2f6c000 r-x- 00000000 00:00 0                  [vdso]</div></pre></td></tr></table></figure></p>
<p>每一个子线程的stack都是放在一起的，而且默认分配好了一块比较大的空间。<br>当然，用python来测试这个内容是不太合理的，最好还是用C来测试。推荐看一下参考内容1。</p>
<p>由上面的内容可以推断出大致的虚存结构：<br><img src="http://imglf0.nosdn.127.net/img/MGpGUW9CdGlzcDd1cm1TOXdxeWIwWGpxSHFVb0RIdUd2NnBndGRVMElhTnRmYXVkaG1Ca253PT0.png?imageView&amp;thumbnail=1680x0&amp;quality=96&amp;stripmeta=0&amp;type=jpg%7Cwatermark&amp;type=2&amp;text=wqkgWmFjaGFyeSAvIG1hcmNob24ubG9mdGVyLmNvbQ==&amp;font=bXN5aA==&amp;gravity=southwest&amp;dissolve=30&amp;fontsize=340&amp;dx=16&amp;dy=20&amp;stripmeta=0" alt="图片"></p>
<p>参考内容：</p>
<ul>
<li><a href="http://blog.csdn.net/high_high/article/details/7204097" target="_blank" rel="external">参考内容1_多线程程序在内存中的分布</a></li>
<li><a href="http://stackoverflow.com/questions/18149218/the-memory-layout-of-a-multithreaded-process" target="_blank" rel="external">参考内容2_StackOverflow</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写了一小段python代码来测试Linux对于多线程的内存排布。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div cl
    
    </summary>
    
      <category term="技术指南" scheme="http://zablog.me/categories/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="Linux" scheme="http://zablog.me/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Web3.0的定义</title>
    <link href="http://zablog.me/2016/12/05/Web3.0/"/>
    <id>http://zablog.me/2016/12/05/Web3.0/</id>
    <published>2016-12-05T06:44:52.000Z</published>
    <updated>2016-12-07T11:47:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>上学期当助教讲到Web章节总结的一点点极为浅显的基础知识。</p>
<p>Web1.0注重于信息的单向发布，像一个权威不容修改。</p>
<p>Web2.0使得用户既是内容的浏览者，又是内容的发布者，更加注重交互性。</p>
<p>Web3.0的信息可以通过第三方信息平台对多家网站的信息进行整合使用。</p>
<p>HTML5是对HTML的第五次重大修改，它的本质是一套标准（HTML5不是一个程序，新版的Chrome、Edge、Firefox、Safari等浏览器，都可以认为是对同一套标准的不同实现）。它更注重移动端的体验，使得各种服务无缝连接。</p>
<p>我总结了几个重点新特性：</p>
<ol>
<li><p>新增语义标签，使得语义更丰富（以前各种苍白的div，现在可以用header、rooter做标签）</p>
</li>
<li><p>本地缓存带来更快的联网速度，还有更有效的服务器推送技术。</p>
</li>
<li><p>更广泛的接口带来更好的设备兼容性（譬如通过Geolocation这种API，开发者可以申请获得用户位置。这也是手机网页版可以在订餐、查地图、租车的时候瞬间确定用户位置的原因。）</p>
</li>
<li><p>更好的网络多媒体特性（网上看视频的时候使用HTML5技术代替原始的Flash，可以更快、能耗更低、安全性更高）</p>
</li>
<li><p>三维图形以及特效特性（SVG、Canvas、WebGL以及CSS3带来惊艳的显示效果）</p>
</li>
</ol>
<p>Cgi可以用不同的语言实现，最常用的是使用perl实现，也可以采用C\C++实现。本节课展示的就是使用C实现CGI的一个例子。</p>
<p>为什么讲CGI，因为在CGI之前，网页都是静态的，CGI开创的动态网页的先河。不过现在CGI也渐渐过时，很难完成大型平台的开发，也很难完成小型平台的快速开发。</p>
<p>CGI FastCGI ASP PHP ColdFusion JSP ASP.NET 等都是常用的主流的动态网页技术。</p>
<p>发展过程中，有一个特性是MVC。MVC是一种软件设计的模式，把模型model-视图-view-控制器-controller分离开。</p>
<p>传统的CGI可以说是把模型、视图、控制器混在一起，靠开发者自己区分，逻辑会比较乱，影响开发效率，MVC出现以后越来越受到开发者的欢迎，也经常被现代Web技术所使用。</p>
]]></content>
    
    <summary type="html">
    
      Web1.0注重于信息的单向发布，像一个权威不容修改。Web2.0使得用户既是内容的浏览者，又是内容的发布者，更加注重交互性。Web3.0的信息可以通过第三方信息平台对多家网站的信息进行整合使用。
    
    </summary>
    
      <category term="技术指南" scheme="http://zablog.me/categories/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"/>
    
    
  </entry>
  
  <entry>
    <title>基于移动传感数据的差分隐私</title>
    <link href="http://zablog.me/2016/10/03/DP/"/>
    <id>http://zablog.me/2016/10/03/DP/</id>
    <published>2016-10-03T03:22:52.000Z</published>
    <updated>2016-10-03T02:51:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>差分隐私（<a href="https://en.wikipedia.org/wiki/Differential_privacy" target="_blank" rel="external">Differential Privacy</a>）的概念已经出现了大概10年了。在密码学中，差分隐私的目的是提供一个机制来最大化统计上查询的准确性，同时最小化识别其个别记录的机会。</p>
<p>差分隐私概念的产生还是要从十年前Netflix举办的机器学习大赛说起。Netflix放出了用户的数据给参赛者，希望参赛者可以给出一个更好的推荐算法。虽然Netflix已经隐去了用户ID、Name等可以直接辨识用户身份的信息，但是还是有人通过匹配网上的数据，找到了大批数据所对应的个人，这相当于让这些数据所对应的隐私直接泄露。</p>
<p>因此就出现了差分隐私的方法。推荐一个优秀的网站 <a href="https://beta.dataverse.org/custom/DifferentialPrivacyPrototype/" target="_blank" rel="external">Privacy Tools</a>。</p>
<p>苹果的WWDC2016用了一个session来讲解差分隐私的概念，并且宣称要开始大规模使用这一技术来统计用户的信息。这也是这项技术产生十年以来第一次大规模地投入业界。</p>
<p>但是对于移动传感数据来说，并不是所有的数据都能直接使用这个技术。</p>
<ol>
<li>传感器数据经常会遵循某一种模式，例如心跳速度是一定位于一个可能区间内的。</li>
<li>传感器数据通常会相互联系。比如加速度传感器数据很高的时候，螺旋仪检测的速度一般也会上升，而且心率、体温一般都会有所升高。</li>
</ol>
<p>因此，简单地使用噪声的增加是不够合理的。当数据进入不太可信的空间的时候，作为黑客可以尽可能地把不合理的数据隐去，力图找到合理的数据，有很大的可能性进行反推。同时，当多个变量相关联的时候，又进一步增大了这种反推的能力。</p>
<p>因此，如果让移动传感器的数据也使用差分隐私的技术安全地释放出去。必须首先判定用户所处的状态，然后对于这个状态进行差分隐私加噪声，最后再还原出来一个虚拟的raw数据，最终把这个数据释放，才能够达到良好的效果。</p>
]]></content>
    
    <summary type="html">
    
      差分隐私的概念已经出现了大概10年了。在密码学中，差分隐私的目的是提供一个机制来最大化统计上查询的准确性，同时最小化识别其个别记录的机会。但是对于移动传感数据来说，并不是所有的数据都能直接使用这个技术。
    
    </summary>
    
      <category term="技术指南" scheme="http://zablog.me/categories/%E6%8A%80%E6%9C%AF%E6%8C%87%E5%8D%97/"/>
    
    
      <category term="DP" scheme="http://zablog.me/tags/DP/"/>
    
  </entry>
  
</feed>
